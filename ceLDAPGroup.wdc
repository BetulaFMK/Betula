#To edit and compare internal_properties, use WINDEV integrated tools.
#Internal properties refer to the properties of controls in windows, reports, etc.
info :
 name : ceLDAPGroup
 major_version : 29
 minor_version : 0
 type : 4
 description : ""
 subtype : 0
class :
 identifier : 0x11f1f623037d16b6
 internal_properties : CQAAAAkAAAB2/vstTMCJbS/hlxjFxirSqKvCUuv8YxgpWyl7S3iA
 code_elements :
  type_code : 10
  p_codes :
   -
     code : |1-
      //*************************************************************************************************************************************************************************
      //Ce fichier fait partie de Betula.
      //Betula est un logiciel libre ; vous pouvez le redistribuer ou le modifier suivant les termes de la GNU Lesser General Public License telle que publiée par la Free Software Foundation ; soit la version 3 de la licence, soit (à votre gré) toute version ultérieure.
      //Betula est distribué dans l'espoir qu'il sera utile, mais SANS AUCUNE GARANTIE ; sans même la garantie tacite de QUALITÉ MARCHANDE ou d'ADÉQUATION à UN BUT PARTICULIER. Consultez la GNU Lesser General Public License pour plus de détails.
      //Vous devez avoir reçu une copie de la GNU Lesser General Public License en même temps que Betula ; si ce n'est pas le cas, consultez <http://www.gnu.org/licenses>.
      //
      //This file is part of Betula.
      //Betula is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
      //Betula is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
      //You should have received a copy of the GNU Lesser General Public License along with Betula. If not, see <https://www.gnu.org/licenses/>
      //*************************************************************************************************************************************************************************
      
      //Classe de base de type Groupe dans le LDAP.  
      
      CONSTANTE																			//Ref : https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-adts/11972272-09ec-4a42-bf5e-3e99b321cf55
      	GROUP_TYPE_BUILTIN_LOCAL_GROUP	= 0x00000001
      	GROUP_TYPE_ACCOUNT_GROUP		= 0x00000002
      	GROUP_TYPE_RESOURCE_GROUP		= 0x00000004
      	GROUP_TYPE_UNIVERSAL_GROUP		= 0x00000008
      	GROUP_TYPE_APP_BASIC_GROUP		= 0x00000010
      	GROUP_TYPE_APP_QUERY_GROUP		= 0x00000020
      	GROUP_TYPE_SECURITY_ENABLED		= 0x80000000
      FIN
      ceLDAPGroup est une Classe															//Pas déclarée comme abstraite car elle peut être appelée directement dans cSourceDeDonnées.Liste
      	hérite de cEnregistrementLDAP
      PROTÉGÉ
      	m_pclUsers					est un csdLDAPUser dynamique 	<sérialise = faux>	//Liste des utilisateurs faisant partie du groupe (pas cSourceDeDonnéesLDAP() dynamique ou objet dynamique car p_pclUsers.m_tabUser affiche une erreur dans le code appelant)
      	m_pclSubGroups				est un csdldapgroup dynamique	<sérialise = faux>	//Liste des sous-groupes faisant partie du groupe (pas cSourceDeDonnéesLDAP() dynamique ou objet dynamique car p_pclUsers.m_tabUser affiche une erreur dans le code appelant)
      	m_pclContacts				est un csdLDAPContact dynamique	<sérialise = faux>	//Liste des contacts faisant partie du groupe (pas cSourceDeDonnéesLDAP() dynamique ou objet dynamique car p_pclUsers.m_tabUser affiche une erreur dans le code appelant)
      GLOBAL PUBLIC
      	mg_sAttributsALire			est une chaine					<Sérialise = Faux>	//Liste des attributs à lire pour le type Groupe séparés par des virgules
      FIN
     type : 131072
  procedures :
   -
     name : Constructeur
     procedure_id : 1293085198274926262
     type_code : 27
     code : |1-
      // Résumé : Initialisation de la classe lors de sa création.
      // Syntaxe : Constructeur (<nIndiceDeConnexion> est entier [, <sOrganizationalUnit> est chaîne ANSI [, <bLectureSeule> est booléen [, <sAttributsALire> est chaîne]]])
      // Paramètres :
      //	nIndiceDeConnexion (entier) : Indique l'indice de connexion pour accéder au LDAP.
      //	sOrganizationalUnit (chaîne ANSI optionnelle) : Nom de la OU à laquelle est liée le groupe.
      // 	bLectureSeule (booléen optionnel) : Indique de l'enregistrement est en lecture seule (dépend uniquement de la programmation).
      //	sAttributsALire (chaîne UNICODE optionnelle) : Liste des attributs à lire séparés par des virgules, par défaut les attributs mis dans le membre global pour le type Groupe.
      // Valeur de retour : Aucune
      // Exemple :
      //
      PROCEDURE Constructeur(nIndiceDeConnexion est un entier,sOrganizationalUnit est une chaine ansi = "",bLectureSeule est un booléen = Faux,sAttributsALire est une chaîne = ceLDAPGroup.mg_sAttributsALire)
      cEnregistrementLDAP.Constructeur(nIndiceDeConnexion,cEnregistrementLDAP._ADTypeGroup,sOrganizationalUnit,bLectureSeule,sAttributsALire)
     type : 589824
   -
     name : Destructeur
     procedure_id : 1293085198274991798
     type_code : 28
     code : |1-
      // Résumé : La méthode effectue les opérations de nettoyage nécessaires lors de la destruction de l'instance de la classe.
      // Syntaxe : Destructeur()
      // Paramètres : Aucun
      // Valeur de retour : Aucune
      // Exemple :
      PROCEDURE Destructeur()
     type : 655360
   -
     name : RechercheSelonNomCommunDuGroupe
     procedure_id : 1293086512540336065
     type_code : 12
     code : |1-
      // Résumé : Recherche un groupe LDAP en utilisant son nom commun (common name) dans un contexte spécifié.
      // Syntaxe : [ <Résultat> = ] RechercheSelonNomCommunDuGroupe (<sNomDuGroupe> est chaîne [, <sOrganizationalUnit> est chaîne ANSI [, <sLireAttributs> est chaîne]])
      // Paramètres :
      //	sNomDuGroupe (chaîne UNICODE) : Le nom commun (common name) du groupe à rechercher. 
      //	sOrganizationalUnit (chaîne ANSI optionnelle) : L'unité organisationnelle LDAP dans laquelle rechercher le groupe. Par défaut, celle passée dans le constructeur.
      //	sLireAttributs (chaîne UNICODE optionnelles) : Liste des attributs à lire lors de la recherche, séparés par des virgules. Par défaut, celle passée dans le constructeur. 
      // Valeur de retour : booléen : Vrai si la recherche aboutit à un groupe LDAP, Faux sinon.
      // Exemple :
      //
      PROCEDURE RechercheSelonNomCommunDuGroupe(sNomDuGroupe est une chaine,sOrganizationalUnit est une chaine ansi = m_sOUouGroupe,sLireAttributs est une chaine = m_sAttributsALire) : booleen
      SI cApplication._Application<>Null _ET_ cApplication._Application.m_pclTrace<>Null ALORS cApplication._Application.m_pclTrace.AjouteMéthode(sNomDuGroupe,sLireAttributs)	//on ne peut pas changer l'attribut de mot de passe donc pas de cryptage
      m_pclErreur.Raz()
      
      SI m_sSessionAD="" 	ALORS m_pclErreur.AjouteErreur(<§$0004§>)
      SI sNomDuGroupe~="" ALORS m_pclErreur.AjouteErreur(<§$0005§>)
      SI p_sErreur>"" 	ALORS RENVOYER Faux
      
      SI PAS Recherche("(&(objectCategory=group)(cn=" +sNomDuGroupe+"))",sOrganizationalUnit,sLireAttributs) ALORS
      	SI Recherche("(ou=" +sNomDuGroupe+")",sOrganizationalUnit,sLireAttributs) ALORS m_eType=cEnregistrementLDAP._ADTypeOrganizationalUnit;RENVOYER Vrai
      SINON
      	m_eType=cEnregistrementLDAP._ADTypeGroup
      	RENVOYER Vrai
      FIN
      RENVOYER Faux
     type : 458752
   -
     name : Écrit
     procedure_id : 1293086697223972818
     type_code : 12
     code : |1-
      // Résumé : Écrit les modifications apportées à un groupe LDAP, y compris l'ajout et la suppression de membres (utilisateurs, sous-groupes, contacts). Elle effectue une écriture LDAP, en ajoutant les nouveaux membres et en supprimant ceux qui ont été marqués comme supprimés.
      // Syntaxe : [ <Résultat> = ] Écrit ( [<sOrganizationalUnit> est chaîne ANSI])
      // Paramètres :
      //	sOrganizationalUnit (chaîne ANSI optionnelle) : L'unité organisationnelle LDAP dans laquelle effectuer l'écriture. Par défaut, celle passée dans le constructeur.
      // Valeur de retour : booléen : Vrai si l'écriture LDAP est réussie, Faux sinon.
      // Exemple :
      //
      PROCEDURE Écrit(sOrganizationalUnit est une chaine ansi = m_sOUouGroupe) : booleen
      bNouveau est un booleen = (m_sValCléEnCours="")
      
      SI cEnregistrementLDAP.Ecrit(sOrganizationalUnit) ALORS
      	
      
      <si CibleExécution=ApplicationWindows ou CibleExécution=SiteWindows ou CibleExécution=AssemblageDotNet ou CibleExécution=ServiceWindows>
      	
      		//membres du groupe
      		SI m_pclUsers<>Null _OU_ m_pclSubGroups<>Null _OU_ m_pclContacts<>Null ALORS
      			sNouveaux,sUsers,sSubGroups,sContacts est une chaine
      			SI m_pclUsers<>Null ALORS
      				POUR TOUT pclUser de {"m_pclUsers.m_tabUser",indVariable}
      					SI Position({"m_pclUsers.m_sDNMembres"},pclUser.dn,0,MotComplet)<1 ALORS sUsers+=[RC]+pclUser.dn;sNouveaux+=[RC]+pclUser.dn
      				FIN
      			FIN
      			SI m_pclSubGroups<>Null ALORS
      				POUR TOUT pclSubGroup de {"m_pclSubGroups.m_tabGroupe",indVariable}
      					SI Position({"m_pclSubGroups.m_sDNMembres"},pclSubGroup.dn,0,MotComplet)<1 ALORS sSubGroups+=[RC]+pclSubGroup.dn;sNouveaux+=[RC]+pclSubGroup.dn
      				FIN
      			FIN
      			SI m_pclContacts<>Null ALORS
      				POUR TOUT pclContact de {"m_pclContacts.m_tabContact",indVariable}
      					SI Position({"m_pclContacts.m_sDNMembres"},pclContact.dn,0,MotComplet)<1 ALORS sContacts+=[RC]+pclContact.dn;sNouveaux+=[RC]+pclContact.dn
      				FIN
      			FIN
      			cApplication._Application.m_pclTrace.AjouteTexte("nouveaux membres : "+sNouveaux)
      			SI sNouveaux>"" ALORS
      				LDAPDébutModification(m_sSessionAD)
      				POUR TOUTE CHAÎNE sDN de sNouveaux separee par rc
      					SI PAS LDAPAjouteAttribut(m_sSessionAD,"member",UnicodeVersAnsi(sDN)) ALORS m_pclErreur.AjouteErreurWx();RENVOYER Faux
      				FIN
      				SI LDAPValideModification(m_sSessionAD,dn) ALORS 
      					SI m_pclUsers<>Null 	ALORS {"m_pclUsers.m_sDNMembres"}		+=[RC]+sUsers
      					SI m_pclSubGroups<>Null ALORS {"m_pclSubGroups.m_sDNMembres"}	+=[RC]+sSubGroups
      					SI m_pclContacts<>Null 	ALORS {"m_pclContacts.m_sDNMembres"}	+=[RC]+sContacts
      				SINON
      					m_pclErreur.AjouteErreurWx();RENVOYER Faux
      				FIN
      			FIN
      		FIN
      		SI (m_pclUsers<>Null _ET_ {"m_pclUsers.m_tabSupprimé",indVariable}..Occurrence>0) _OU_ (m_pclSubGroups<>Null _ET_ {"m_pclSubGroups.m_tabSupprimé",indVariable}..Occurrence>0) _OU_ ...
      			(m_pclContacts<>Null _ET_ {"m_pclContacts.m_tabSupprimé",indVariable}..Occurrence>0) ALORS
      			sSupprimés est une chaine
      			SI m_pclUsers<>Null _ET_ {"m_pclUsers.m_tabSupprimé",indVariable}..Occurrence>0 ALORS
      				POUR TOUT pclUser de {"m_pclUsers.m_tabSupprimé",indVariable}
      					sSupprimés+=[RC]+pclUser.dn
      				FIN
      			FIN
      			SI m_pclSubGroups<>Null _ET_ {"m_pclSubGroups.m_tabSupprimé",indVariable}..Occurrence>0 ALORS
      				POUR TOUT pclSubGroup de {"m_pclSubGroups.m_tabSupprimé",indVariable}
      					sSupprimés+=[RC]+pclSubGroup.dn
      				FIN
      			FIN
      			SI m_pclContacts<>Null _ET_ {"m_pclContacts.m_tabSupprimé",indVariable}..Occurrence>0 ALORS
      				POUR TOUT pclContact de {"m_pclContacts.m_tabSupprimé",indVariable}
      					sSupprimés+=[RC]+pclContact.dn
      				FIN
      			FIN
      			SI sSupprimés>"" ALORS
      				cApplication._Application.m_pclTrace.AjouteTexte("membres à enlever : "+sSupprimés)
      				LDAPDébutModification(m_sSessionAD)
      				POUR TOUTE CHAÎNE sDN de sSupprimés separee par rc
      					SI PAS LDAPSupprimeValeurAttribut(m_sSessionAD,"member",UnicodeVersAnsi(sDN)) ALORS m_pclErreur.AjouteErreurWx();RENVOYER Faux
      				FIN
      				SI LDAPValideModification(m_sSessionAD,dn) ALORS 
      					SI m_pclUsers<>Null 	ALORS TableauSupprimeTout({"m_pclUsers.m_tabSupprimé",indVariable})
      					SI m_pclSubGroups<>Null ALORS TableauSupprimeTout({"m_pclSubGroups.m_tabSupprimé",indVariable})
      					SI m_pclContacts<>Null 	ALORS TableauSupprimeTout({"m_pclContacts.m_tabSupprimé",indVariable})
      				SINON
      					m_pclErreur.AjouteErreurWx();RENVOYER Faux
      				FIN
      			FIN
      	FIN
      	
      <fin>
      
      	
      	RENVOYER Vrai
      SINON
      	RENVOYER Faux
      FIN
     type : 458752
   -
     name : SubGroupsCharge
     procedure_id : 1293087315699407306
     type_code : 12
     code : |1-
      // Résumé : Charge les sous-groupes d'un groupe LDAP. 
      // Syntaxe : [ <Résultat> = ] SubGroupsCharge ( [<xNomObjetListe> [, <xNomObjetFiche> [, <sFiltres> [, <nLimiteMax> est entier [, <sAttributsALire> est chaîne [, <bLectureSeule> est booléen]]]]]])
      // Paramètres :
      // 	xNomObjetListe (valeur optionnelle) : L'objet représentant la liste des sous-groupes. Si la valeur est Null, la méthode sélectionne automatiquement la classe appropriée en fonction de la version du serveur LDAP.
      // 	xNomObjetFiche (valeur optionnelle) : L'objet représentant la fiche d'un sous-groupe. Si la valeur est Null, la méthode sélectionne automatiquement la classe appropriée en fonction de la version du serveur LDAP.
      // 	sFiltres (optionnel) : Les filtres à appliquer lors de la récupération des sous-groupes.
      // 	nLimiteMax (entier optionnel) : Le nombre maximum de sous-groupes à charger. Par défaut, la valeur est 0 pour charger tous les sous-groupes.
      //	sAttributsALire (chaîne UNICODE optionnelle) : Les attributs à lire pour chaque sous-groupe séparés par des virgules, par défaut Tous.
      //	bLectureSeule (booléen optionnel) : Indique si l'opération de chargement doit être en mode lecture seule, par défaut le même indicateur que cette instance. 
      // Valeur de retour : booléen : Vrai si le chargement des sous-groupes est réussi, Faux sinon.
      // Exemple :
      //
      PROCEDURE SubGroupsCharge(xNomObjetListe = null,xNomObjetFiche = null,sFiltres = "",nLimiteMax est un entier = 0,sAttributsALire est une chaine = "",bLectureSeule est un booleen = p_bLectureSeule) : booleen	//ne pas typer sFiltre
      VariableRAZ(m_pclSubGroups)
      SELON cBaseDeDonnéesLDAP.mg_taServeurVersion[cBaseDeDonnées.mg_tabConnexion[p_nIndiceDeConnexion].sNomUnique]
      	CAS cBaseDeDonnées.EVersionServeur.WindowsServer2000..Valeur 	
      		SI MesParamètres[1]..Défaut ALORS xNomObjetListe=csdLDAP2000Group
      		SI MesParamètres[2]..Défaut ALORS xNomObjetFiche=ceLDAP2000Group
      	CAS cBaseDeDonnées.EVersionServeur.WindowsServer2003..Valeur 	
      		SI MesParamètres[1]..Défaut ALORS xNomObjetListe=csdLDAP2003Group
      		SI MesParamètres[2]..Défaut ALORS xNomObjetFiche=ceLDAP2003Group
      	CAS cBaseDeDonnées.EVersionServeur.WindowsServer2003R2..Valeur 	
      		SI MesParamètres[1]..Défaut ALORS xNomObjetListe=csdLDAP2003R2Group
      		SI MesParamètres[2]..Défaut ALORS xNomObjetFiche=ceLDAP2003R2Group
      	CAS cBaseDeDonnées.EVersionServeur.WindowsServer2008..Valeur 	
      		SI MesParamètres[1]..Défaut ALORS xNomObjetListe=csdLDAP2008Group
      		SI MesParamètres[2]..Défaut ALORS xNomObjetFiche=ceLDAP2008Group
      	CAS cBaseDeDonnées.EVersionServeur.WindowsServer2008R2..Valeur 	
      		SI MesParamètres[1]..Défaut ALORS xNomObjetListe=csdLDAP2008R2Group
      		SI MesParamètres[2]..Défaut ALORS xNomObjetFiche=ceLDAP2008R2Group
      	CAS cBaseDeDonnées.EVersionServeur.WindowsServer2012..Valeur
      		SI MesParamètres[1]..Défaut ALORS xNomObjetListe=csdLDAP2012Group
      		SI MesParamètres[2]..Défaut ALORS xNomObjetFiche=ceLDAP2012Group
      	AUTRES CAS
      		m_pclErreur.AjouteErreur(<§$0003§>+cBaseDeDonnéesLDAP.mg_taServeurVersion[cBaseDeDonnées.mg_tabConnexion[p_nIndiceDeConnexion].sNomUnique])
      		RENVOYER Faux
      FIN
      SI xNomObjetListe<>Null _ET_ xNomObjetFiche<>Null ALORS
      	m_pclSubGroups = allouer un xNomObjetListe (p_nIndiceDeConnexion,xNomObjetFiche,"",bLectureSeule,sAttributsALire)
      	RENVOYER m_pclSubGroups.Liste(objet,sFiltres,nLimiteMax,bLectureSeule)
      FIN
      RENVOYER Faux
     type : 458752
   -
     name : UsersCharge
     procedure_id : 1293087539037758569
     type_code : 12
     code : |1-
      // Résumé : Charge les utilisateurs d'un groupe LDAP. 
      // Syntaxe : [ <Résultat> = ] UsersCharge ( [<xNomObjetListe> [, <xNomObjetFiche> [, <sFiltres> [, <nLimiteMax> est entier [, <sAttributsALire> est chaîne [, <bLectureSeule> est booléen]]]]]])
      // Paramètres :
      // 	xNomObjetListe (valeur optionnelle) : L'objet représentant la liste des utilisateurs. Si la valeur est Null, la méthode sélectionne automatiquement la classe appropriée en fonction de la version du serveur LDAP.
      // 	xNomObjetFiche (valeur optionnelle) : L'objet représentant la fiche d'un utilisateur. Si la valeur est Null, la méthode sélectionne automatiquement la classe appropriée en fonction de la version du serveur LDAP.
      // 	sFiltres (optionnel) : Les filtres à appliquer lors de la récupération des utilisateurs. Par défaut, ceux dont le statut est actif.
      // 	nLimiteMax (entier optionnel) : Le nombre maximum de utilisateurs à charger. Par défaut, la valeur est 0 pour charger tous les utilisateurs.
      //	sAttributsALire (chaîne UNICODE optionnelle) : Les attributs à lire pour chaque utilisateur séparés par des virgules, par défaut Tous.
      //	bLectureSeule (booléen optionnel) : Indique si l'opération de chargement doit être en mode lecture seule, par défaut le même indicateur que cette instance. 
      // Valeur de retour : booléen : Vrai si le chargement des utilisateurs est réussi, Faux sinon.
      // Exemple :
      //
      PROCEDURE UsersCharge(xNomObjetListe = null,xNomObjetFiche = null,sFiltres = csdLDAPUser._ADUserFiltreStatutActifsSeulement,nLimiteMax est un entier = 0,sAttributsALire est une chaine = "",bLectureSeule est un booleen = p_bLectureSeule) : booleen
      VariableRAZ(m_pclUsers)
      SELON cBaseDeDonnéesLDAP.mg_taServeurVersion[cBaseDeDonnées.mg_tabConnexion[p_nIndiceDeConnexion].sNomUnique]
      	CAS cBaseDeDonnées.EVersionServeur.WindowsServer2000..Valeur 	
      		SI MesParamètres[1]..Défaut ALORS xNomObjetListe=csdLDAP2000User
      		SI MesParamètres[2]..Défaut ALORS xNomObjetFiche=ceLDAP2000User
      	CAS cBaseDeDonnées.EVersionServeur.WindowsServer2003..Valeur 	
      		SI MesParamètres[1]..Défaut ALORS xNomObjetListe=csdLDAP2003User
      		SI MesParamètres[2]..Défaut ALORS xNomObjetFiche=ceLDAP2003User
      	CAS cBaseDeDonnées.EVersionServeur.WindowsServer2003R2..Valeur 	
      		SI MesParamètres[1]..Défaut ALORS xNomObjetListe=csdLDAP2003R2User
      		SI MesParamètres[2]..Défaut ALORS xNomObjetFiche=ceLDAP2003R2User
      	CAS cBaseDeDonnées.EVersionServeur.WindowsServer2008..Valeur 	
      		SI MesParamètres[1]..Défaut ALORS xNomObjetListe=csdLDAP2008User
      		SI MesParamètres[2]..Défaut ALORS xNomObjetFiche=ceLDAP2008User
      	CAS cBaseDeDonnées.EVersionServeur.WindowsServer2008R2..Valeur 	
      		SI MesParamètres[1]..Défaut ALORS xNomObjetListe=csdLDAP2008R2User
      		SI MesParamètres[2]..Défaut ALORS xNomObjetFiche=ceLDAP2008R2User
      	CAS cBaseDeDonnées.EVersionServeur.WindowsServer2012..Valeur
      		SI MesParamètres[1]..Défaut ALORS xNomObjetListe=csdLDAP2012User
      		SI MesParamètres[2]..Défaut ALORS xNomObjetFiche=ceLDAP2012User
      	AUTRES CAS
      		m_pclErreur.AjouteErreur(<§$0003§>+cBaseDeDonnéesLDAP.mg_taServeurVersion[cBaseDeDonnées.mg_tabConnexion[p_nIndiceDeConnexion].sNomUnique])
      		RENVOYER Faux
      FIN
      SI xNomObjetListe<>Null _ET_ xNomObjetFiche<>Null ALORS
      	m_pclUsers = allouer un xNomObjetListe (p_nIndiceDeConnexion,xNomObjetFiche,"",bLectureSeule,sAttributsALire)
      	RENVOYER m_pclUsers.Liste(objet,sFiltres,nLimiteMax,bLectureSeule)
      FIN
      RENVOYER Faux
     type : 458752
   -
     name : ContactsCharge
     procedure_id : 1293087697951651341
     type_code : 12
     code : |1-
      // Résumé : Charge les contacts d'un groupe LDAP. 
      // Syntaxe : [ <Résultat> = ] ContactsCharge ( [<xNomObjetListe> [, <xNomObjetFiche> [, <sFiltres> [, <nLimiteMax> est entier [, <sAttributsALire> est chaîne [, <bLectureSeule> est booléen]]]]]])
      // Paramètres :
      // 	xNomObjetListe (valeur optionnelle) : L'objet représentant la liste des contacts. Si la valeur est Null, la méthode sélectionne automatiquement la classe appropriée en fonction de la version du serveur LDAP.
      // 	xNomObjetFiche (valeur optionnelle) : L'objet représentant la fiche d'un contact. Si la valeur est Null, la méthode sélectionne automatiquement la classe appropriée en fonction de la version du serveur LDAP.
      // 	sFiltres (optionnel) : Les filtres à appliquer lors de la récupération des contacts. Par défaut, tous.
      // 	nLimiteMax (entier optionnel) : Le nombre maximum de contacts à charger. Par défaut, la valeur est 0 pour charger tous les contacts.
      //	sAttributsALire (chaîne UNICODE optionnelle) : Les attributs à lire pour chaque contact séparés par des virgules, par défaut Tous.
      //	bLectureSeule (booléen optionnel) : Indique si l'opération de chargement doit être en mode lecture seule, par défaut le même indicateur que cette instance. 
      // Valeur de retour : booléen : Vrai si le chargement des contacts est réussi, Faux sinon.
      // Exemple :
      //
      PROCEDURE ContactsCharge(xNomObjetListe = null,xNomObjetFiche = null,sFiltres = "",nLimiteMax est un entier = 0,sAttributsALire est une chaine = "",bLectureSeule est un booleen = p_bLectureSeule) : booleen
      VariableRAZ(m_pclContacts)
      SELON cBaseDeDonnéesLDAP.mg_taServeurVersion[cBaseDeDonnées.mg_tabConnexion[p_nIndiceDeConnexion].sNomUnique]
      	CAS cBaseDeDonnées.EVersionServeur.WindowsServer2000..Valeur 	
      		SI MesParamètres[1]..Défaut ALORS xNomObjetListe=csdLDAP2000Contact
      		SI MesParamètres[2]..Défaut ALORS xNomObjetFiche=ceLDAP2000Contact
      	CAS cBaseDeDonnées.EVersionServeur.WindowsServer2003..Valeur 	
      		SI MesParamètres[1]..Défaut ALORS xNomObjetListe=csdLDAP2003Contact
      		SI MesParamètres[2]..Défaut ALORS xNomObjetFiche=ceLDAP2003Contact
      	CAS cBaseDeDonnées.EVersionServeur.WindowsServer2003R2..Valeur 	
      		SI MesParamètres[1]..Défaut ALORS xNomObjetListe=csdLDAP2003R2Contact
      		SI MesParamètres[2]..Défaut ALORS xNomObjetFiche=ceLDAP2003R2Contact
      	CAS cBaseDeDonnées.EVersionServeur.WindowsServer2008..Valeur 	
      		SI MesParamètres[1]..Défaut ALORS xNomObjetListe=csdLDAP2008Contact
      		SI MesParamètres[2]..Défaut ALORS xNomObjetFiche=ceLDAP2008Contact
      	CAS cBaseDeDonnées.EVersionServeur.WindowsServer2008R2..Valeur 	
      		SI MesParamètres[1]..Défaut ALORS xNomObjetListe=csdLDAP2008R2Contact
      		SI MesParamètres[2]..Défaut ALORS xNomObjetFiche=ceLDAP2008R2Contact
      	CAS cBaseDeDonnées.EVersionServeur.WindowsServer2012..Valeur
      		SI MesParamètres[1]..Défaut ALORS xNomObjetListe=csdLDAP2012Contact
      		SI MesParamètres[2]..Défaut ALORS xNomObjetFiche=ceLDAP2012Contact
      	AUTRES CAS
      		m_pclErreur.AjouteErreur(<§$0003§>+cBaseDeDonnéesLDAP.mg_taServeurVersion[cBaseDeDonnées.mg_tabConnexion[p_nIndiceDeConnexion].sNomUnique])
      		RENVOYER Faux
      FIN
      SI xNomObjetListe<>Null _ET_ xNomObjetFiche<>Null ALORS
      	m_pclContacts = allouer un xNomObjetListe (p_nIndiceDeConnexion,xNomObjetFiche,"",bLectureSeule,sAttributsALire)
      	RENVOYER m_pclContacts.Liste(objet,sFiltres,nLimiteMax,bLectureSeule)
      FIN
      RENVOYER Faux
     type : 458752
   -
     name : EcritMembres
     procedure_id : 1294234007797397843
     type_code : 12
     code : |1-
      // Résumé : Écrit les membres (utilisateurs, contacts, sous-groupes) dans le groupe LDAP actuel. Elle supprime d'abord tous les membres existants du groupe, puis ajoute les membres actuels du groupe.
      // Syntaxe : [ <Résultat> = ] EcritMembres ( [<bContinueQuandErreur> est booléen])
      // Paramètres :
      // 	bContinueQuandErreur (booléen optionnel) : Indique si le processus doit continuer même en cas d'erreur. Par défaut, ne continue pas.
      // Valeur de retour : booléen : Vrai si l'écriture des membres est réussie, Faux sinon.
      // Exemple :
      //
      PROCEDURE EcritMembres(bContinueQuandErreur est un booléen = Faux) : booléen
      SI cApplication._Application<>Null _ET_ cApplication._Application.m_pclTrace<>Null ALORS cApplication._Application.m_pclTrace.AjouteMéthode(bContinueQuandErreur)
      m_pclErreur.Raz()
      
      
      <si CibleExécution=ApplicationWindows ou CibleExécution=SiteWindows ou CibleExécution=WebserviceWindows ou CibleExécution=AssemblageDotNet ou CibleExécution=ServiceWindows>
      	
      	//ref : https://forum.pcsoft.fr/fr-FR/pcsoft.fr.windev/57200-ldap-ajouter-membre-groupe/read.awp
      	LDAPDébutModification(m_sSessionAD)
      	sMembres 	est une chaine ansi = LDAPListeFils(m_sSessionAD,DN)
      	sMembre		est une chaine ansi
      	pour toute chaine sMembre de sMembres separee par RC
      		LDAPSupprimeValeurAttribut(m_sSessionAD,"member",sMembre)
      	FIN
      	POUR TOUT pclUser de m_pclUsers.m_tabUser
      		//on ne supprime pas ici l'élément du LDAP mais uniquement son lien avec le groupe père
      		SI PAS LDAPAjouteAttribut(m_sSessionAD, "member", pclUser.cn) ALORS
      			m_pclErreur.AjouteErreurWx()
      			SI PAS bContinueQuandErreur ALORS RENVOYER Faux
      		FIN
      	FIN
      	
      	POUR TOUT pclContact DE m_pclContacts.m_tabContact
      		SI PAS LDAPAjouteAttribut(m_sSessionAD,"member",pclContact.cn) ALORS
      			m_pclErreur.AjouteErreurWx()
      			SI PAS bContinueQuandErreur ALORS RENVOYER Faux
      		FIN
      	FIN
      	
      	POUR TOUT pclGroupe DE m_pclSubGroups.m_tabGroupe
      		SI PAS LDAPAjouteAttribut(m_sSessionAD,"member",pclGroupe.cn) ALORS
      			m_pclErreur.AjouteErreurWx()
      			SI PAS bContinueQuandErreur ALORS RENVOYER Faux
      		FIN
      	FIN
      	
      	SI LDAPValideModification(m_sSessionAD, dn) ALORS RENVOYER Vrai SINON m_pclErreur.AjouteErreurWx()
      	
      <fin>
      
      
      RENVOYER Faux
     type : 458752
  properties :
   -
     name : p_pclUsers
     identifier : 0x11f1f6df03cdf3ac
     type_code : 103
     p_codes :
      -
        code : |1-
         // Résumé : Renvoie la liste des utilisateurs si UsersCharge() a bien été appelé avant.
         PROCEDURE PUBLIQUE p_pclUsers()
         SI m_pclUsers=Null ALORS m_pclErreur.AjouteAvertissement(<§$0000§>)
         RENVOYER m_pclUsers
        type : 1966080
      -
        code : |1-
         // Résumé : Modifie la liste des utilisateurs
         PROCEDURE PUBLIQUE p_pclUsers(Valeur)
         m_pclUsers = Valeur
        type : 2031616
     template_refs : []
   -
     name : p_pclContacts
     identifier : 0x11f1f70403ce84e4
     type_code : 103
     p_codes :
      -
        code : |1-
         // Résumé : Renvoie la liste des contacts si ContactsCharge a bien été appelé avant.
         PROCEDURE PUBLIQUE p_pclContacts()
         SI m_pclContacts=Null ALORS m_pclErreur.AjouteAvertissement(<§$0001§>)
         RENVOYER m_pclContacts
        type : 1966080
      -
        code : |1-
         // Résumé : Modifie la liste des contacts
         PROCEDURE PUBLIQUE p_pclContacts(Valeur)
         m_pclContacts = Valeur
        type : 2031616
     template_refs : []
   -
     name : p_pclSubGroups
     identifier : 0x11f1f72403cf0069
     type_code : 103
     p_codes :
      -
        code : |1-
         // Résumé : Renvoie la liste des sous-groupes si SubGroupsCharge a bien été appelé avant.
         PROCEDURE PUBLIQUE p_pclSubGroups()
         SI m_pclSubGroups=Null ALORS m_pclErreur.AjouteAvertissement(<§$0002§>)
         RENVOYER m_pclSubGroups
        type : 1966080
      -
        code : |1-
         // Résumé : Modifie la liste des sous-groupes
         PROCEDURE PUBLIQUE p_pclSubGroups(Valeur)
         m_pclSubGroups = Valeur
        type : 2031616
     template_refs : []
  procedure_templates : []
  property_templates : []
 code_parameters :
  internal_properties : CQAAAAkAAACVGQgYbalU7DKC3oH4ItDrjtcTHXXV/EuH8q0IbhyQlw==
  original_name : Classe1
resources :
 string_res :
  identifier : 0x11f1f62003770864
  internal_properties : CQAAAAkAAACm76HWfKGWp33VjXInA4cRlqArlgTTA862QGt72W2ld5Y=
  strings :
   -
     text :
      fr-FR : Utilisez d'abord UsersCharge()
      en-GB : First use UsersCharge()
      fr-CA : Utilisez d'abord UsersCharge()
      en-US : First use UsersCharge()
     index : 0
   -
     text :
      fr-FR : Utilisez d'abord ContactsCharge()
      en-GB : First use ContactsCharge()
      fr-CA : Utilisez d'abord ContactsCharge()
      en-US : First use ContactsCharge()
     index : 1
   -
     text :
      fr-FR : Utilisez d'abord SubGroupsCharge()
      en-GB : First use SubGroupsCharge()
      fr-CA : Utilisez d'abord SubGroupsCharge()
      en-US : First use SubGroupsCharge()
     index : 2
   -
     text :
      fr-FR : "La version du serveur n'est pas gérée : "
      en-GB : "The server version is not supported : "
      fr-CA : "La version du serveur n'est pas gérée : "
      en-US : "The server version is not supported : "
     index : 3
   -
     text :
      fr-FR : Pas de session LDAP ouverte
      en-GB : No open LDAP session
      fr-CA : Pas de session LDAP ouverte
      en-US : No open LDAP session
     index : 4
   -
     text :
      fr-FR : Le nom du groupe est obligatoire
      en-GB : The group name is mandatory
      fr-CA : Le nom du groupe est obligatoire
      en-US : The group name is mandatory
     index : 5
custom_note :
 internal_properties : CQAAAAkAAABtB9HWVzrXO2+4NDRVK0vmzaNKrCKqH1DBX30lMmGZ
