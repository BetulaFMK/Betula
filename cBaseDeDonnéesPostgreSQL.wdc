#To edit and compare internal_properties, use WINDEV integrated tools.
#Internal properties refer to the properties of controls in windows, reports, etc.
info :
 name : cBaseDeDonnéesPostgreSQL
 major_version : 29
 minor_version : 0
 type : 4
 description : ""
 subtype : 0
class :
 identifier : 0x1c7e749e08b15600
 internal_properties : CQAAAAkAAAB2/vstTMCJbS/hlxjFxirSqKvCUuv8YxgpWyl7S3iA
 code_elements :
  internal_properties : CQAAAAkAAADvJt7cUwXHZ32pbis/jy4kYAKNFGzDBTqTUA2UrL9GISN+kXBY70/wjh30kddEdEWQ5U+1Xu99roFymLBHx+lCta/jdSht8Gv9mpa3XwmwUw==
  type_code : 10
  p_codes :
   -
     code : |1+
      //*************************************************************************************************************************************************************************
      //Ce fichier fait partie de Betula.
      //Betula est un logiciel libre ; vous pouvez le redistribuer ou le modifier suivant les termes de la GNU Lesser General Public License telle que publiée par la Free Software Foundation ; soit la version 3 de la licence, soit (à votre gré) toute version ultérieure.
      //Betula est distribué dans l'espoir qu'il sera utile, mais SANS AUCUNE GARANTIE ; sans même la garantie tacite de QUALITÉ MARCHANDE ou d'ADÉQUATION à UN BUT PARTICULIER. Consultez la GNU Lesser General Public License pour plus de détails.
      //Vous devez avoir reçu une copie de la GNU Lesser General Public License en même temps que Betula ; si ce n'est pas le cas, consultez <http://www.gnu.org/licenses>.
      //
      //This file is part of Betula.
      //Betula is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
      //Betula is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
      //You should have received a copy of the GNU Lesser General Public License along with Betula. If not, see <https://www.gnu.org/licenses/>
      //*************************************************************************************************************************************************************************
      
      //Cette classe permet d'accéder aux données PostgreSQL.
      
      EConstraintType est une Enumération
      	PrimaryKey				= "p"
      	UniqueKey				= "u"
      	ForeignKey				= "f"
      FIN
      cBaseDeDonnéesPostgreSQL est une Classe
      	hérite de cGénérique
      	constante
      		_Port					= 5432														//Port de communication par défaut
      		hAccèsNatifPostGreSQL	= "WinDevPostgreSQL"										//Valeur du type de base de données pour PostgreSQL. N'est pas reconnu par toutes les plateformes, la répéter évite des erreurs dans Betula.
      		hFichierPostgreSQL		= 88														//Valeur du type de base de données pour PostgreSQL dans l'analyse. N'est pas reconnu par toutes les plateformes, la répéter évite des erreurs dans Betula.
      	fin
      	m_bTraceColonnesModifiées	est un booleen				<sérialise = faux>				//Renvoi ou permet de modifier le statut permettant la trace des colonnes modifiés lors de l'utilisation de la fonction cEnregistrement.Écrit() 
      public constant local
      	m_nIndiceDeConnexion		est un entier 				<serialise = faux>				//Indice de la connexion en cours
      PRIVÉ GLOBAL
      	mg_taServeurVersion			est un tableau associatif 	<sérialise = faux> de chaines	//Tableau contenant la version de chaque serveur auquel l'application aura accès
      FIN
     type : 131072
  procedures :
   -
     name : Constructeur
     procedure_id : 2053206702227150336
     type_code : 27
     code : |1-
      // Résumé : Permet d'initialiser la classe. Si un indice de connexion est passé en paramètre, récupère toutes les informations d'une précédente connexion qui avait renvoyé ledit indice.
      // Syntaxe : Constructeur ( [<nIndiceDeConnexionExistant> est entier])
      // Paramètres :
      // 	nIndiceDeConnexionExistant (entier optionnel): L'indice de connexion existant à associer à l'instance de la classe. Par défaut, il est initialisé à zéro.
      // Valeur de retour : Aucune
      // Exemple :
      //
      PROCEDURE Constructeur(nIndiceDeConnexionExistant est un entier = 0)
      SI cApplication._Application<>Null _ET_ cApplication._Application.m_pclTrace<>Null ALORS cApplication._Application.m_pclTrace.AjouteMéthode(nIndiceDeConnexionExistant)
      m_pclErreur.Raz()
      
      m_nIndiceDeConnexion=nIndiceDeConnexionExistant
      SI m_nIndiceDeConnexion>0 ALORS Connecte(cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].eAccès,cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].cnxDonnées..Serveur,cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].cnxDonnées..Utilisateur,cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].sMotDePasse,cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].cnxDonnées..BaseDeDonnées,"public",cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].sEmplacementDesMémos)
     type : 589824
   -
     name : Destructeur
     procedure_id : 2053206702227215872
     type_code : 28
     code : |1-
      // Résumé : La méthode effectue les opérations de nettoyage nécessaires lors de la destruction de l'instance de la classe. Déconnecte la connexion à la BD le cas échéant.
      // Syntaxe : Destructeur()
      // Paramètres : Aucun
      // Valeur de retour : Aucune
      // Exemple :
      PROCEDURE Destructeur()
      SI p_bEstConnecté ALORS Déconnecte()
     type : 655360
   -
     name : Déconnecte
     internal_properties : CQAAAAkAAADOHQnw/DDAwA2Sgstp0iHSSBV/Y0v9kC8OE8I6vhlqV+I4sjPf5ROobTvWBZvyPjvs1ze4RSeiCjX3eWHFbMbJbWKSueDL/7/Rt/ulD6FEW2dTWCwlpbgr6dR0FrS0NEw1OS5fHCqXWT7naioXT1ABvCbnfdYcDJRoA+CUWtTiBI4wz6g=
     procedure_id : 2053206702227281408
     type_code : 12
     code : |1-
      // Résumé : Déconnecte la base de données.
      // Syntaxe : [ <Résultat> = ] Déconnecte ()
      // Paramètres : Aucun
      // Valeur de retour : booléen : Renvoie vrai si la déconnexion s'est correctement déroulée, faux sinon
      // Exemple :
      //
      PROCEDURE Déconnecte(bForce est un booleen = faux) : booléen
      m_pclErreur.Raz()
      
      SI m_nIndiceDeConnexion>0 ALORS
      	sClé 			est une chaine = cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].sClé
      	nUtilisation 	est un entier = cBaseDeDonnées.mg_taUtilisationServeur[sClé]
      	SI ((PAS cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].bResterConnecté _ET_ nUtilisation=1) OU bForce) ALORS	//nUtilisation=1 ALORS c'est la dernière connexion active sur ce serveur
      		SI cApplication._Application<>Null _ET_ cApplication._Application.m_pclTrace<>Null ALORS cApplication._Application.m_pclTrace.AjouteMéthode(bForce)
      		SI HFermeConnexion(cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].cnxDonnées) ALORS 
      			cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].bConnecté=Faux
      			cBaseDeDonnées.ConnexionSupprimeTout(cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].sClé)
      			m_nIndiceDeConnexion=0;nUtilisation=0
      		SINON
      			m_pclErreur.AjouteErreurHF(ChaîneConstruit(<§$0001§>,cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].cnxDonnées..Provider,cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].cnxDonnées..BaseDeDonnées))
      			RENVOYER Faux
      		FIN
      	FIN
      	SI nUtilisation>1 ALORS cBaseDeDonnées.ConnexionSupprime(cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].sClé)
      SINON
      	m_pclErreur.AjouteAvertissement(<§$0002§>)
      FIN
      RENVOYER Vrai
      
      CAS ERREUR:
      m_pclErreur.AjouteErreurWx();RENVOYER Faux
      CAS EXCEPTION:
      m_pclErreur.AjouteException();RENVOYER Faux
     type : 458752
   -
     name : Connecte
     internal_properties : CQAAAAkAAADOHQnw/DDAwA2Sgstp0iHSSBV/Y0v9kC8OE8I6vhlqV+I4sjPf5ROobTvWBZvyPjvs1ze4RSeiCjX3eWHFbMbJbWKSueDL/7/Rt/ulD6FEW2dTWCwlpbgr6dR0FrS0NEw1OS5fHCqXWT7naioXT1ABvCbnfdYcDJRoA+CUWtTiBI4wz6g=
     procedure_id : 2295170604125144915
     type_code : 12
     code : |1-
      // Résumé : Utilisée pour établir une connexion à des données sur PostgreSQL en utilisant les paramètres fournis. Tous les paramètres de la méthode peuvent être récupérés des paramètres de l'application avec le nom de section "Postgres".
      // Syntaxe : [ <Résultat> = ] Connecte ( [<eAccès> est cBaseDeDonnées.ETypeAccès [, <sServeurPort> est chaîne [, <sUtilisateur> est chaîne [, <sMotDePasse> est chaîne [, <sBaseDeDonnées> est chaîne [, <sSchema> est chaîne [, <sGroupeOuTypeOuNomDeFichiers> est chaîne [, <sEmplacementDesMémos> est chaîne [, <sRépertoireCache> est chaîne [, <bResterConnecté> est booléen]]]]]]]]]])
      // Paramètres :
      //	eAccès (cBaseDeDonnées.ETypeAccès) : Type d'accès à la base de données (par défaut à partir des paramètres). Paramètre "Access", par défaut "RequêteSQL".
      //	sServeurPort (chaîne UNICODE) : Nom du serveur et port de communication du serveur (format : Serveur:Port). Paramètre "Address" et "Port".
      //	sUtilisateur (chaîne UNICODE) : Nom d'utilisateur pour la connexion. Paramètre "User".
      //	sMotDePasse (chaîne UNICODE) : Mot de passe pour la connexion. Paramètre "Password".
      //	sBaseDeDonnées (chaîne UNICODE) : Nom de la base de données. Paramètre "DB".
      //	sSchema (chaîne UNICODE) : Nom du schéma avec lequel on va accéder au serveur Oracle. Paramètre "Schema".
      //	sGroupeOuTypeOuNomDeFichiers (chaîne UNICODE) : Paramètre pour spécifier le groupe, type ou nom de fichiers. Paramètre "Group", par défaut "*".
      //	sEmplacementDesMémos (chaîne UNICODE) : Emplacement des mémos. Paramètre "PathMemos".
      //	sRépertoireCache (chaîne UNICODE) : Répertoire du cache des mémos. Paramètre "CacheMemos", par défaut cApplication._Application.p_sRépertoireCacheMémo.
      //	sInfosÉtendues (chaîne UNICODE) : Informations étendues pour la connexion. Paramètre "ExtInfos".
      //	bResterConnecté (booléen) : Indique si la connexion doit être maintenue ou non. Paramètre "StayConnected", par défaut Vrai.
      // Valeur de retour : entier : Indice de la connexion établie. En cas d'échec, renvoie 0.
      // Exemple :
      //
      PROCEDURE Connecte(LOCAL eAccès est un cBaseDeDonnées.ETypeAccès = EnumérationDepuisNom(cBaseDeDonnées.ETypeAccès,cApplication._Application.m_pclParamètres.Lit("Postgres","Access",faux,"RequêteSQL")),	//ETypeAccès.RequêteSQL..Nom affiche une erreur en Android et Java
      		LOCAL sServeurPort est une chaine = cApplication._Application.m_pclParamètres.Lit("Postgres","Address"),
      		sUtilisateur est une chaine = cApplication._Application.m_pclParamètres.Lit("Postgres","User"),
      		sMotDePasse = cApplication._Application.m_pclParamètres.Lit("Postgres","Password"),
      		sBaseDeDonnées est une chaine = cApplication._Application.m_pclParamètres.Lit("Postgres","DB"),
      		sSchema est une chaine = cApplication._Application.m_pclParamètres.Lit("Postgres","schema",faux,"public"),
      		LOCAL sGroupeOuTypeOuNomDeFichiers est une chaine = cApplication._Application.m_pclParamètres.Lit("Postgres","Group",Faux,"*"),
      		sEmplacementDesMémos est une chaine = cApplication._Application.m_pclParamètres.Lit("Postgres","PathMemos"),
      		sRépertoireCache est une chaîne = cApplication._Application.m_pclParamètres.Lit("Postgres","CacheMemos",Faux,cApplication._Application.p_sRépertoireCacheMémo),
      		bResterConnecté est un booleen = cApplication._Application.m_pclParamètres.Lit("Postgres","StayConnected",faux,vrai)) : entier
      			
      SI cApplication._Application<>Null _ET_ cApplication._Application.m_pclTrace<>Null ALORS cApplication._Application.m_pclTrace.AjouteMéthode(eAccès,sServeurPort,sUtilisateur,(EnModeTest() ? sMotDePasse SINON Répète(_Sep,Taille(sMotDePasse))),sBaseDeDonnées,sGroupeOuTypeOuNomDeFichiers,sEmplacementDesMémos,bResterConnecté)
      m_pclErreur.Raz()
      
      SI sServeurPort~="" 			ALORS m_pclErreur.AjouteErreur(<§$0005§>)
      SI sUtilisateur~="" 			ALORS m_pclErreur.AjouteErreur(<§$0006§>)
      SI sBaseDeDonnées~="" 			ALORS m_pclErreur.AjouteErreur(<§$0003§>)
      SI eAccès=cBaseDeDonnées.ODBC 	ALORS m_pclErreur.AjouteErreur(<§$000e§>)
      SI m_pclErreur.p_sErreur>"" 	ALORS RENVOYER 0
      
      //SI ExtraitChaîne(sServeurPort,2,":") DANS ("",EOT) ALORS sServeurPort+=":"+_PortSQLServer
      
      SI eAccès=cBaseDeDonnées.ODBC _ET_ ODBCChemin()="" 	ALORS m_pclErreur.AjouteErreur(<§$000f§>)
      stUneConnexion 	est un cBaseDeDonnées.STConnexion
      cnxDonnées 		est une connexion
      sClé			est une chaine = Minuscule(sServeurPort+TAB+sUtilisateur+TAB+sBaseDeDonnées+tab+sSchema+tab+(eAccès=cBaseDeDonnées.ODBC))
      sTables 		est une chaine
      
      
      m_nIndiceDeConnexion = TableauCherche(cBaseDeDonnées.mg_tabConnexion,tcLinéaire,"sCLé",sClé)
      SI m_nIndiceDeConnexion>0 _ET_ cBaseDeDonnées.mg_taUtilisationServeur[sClé]>0 ALORS cBaseDeDonnées.Connexionajoute(sClé);RENVOYER m_nIndiceDeConnexion	//la connexion existe déjà, renvoyer l'indice pour minimiser le nombre de connexions faites par l'appli
      
      SI cApplication.mg_bSécurité ALORS 
      	procConnecte est une Procédure = ChercheProcédure("COL_Betula_Secu.BDConnecteSecurisé")
      	SI procConnecte<>Null ALORS
      		cnxDonnées			= ExécuteTraitement("COL_Betula_Secu.BDConnecteSecurisé",trtProcédure,sServeurPort,sSchema,sUtilisateur,sMotDePasse)
      		SI ErreurDétectée() ALORS m_pclErreur.AjouteErreur(ErreurInfo());RENVOYER 0
      	fin
      sinon
      	cnxDonnées..Provider												= hAccèsNatifPostGreSQL
      	cnxDonnées..Serveur													= sServeurPort
      	cnxDonnées..Utilisateur												= sUtilisateur
      	cnxDonnées..MotDePasse	    										= sMotDePasse
      	cnxDonnées..BaseDeDonnées											= sBaseDeDonnées
      	cnxDonnées..Accès													= hOLectureEcriture
      	cnxDonnées..Cryptage												= hCryptageNon
      fin
      
      SI HOuvreConnexion(cnxDonnées) _ET_ ChangeConnexion() ALORS
      	cBaseDeDonnées.ConnexionAjoute(sClé)
      	SI m_nIndiceDeConnexion<1 ALORS
      		stUneConnexion.sNomUnique										= Minuscule(cnxDonnées..Serveur+cGénérique._Sep+sBaseDeDonnées)
      		stUneConnexion.cnxDonnées										= cnxDonnées
      		stUneConnexion.sMotDePasse										= sMotDePasse
      		stUneConnexion.bConnecté										= Vrai
      		stUneConnexion.sClé												= sClé
      		stUneConnexion.eAccès											= eAccès
      		stUneConnexion.sRépertoireCache									= completerep(sRépertoireCache)
      		stUneConnexion.sEmplacementDesMémos								= ComplèteRep(sEmplacementDesMémos)
      		stUneConnexion.sGroupeOuTypeOuNomDeFichiers						= sGroupeOuTypeOuNomDeFichiers
      		stUneConnexion.bResterConnecté									= bResterConnecté
      		stUneConnexion.sSchémaOuDC										= sSchema
      		m_nIndiceDeConnexion											= TableauAjoute(cBaseDeDonnées.mg_tabConnexion,stUneConnexion)	//ne pas faire TableauAjouteTrié car il peut prendre un indice déjà utilisé par une autre connexion
      		ServeurVersion()
      		SI sTables>"" ALORS TableColonnes(sTables);TableIndexes(sTables)
      	SINON
      		cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].bConnecté	= Vrai
      	FIN
      	RENVOYER m_nIndiceDeConnexion
      SINON 
      	m_pclErreur.AjouteErreurHF(ChaîneConstruit(<§$0004§>,"Postgres",sServeurPort)) 
      FIN
      RENVOYER 0
      
      	PROCÉDURE INTERNE ServeurVersion()
      	//récupérer la version du serveur
      	SI mg_taServeurVersion[Minuscule(sServeurPort)]="" ALORS
      		sdVersion est une source de données
      		SI HExécuteRequêteSQL(sdVersion,cnxDonnées,hRequêteSansCorrection,"SELECT VERSION() AS server_version;") _ET_ HLitPremier(sdVersion) ALORS	//mettre les 2 requêtes dans une fait planter Windev 23 (problème avec l'accès natif, cas envoyé chez PCSOFT le 22 janv.2019)
      			mg_taServeurVersion[Minuscule(sServeurPort)] = Remplace(ExtraitChaîne(sdVersion.server_version,1,","),"PostgreSQL ","")
      		FIN
      	FIN
      	FIN
      
      	PROCÉDURE INTERNE ChangeConnexion()
      	SI sGroupeOuTypeOuNomDeFichiers="*" ALORS
      		RENVOYER HChangeConnexion("*",cnxDonnées)
      	SINON SI sGroupeOuTypeOuNomDeFichiers=hFichierPostgreSQL ALORS
      		POUR TOUTE CHAÎNE sTable de capplication.mg_sTablesAnalyse separee par rc
      			SI {sTable,indFichier}..Type=hFichierPostgreSQL _ET_ PAS HChangeConnexion(sTable,cnxDonnées) ALORS RENVOYER Faux sinon sTables+=[tab]+sTable
      		FIN
      	SINON SI sGroupeOuTypeOuNomDeFichiers>"" ALORS
      		POUR TOUTE CHAÎNE sTable de sGroupeOuTypeOuNomDeFichiers separee par [rc," ",",",";",tab]
      			SI PAS HChangeConnexion(sTable,cnxDonnées) ALORS RENVOYER Faux SINON sTables+=[TAB]+sTable
      		FIN
      	FIN	
      	RENVOYER Vrai
      	FIN
      
      CAS ERREUR:
      m_pclErreur.AjouteErreurWx();RENVOYER 0
      CAS EXCEPTION:
      m_pclErreur.AjouteException();RENVOYER 0
     type : 458752
   -
     name : Tables
     procedure_id : 2295171523248228503
     type_code : 12
     code : |1-
      // Résumé : Renvoie l'ensemble des noms de table.
      // Syntaxe : [ <Résultat> = ] Tables ()
      // Paramètres : Aucun
      // Valeur de retour : chaîne UNICODE : Retourne la liste des tables sous forme de chaine séparée par des RC.
      // Exemple :
      //
      PROCEDURE Tables(sCondition est une chaine = "") : chaîne
      SI cApplication._Application<>Null _ET_ cApplication._Application.m_pclTrace<>Null ALORS cApplication._Application.m_pclTrace.AjouteMéthode()
      m_pclErreur.Raz()
      
      SI PAS cBaseDeDonnées.ConnexionActive(m_nIndiceDeConnexion) ALORS m_pclErreur.AjouteErreur(<§$0007§>);renvoyer ""
      SI sCondition="" _Et_ cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].sToutesLesTables>"" ALORS RENVOYER cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].sToutesLesTables
      
      sRes 	est une chaine
      clSQL 	est un csql(m_nIndiceDeConnexion)
      sReq 	est une chaine = [
      SELECT * from information_schema.tables where table_schema = '%1'
      ]
      SI clSQL.Requête(chaineconstruit(sReq,cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].sSchémaOuDC)+" ORDER BY TABLE_NAME") ALORS
      	POUR TOUT clSQL.m_sd
      		sRes+=[RC]+clSQL.m_sd.table_name
      	FIN
      	SI sCondition="" ALORS cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].sToutesLesTables=sRes
      	RENVOYER sRes
      SINON
      	m_pclErreur.AjouteErreur(clSQL.p_sErreur)
      FIN		
      RENVOYER ""
     type : 458752
   -
     name : TableColonneExiste
     procedure_id : 2295171664982183201
     type_code : 12
     code : |1-
      // Résumé : Vérifie l'existence d'une colonne de table dont le nom est passé en paramètre.
      // Syntaxe : [ <Résultat> = ] TableColonneExiste (<sNomTable> est chaîne)                              
      // Paramètres :
      //	sNomTable (chaîne UNICODE) : Nom de la colonne (table+"."+colonne) dont on souhaite vérifier l'existence.
      // Valeur de retour : booléen : Retourne Vrai si la colonne de table existe dans la base de données, sinon elle renvoie Faux.
      // Exemple :
      //
      PROCEDURE TableColonneExiste(sNomTableEtColonne est une chaîne) : booléen
      SI cApplication._Application<>Null _ET_ cApplication._Application.m_pclTrace<>Null ALORS cApplication._Application.m_pclTrace.AjouteMéthode(sNomTableEtColonne)
      m_pclErreur.Raz()
      
      SI PAS cBaseDeDonnées.ConnexionActive(m_nIndiceDeConnexion) ALORS m_pclErreur.AjouteErreur(<§$0007§>);renvoyer ""
      
      sTable,sColonne sont des chaines
      sColonne= ExtraitChaîne(sNomTableEtColonne,1,".",DepuisFin)
      sTable	= Gauche(sNomTableEtColonne,Taille(sNomTableEtColonne)-Taille(sColonne)-1)
      clSQL	est un csql(m_nIndiceDeConnexion)
      sReq	est une chaine = [
      SELECT * FROM information_schema.columns WHERE table_schema = '%1' AND table_name  = '%2' and column_name = '%3'
      ]
      SI clSQL.Requête(chaineconstruit(sReq,cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].sSchémaOuDC,sTable,sColonne)) ALORS
      	RENVOYER HLitPremier(clSQL.m_sd)
      SINON
      	m_pclErreur.AjouteErreur(clSQL.p_sErreur)
      FIN
      RENVOYER Faux
     type : 458752
   -
     name : TableExiste
     procedure_id : 2295171768061487460
     type_code : 12
     code : |1-
      // Résumé : Vérifie l'existence d'une colonne dont le nom est passé en paramètre.
      // Syntaxe : [ <Résultat> = ] ColonneExiste (<sNomTableEtColonne> est chaîne)
      // Paramètres :
      //	sNomTableEtColonne (chaîne UNICODE) : Nom de la table dont on souhaite vérifier l'existence.
      // Valeur de retour : booléen : Retourne Vrai si la table existe dans la base de données, sinon elle renvoie Faux.
      // Exemple :
      //
      PROCEDURE TableExiste(sNomTable est une chaîne) : booléen
      SI cApplication._Application<>Null _ET_ cApplication._Application.m_pclTrace<>Null ALORS cApplication._Application.m_pclTrace.AjouteMéthode(sNomTable)
      m_pclErreur.Raz()
      
      SI PAS cBaseDeDonnées.ConnexionActive(m_nIndiceDeConnexion) ALORS m_pclErreur.AjouteErreur(<§$0007§>);renvoyer Faux
      SI cApplication.mg_taInfo[cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].sNomUnique+cGénérique._Sep+Minuscule(sNomTable)]<>null alors renvoyer vrai
      
      si cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].sToutesLesTables>"" alors
      	renvoyer (position(cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].sToutesLesTables,sNomTable,0,MotComplet+SansCasse+DepuisDébut)>0)
      sinon
      	sReq est une chaine = [
      	SELECT 
      		* 
      	FROM 
      		information_schema.tables 
      	WHERE 
      		table_schema = '%1' AND table_name='%2'
      	]
      	
      	SI sReq>"" ALORS
      		clSQL est un csql(m_nIndiceDeConnexion)
      		SI clSQL.Requête(ChaîneConstruit(sReq,cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].sSchémaOuDC,sNomTable)) ALORS
      			RENVOYER HLitPremier(clSQL.m_sd)
      		SINON
      			m_pclErreur.AjouteErreur(clSQL.p_sErreur) 
      		FIN		
      	FIN
      FIN
      RENVOYER Faux
     type : 458752
   -
     name : DateHeureUTC
     procedure_id : 2295171832486077521
     type_code : 12
     code : |1-
      // Résumé : Renvoie la date et l'heure actuelles en temps universel coordonné (UTC) sur le serveur de BD. 
      // Syntaxe : [ <Résultat> = ] DateHeureUTC ()
      // Paramètres : Aucun
      // Valeur de retour : dateheure : Renvoie une chaîne représentant la date et l'heure au format de la base de données. En cas d'erreur, elle renvoie une chaîne vide.
      // Exemple :
      //
      PROCEDURE DateHeureUTC() : DateHeure
      m_pclErreur.Raz()
      SI PAS cBaseDeDonnées.ConnexionActive(m_nIndiceDeConnexion) ALORS m_pclErreur.AjouteErreur(<§$0007§>);renvoyer ""
      
      clSQL est un csql(m_nIndiceDeConnexion)
      SI clSQL.requete("SELECT now() at time zone 'utc';") _ET_ HLitPremier(clSQL.m_sd) ALORS 
      	SI DateHeureValide(Milieu(clSQL.m_sd.DateHeureSQLServer,2)) ALORS RENVOYER Milieu(clSQL.m_sd.DateHeureSQLServer,2) SINON m_pclErreur.AjouteErreur(<§$0009§>)
      FIN
      RENVOYER ""
     type : 458752
   -
     name : TransactionAnnule
     procedure_id : 2295171914090540479
     type_code : 12
     code : |1-
      // Résumé : Annule la transaction débutée par TransactionDébut.
      // Syntaxe : [ <Résultat> = ] TransactionAnnule ()
      // Paramètres : Aucun
      // Valeur de retour : booléen : Retourne Vrai si la transaction a bien été annulée, sinon elle renvoie Faux.
      // Exemple :
      //
      PROCEDURE TransactionAnnule() : booléen
      SI cApplication._Application<>Null _ET_ cApplication._Application.m_pclTrace<>Null ALORS cApplication._Application.m_pclTrace.AjouteMéthode()
      m_pclErreur.Raz()
      
      SI PAS cBaseDeDonnées.ConnexionActive(m_nIndiceDeConnexion) ALORS m_pclErreur.AjouteErreur(<§$0007§>);renvoyer faux
      
      SI cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].bTransactionEnCours ALORS	//au cas où on aurait la merveilleuse idée d'annuler une transaction qui n'a pas été ouverte
      	SELON cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].eAccès
      		CAS cBaseDeDonnées.FonctionsH
      			SI HTransactionAnnule(cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].cnxDonnées) ALORS 
      				cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].bTransactionEnCours=Faux 
      			SINON 
      				m_pclErreur.AjouteErreurHF()
      			FIN
      		CAS cBaseDeDonnées.RequêteSQL
      			SI HExécuteRequêteSQL("REQ_FRAMEWORK",cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].cnxDonnées,hRequêteSansCorrection,"ROLLBACK ") ALORS 
      				cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].bTransactionEnCours=Faux 
      			SINON 
      				m_pclErreur.AjouteErreurHF()		
      			FIN
      	FIN
      SINON
      	m_pclErreur.AjouteAvertissement(<§$000a§>)
      FIN
      RENVOYER (cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].bTransactionEnCours=Faux)
     type : 458752
   -
     name : TransactionDébut
     procedure_id : 2295171995694938510
     type_code : 12
     code : |1-
      // Résumé : Débute une transaction sur toutes les tables ou certaines.
      // Syntaxe : [ <Résultat> = ] TransactionDébut ( [<sNomTables> est chaîne])
      // Paramètres :
      //	sNomTables (chaîne UNICODE optionnel): Une chaîne contenant les noms des tables sur lesquelles appliquer la transaction, séparés par des virgules. Pour exclure des tables de la transaction, préfixer leur nom d'un tiret -. 
      // Valeur de retour : booléen : Retourne Vrai si la transaction est débutée avec succès, sinon elle renvoie Faux.
      // Exemple :
      //
      PROCEDURE TransactionDébut(sNomTables est une chaîne = "") : booléen	//tables séparées par des , (pour enlever des tables, mettre - devant)
      SI cApplication._Application<>Null _ET_ cApplication._Application.m_pclTrace<>Null ALORS cApplication._Application.m_pclTrace.AjouteMéthode()
      m_pclErreur.Raz()
      
      SI PAS cBaseDeDonnées.ConnexionActive(m_nIndiceDeConnexion) ALORS m_pclErreur.AjouteErreur(<§$0007§>);renvoyer faux
      
      SI PAS cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].bTransactionEnCours ALORS
      	SELON cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].eAccès
      		CAS cBaseDeDonnées.FonctionsH
      			SI HTransactionDébut(cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].cnxDonnées,sNomTables) ALORS 
      				cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].bTransactionEnCours=Vrai
      			SINON 
      				m_pclErreur.AjouteErreurHF()
      			FIN
      		CAS cBaseDeDonnées.RequêteSQL
      			SI HExécuteRequêteSQL("REQ_FRAMEWORK",cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].cnxDonnées,hRequêteSansCorrection,"BEGIN TRANSACTION") ALORS 
      				cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].bTransactionEnCours=Vrai
      			SINON 
      				m_pclErreur.AjouteErreurHF()		//pas de table à passer ici	
      			FIN
      	FIN
      SINON
      	m_pclErreur.AjouteErreur(<§$000b§>)
      FIN
      RENVOYER (cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].bTransactionEnCours=Faux)
     type : 458752
   -
     name : TransactionFin
     procedure_id : 2295172090184305883
     type_code : 12
     code : |1-
      // Résumé : Termine une transaction débutée par TransactionDébut.
      // Syntaxe : [ <Résultat> = ] TransactionFin ()
      // Paramètres : Aucun
      // Valeur de retour : booléen : Retourne Vrai si la transaction a bien été annulée, sinon elle renvoie Faux.
      // Exemple :
      //
      PROCEDURE TransactionFin() : booléen
      SI cApplication._Application<>Null _ET_ cApplication._Application.m_pclTrace<>Null ALORS cApplication._Application.m_pclTrace.AjouteMéthode()
      m_pclErreur.Raz()
      
      SI PAS cBaseDeDonnées.ConnexionActive(m_nIndiceDeConnexion) ALORS m_pclErreur.AjouteErreur(<§$0007§>);renvoyer faux
      
      SI cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].bTransactionEnCours ALORS	//au cas où on aurait la merveilleuse idée de terminer une transaction qui n'a pas été ouverte
      	SELON cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].eAccès
      		CAS cBaseDeDonnées.FonctionsH
      			SI HTransactionFin(cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].cnxDonnées) ALORS 
      				cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].bTransactionEnCours=Faux
      			SINON 
      				m_pclErreur.AjouteErreurHF()
      			FIN
      		CAS cBaseDeDonnées.RequêteSQL
      			SI HExécuteRequêteSQL("REQ_FRAMEWORK",cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].cnxDonnées,hRequêteSansCorrection,"COMMIT ") ALORS 
      				cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].bTransactionEnCours=Faux
      			SINON 
      				m_pclErreur.AjouteErreurHF()	
      			FIN
      	FIN
      SINON
      	m_pclErreur.AjouteAvertissement(<§$000a§>)
      FIN
      RENVOYER (cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].bTransactionEnCours=Faux)
     type : 458752
   -
     name : TableDébloque
     procedure_id : 2295172180378706226
     type_code : 12
     code : |1-
      // Résumé : <indiquez ici ce que fait la procédure>
      // Syntaxe :
      // [ <Résultat> = ] TableDébloque (<sNomTable> est chaîne)
      //
      // Paramètres :
      //	sNomTable (chaîne UNICODE) : <indiquez ici le rôle de sNomTable>
      // Valeur de retour :
      // 	booléen : <indiquez ici les valeurs possibles ainsi que leur interprétation>
      //
      // Exemple :
      // Indiquez ici un exemple d'utilisation.
      //
      //
      PROCEDURE TableDébloque(sNomTable est une chaine) : booleen
      //à compléter
      SI cApplication._Application<>Null _ET_ cApplication._Application.m_pclTrace<>Null ALORS cApplication._Application.m_pclTrace.AjouteMéthode(sNomTable)
      m_pclErreur.Raz()
      
      SI PAS cBaseDeDonnées.ConnexionActive(m_nIndiceDeConnexion) ALORS m_pclErreur.AjouteErreur(<§$0007§>);renvoyer faux
      
      SELON cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].eAccès
      	CAS cBaseDeDonnées.FonctionsH
      	CAS cBaseDeDonnées.RequêteSQL
      FIN
     type : 458752
   -
     name : TableBloque
     procedure_id : 2295172253393166622
     type_code : 12
     code : |1-
      // Résumé : <indiquez ici ce que fait la procédure>
      // Syntaxe :
      // [ <Résultat> = ] TableBloque (<sNomTable> est chaîne, <sCléPrimaire> est chaîne)
      //
      // Paramètres :
      //	sNomTable (chaîne UNICODE) : <indiquez ici le rôle de sNomTable>
      //	sCléPrimaire (chaîne UNICODE) : <indiquez ici le rôle de sCléPrimaire>
      // Valeur de retour :
      // 	booléen : <indiquez ici les valeurs possibles ainsi que leur interprétation>
      //
      // Exemple :
      // Indiquez ici un exemple d'utilisation.
      //
      //
      PROCEDURE TableBloque(sNomTable est une chaîne,sCléPrimaire est une chaine) : booleen
      //à compléter
      SI cApplication._Application<>Null _ET_ cApplication._Application.m_pclTrace<>Null ALORS cApplication._Application.m_pclTrace.AjouteMéthode()
      m_pclErreur.Raz()
      SI PAS cBaseDeDonnées.ConnexionActive(m_nIndiceDeConnexion) ALORS m_pclErreur.AjouteErreur(<§$0007§>);renvoyer faux
      //pas de blocage de table en PostgreSQL. Il faut utiliser les transactions
      RENVOYER faux
     type : 458752
   -
     name : SQLColonneMémoVide
     procedure_id : 2295172334997629736
     type_code : 12
     group : 3
     code : |1-
      // Résumé : Renvoie du code SQL d'une colonne binaire vide. Permet de récupérer un binaire vide dans le résultat plutôt que de charger le binaire dès le départ.
      // Syntaxe : [ <Résultat> = ] SQLColonneMémoVide (<sNomColonne> est chaîne)
      // Paramètres :
      //	sNomColonne (chaîne UNICODE) : Le nom de la colonne mémo pour laquelle la vérification sera faite.
      // Valeur de retour : chaîne UNICODE : Code SQL d'une colonne binaire vide
      // Exemple :
      //
      PROCEDURE SQLColonneMémoVide(sNomColonne est une chaine) : chaine
      RENVOYER  "cast('' as bytea) AS "+sNomColonne
     type : 458752
   -
     name : TableVersion
     procedure_id : 2295172438076934447
     type_code : 12
     code : |1-
      // Résumé : Renvoie la version d'une table passée en paramètre (n'est pas géré par Oracle, renvoie toujours 0).
      // Syntaxe : [ <Résultat> = ] TableVersion (<sNomTable> est chaîne)
      // Paramètres :
      //	sNomTable (chaîne UNICODE) : Le nom de la table pour laquelle l'on souhaite la version.
      // Valeur de retour : entier : Numéro de version de la table
      // Exemple :
      //
      PROCEDURE TableVersion(sNomTable est une chaine) : entier
      RENVOYER 0
     type : 458752
   -
     name : SQLTableForceIDauto
     procedure_id : 2295172502501459659
     type_code : 12
     group : 3
     code : |1-
      // Résumé : Retourne le code SQL permettant d'activer ou de désactive la gestion de l'identifiant auto-incrémental sur une table passé en paramètre. Rien à faire, juste mettre le nom de la colonne et une valeur va forcer la valeur
      // Syntaxe : [ <Résultat> = ] SQLTableForceIDauto (<sNomTable> est chaîne, <bForce> est booléen)
      // Paramètres :
      //	sNomTable (chaîne UNICODE) : Le nom de la table pour laquelle la contrainte doit être définie ou désactivée.
      //	bForce (booléen) : Si vrai, la contrainte d'auto-incrémentation sera activée. Si faux, la contrainte sera désactivée.
      // Valeur de retour : chaîne UNICODE : Contient le code SQL à utiliser pour activer ou désactiver la gestion de l'identifiant auto-incrémental. Chaine vide si en erreur ou si la fonction n'est pas supportée par la base de données cible.
      // Exemple :
      //
      PROCEDURE SQLTableForceIDauto(sNomTable est une chaine,bForce est un booleen) : chaine
      RENVOYER ""
     type : 458752
   -
     name : SQLLimiteRequêteA
     procedure_id : 2295172579810954245
     type_code : 12
     group : 3
     code : |1-
      // Résumé : Génère les parties préliminaire et postliminaire d'une requête SQL destinés à limiter le nombre de résultats renvoyés.
      // Syntaxe : [ <Résultat> = ] SQLLimiteRequêteA (<nNombre> est entier [, <bAvecWhere> est booléen])
      // Paramètres :
      //	nNombre (entier) : Le nombre maximum de résultats à renvoyer dans la requête.
      // 	bAvecWhere (booléen optionnel) : N'influence pas le résultat
      // Valeur de retour : multi-valeur : Renvoie le code SQL des parties à intégrer dans une requête SQL pour limiter le nombre de résultats.
      // Exemple :
      //
      PROCEDURE SQLLimiteRequêteA(nNombre est un entier,bAvecWhere est un booleen = faux) : (chaine,chaine)
      sPréLimite,sPostLimite sont des chaines
      sPostLimite	= "LIMIT ("+nNombre+")"
      RENVOYER (sPréLimite,sPostLimite)
     type : 458752
   -
     name : Liste
     procedure_id : 2295172665710385107
     type_code : 12
     code : |1-
      // Résumé : Renvoie la liste des base de données présents sur le serveur.
      // Syntaxe : [ <Résultat> = ] Liste ( [, <sServeurPort> est chaîne [, <sUtilisateur> est chaîne [, <sMotDePasse> est chaîne ]]])
      // Paramètres :
      //	sServeurPort (chaîne UNICODE) : L'adresse du serveur et le port à utiliser pour la connexion à la base de données Oracle.
      //	sUtilisateur (chaîne UNICODE) : Le nom de l'utilisateur à utiliser pour la connexion à la base de données Oracle.
      //	sMotDePasse (chaîne UNICODE) : Le mot de passe à utiliser pour la connexion à la base de données Oracle.
      // Valeur de retour : chaîne UNICODE : Liste des bases de données présentes sur le serveur séparés par RC
      // Exemple :
      //
      PROCEDURE Liste(LOCAL sServeurPort est une chaine = cApplication._Application.m_pclParamètres.Lit("Postgres","Address"),
      	sUtilisateur est une chaine = cApplication._Application.m_pclParamètres.Lit("Postgres","User"),
      	sMotDePasse est une chaîne = cApplication._Application.m_pclParamètres.Lit("Postgres","Password",Vrai),bAccessible est un booleen = vrai) : chaine
      
      SI cApplication._Application<>Null _ET_ cApplication._Application.m_pclTrace<>Null ALORS cApplication._Application.m_pclTrace.AjouteMéthode(sServeurPort,sUtilisateur,Répète(_Sep,Taille(sMotDePasse)),bAccessible)
      m_pclErreur.Raz()
      
      sListe 		est une chaine
      cnxListe 	est une Connexion 
      cnxListe..Utilisateur 	= sUtilisateur
      cnxListe..MotDePasse 	= sMotDePasse 
      cnxListe..Serveur 		= sServeurPort
      cnxListe..BaseDeDonnées = "" 
      cnxListe..Provider 		= hAccèsNatifPostgreSQL
      SI HOuvreConnexion(cnxListe) ALORS
      	//	sListe=remplace(HListeBaseDeDonnées(cnxListe,hLstNormal),tab,rc)	//pas autorisé par l'accès natif
      	sdBD est une source de données
      	SI HExécuteRequêteSQL(sdBD,cnxListe,hRequêteSansCorrection,"SELECT datname FROM pg_database WHERE datistemplate = false") ALORS
      		POUR TOUT sdBD
      			sListe+=[RC]+sdBD.datname
      		FIN
      	SINON
      		m_pclErreur.AjouteErreurHF()
      	FIN
      	HFermeConnexion(cnxListe)
      SINON
      	m_pclErreur.AjouteErreurHF()
      FIN
      RENVOYER sListe
     type : 458752
   -
     name : DateVersSQL
     procedure_id : 2295172781674530008
     type_code : 12
     group : 2
     code : |1-
      // Résumé : Transforme une date dans le format SQL.
      // Syntaxe : [ <Résultat> = ] DateVersSQL (<xDateHeure>)
      // Paramètres : 
      // 	xDate : La date à convertir. Le type de cette valeur peut être date ou une chaine équivalente
      // Valeur de retour : chaîne UNICODE : Renvoie une chaîne représentant la date converties au format SQL. En cas d'erreur, elle renvoie une chaîne vide.
      // Exemple :
      //
      PROCEDURE DateVersSQL(xDate) : chaine
      SI DateValide(xDate) ALORS RENVOYER "to_date('"+xDate+"', 'YYYYMMDD')" sinon renvoyer "''"
     type : 458752
   -
     name : DateHeureVersSQL
     procedure_id : 2295172846099119367
     type_code : 12
     group : 2
     code : |1-
      // Résumé : Exécute la méthode, de la classe de la BD dont l'indice est passé au constructeur, qui transforme une dateheure dans le format SQL.
      // Syntaxe : [ <Résultat> = ] DateHeureVersSQL (<xDateHeure>)
      // Paramètres : 
      // 	xDateHeure : La date et l'heure à convertir. Le type de cette valeur peut être dateheure ou une chaine équivalente
      // Valeur de retour : chaîne UNICODE : Renvoie une chaîne représentant la date et l'heure converties au format SQL. En cas d'erreur, elle renvoie une chaîne vide.
      // Exemple :
      //
      PROCEDURE DateHeureVersSQL(xDateHeure) : chaine
      SI DateHeureValide(xDateHeure) ALORS rENVOYER "to_timestamp('"+xDateHeure+"','YYYYMMDDHH24MISS')" sinon renvoyer "''"
     type : 458752
   -
     name : SQLRetourIDAuto
     procedure_id : 2295172910523708976
     type_code : 12
     group : 3
     code : |1-
      // Résumé : Retourne le code SQL pour permettre la récupération de l'identifiant auto-incrémental en cas d'ajout d'enregistrement.
      // Syntaxe : [ <Résultat> = ] SQLRetourIDAuto (<sNomColonneIDAuto> est chaîne)
      // Paramètres :
      //	sNomColonneIDAuto (chaîne UNICODE) : Nom de la colonne ou code SQL permettant de récupérer l'ID automatique
      // Valeur de retour : chaîne UNICODE : Code SQL pour permettre la récupération de l'identifiant auto-incrémental.
      // Exemple :
      //
      PROCEDURE SQLRetourIDAuto(sNomColonneIDAuto est une chaine) : chaine
      RENVOYER "RETURNING "+[SQLAvantColonne()]+sNomColonneIDAuto+[SQLAprèsColonne()]
     type : 458752
   -
     name : SQLUnicodePréfixe
     procedure_id : 2295172970653331617
     type_code : 12
     group : 3
     code : |1-
      // Résumé : Récupère le préfixe d'une chaine Unicode à utiliser dans une requête SQL.
      // Syntaxe : [ <Résultat> = ] SQLUnicodePréfixe ()
      // Paramètres : Aucun
      // Valeur de retour : chaîne UNICODE : Préfixe à ajouter à une chaine Unicode pour exécuter une requête dans la BD.
      // Exemple :
      //
      PROCEDURE SQLUnicodePréfixe() : chaîne
      RENVOYER ""
     type : 458752
   -
     name : SQLUnicodeSuffixe
     procedure_id : 2295173026487984340
     type_code : 12
     group : 3
     code : |1-
      // Résumé : Exécute la méthode, de la classe de la BD dont l'indice est passé au constructeur, qui récupère le suffixe d'une chaine Unicode à utiliser dans une requête SQL.
      // Syntaxe : [ <Résultat> = ] SQLUnicodeSuffixe ()
      // Paramètres : Aucun
      // Valeur de retour : chaîne UNICODE : Suffixe à ajouter à une chaine Unicode pour exécuter une requête dans la BD.
      // Exemple :
      //
      PROCEDURE SQLUnicodeSuffixe() : chaîne
      RENVOYER ""
     type : 458752
   -
     name : HeureVersSQL
     procedure_id : 2295173112387350681
     type_code : 12
     group : 2
     code : |1-
      // Résumé : Transforme une heure dans le format SQL.
      // Syntaxe : [ <Résultat> = ] DateHeureVersSQL (<xDateHeure>)
      // Paramètres : 
      // 	xHeure : L'heure à convertir. Le type de cette valeur peut être heure ou une chaine équivalente
      // Valeur de retour : chaîne UNICODE : Renvoie une chaîne représentant l'heure converties au format SQL.
      // Exemple :
      //
      PROCEDURE HeureVersSQL(xHeure) : chaine                   
      SI HeureValide(xHeure) ALORS 
      	hHeure est une heure = xHeure
      	RENVOYER "'"+HeureVersChaîne(hHeure,"HH:MM:SS:CC0")+"'" 
      SINON 
      	RENVOYER "''"
      FIN
     type : 458752
   -
     name : ExécuteFonctionVersJSON
     procedure_id : 2295173176811940726
     type_code : 12
     code : |1+
      // Résumé : Exécute une fonction stockée avec ses paramètres le cas échéant.
      // Syntaxe : [ <Résultat> = ] ExécuteFonctionVersJSON (<sNomDeFonction> est chaîne [, <xParam1> [, <xParam2> [, <xParam3> [, <xParam4> [, <xParam5> [, <xParam6> [, <xParam7> [, <xParam8> [, <xParam9> [, <xParam10> [, <xParam11> [, <xParam12> [, <xParam13> [, <xParam14> [, <xParam15> [, <xParam16> [, <xParam17> [, <xParam18> [, <xParam19> [, <xParam20>]]]]]]]]]]]]]]]]]]]])
      // Paramètres :
      //	sNomDeFonction (chaîne UNICODE) : Le nom de la fonction stockée à exécuter.
      // 	xParam1 (valeur optionnelle) : Les paramètres de la fonction stockée. 
      // 	xParam2 (valeur optionnelle) : Les paramètres de la fonction stockée. 
      // 	xParam3 (valeur optionnelle) : Les paramètres de la fonction stockée. 
      // 	xParam4 (valeur optionnelle) : Les paramètres de la fonction stockée. 
      // 	xParam5 (valeur optionnelle) : Les paramètres de la fonction stockée. 
      // 	xParam6 (valeur optionnelle) : Les paramètres de la fonction stockée. 
      // 	xParam7 (valeur optionnelle) : Les paramètres de la fonction stockée. 
      // 	xParam8 (valeur optionnelle) : Les paramètres de la fonction stockée. 
      // 	xParam9 (valeur optionnelle) : Les paramètres de la fonction stockée. 
      // 	xParam10 (valeur optionnelle) : Les paramètres de la fonction stockée. 
      // 	xParam11 (valeur optionnelle) : Les paramètres de la fonction stockée. 
      // 	xParam12 (valeur optionnelle) : Les paramètres de la fonction stockée. 
      // 	xParam13 (valeur optionnelle) : Les paramètres de la fonction stockée. 
      // 	xParam14 (valeur optionnelle) : Les paramètres de la fonction stockée. 
      // 	xParam15 (valeur optionnelle) : Les paramètres de la fonction stockée. 
      // 	xParam16 (valeur optionnelle) : Les paramètres de la fonction stockée. 
      // 	xParam17 (valeur optionnelle) : Les paramètres de la fonction stockée. 
      // 	xParam18 (valeur optionnelle) : Les paramètres de la fonction stockée. 
      // 	xParam19 (valeur optionnelle) : Les paramètres de la fonction stockée. 
      // 	xParam20 (valeur optionnelle) : Les paramètres de la fonction stockée. 
      // Valeur de retour : chaîne Unicode : Valeur de retour de la fonction au format JSON. En cas d'erreur, elle renvoie Faux et enregistre les détails de l'erreur dans l'objet m_pclErreur.
      // Exemple :
      //
      PROCEDURE ExécuteFonctionVersJSON(sNomDeFonction est une chaine,xParam1 <utile> = Null,xParam2 <utile> = Null,xParam3 <utile> = Null,xParam4 <utile> = Null,xParam5 <utile> = Null,xParam6 <utile> = Null,xParam7 <utile> = Null,xParam8 <utile> = Null,xParam9 <utile> = Null,xParam10 <utile> = Null,xParam11 <utile> = Null,xParam12 <utile> = Null,xParam13 <utile> = Null,xParam14 <utile> = Null,xParam15 <utile> = Null,xParam16 <utile> = Null,xParam17 <utile> = Null,xParam18 <utile> = Null,xParam19 <utile> = Null,xParam20 <utile> = Null): booleen	//on ne peut pas faire * car pas compatible avec Java 
      m_pclErreur.Raz()
      SI cApplication._Application<>Null _ET_ cApplication._Application.m_pclTrace<>Null ALORS cApplication._Application.m_pclTrace.AjouteMéthode(sNomDeFonction,xParam1,xParam2,xParam3,xParam4,xParam5)
      
      SI PAS cBaseDeDonnées.ConnexionActive(m_nIndiceDeConnexion) ALORS m_pclErreur.AjouteErreur(<§$0007§>);renvoyer faux
      
      sParams,sRes,sEnreg	sont des chaines
      
      POUR nParamètre =  1 _À_ 20	//WD23 : mesParamètres pas dispo en Java et PHP
      	sParams+=[", "]+(TypeVar({"xParam"+nParamètre,indVariable})=wlVariant ET {"xParam"+nParamètre,indVariable}=Null ? "" SINON (EstChaine(TypeVar({"xParam"+nParamètre,indVariable})) ? "'"+Remplace({"xParam"+nParamètre,indVariable},"'","''") SINON ""+{"xParam"+nParamètre,indVariable})+(EstChaine(TypeVar({"xParam"+nParamètre,indVariable})) ? "'" SINON ""))
      FIN
      
      clSQL est un cSQL(m_nIndiceDeConnexion)
      SI clSQL.Requête(ChaîneConstruit("SELECT * FROM %1"+[" "]+(sParams="" ? "" SINON "("+sParams+")"),sNomDeFonction)) ALORS
      	
      
      <si CibleExécution=ApplicationWindows ou CibleExécution=Site ou CibleExécution=Webservice ou CibleExécution=AssemblageDotNet ou CibleExécution=ApplicationLinux64 ou CibleExécution=ServiceWindows ou CibleExécution=ServiceLinux64 ou CibleExécution=iOS ou CibleExécution=UniversalWindowsApp>
      	
      	POUR TOUT clSQL.m_sd
      		sEnreg=HEnregistrementVersJSON(clSQL.m_sd)
      		sEnreg=Milieu(sEnreg,Position(sEnreg,":")+1)
      		sRes+=[","]+Gauche(sEnreg,Taille(sEnreg)-1)
      	FIN
      	
      <fin>
      
      
      	RENVOYER "["+sRes+"]"
      SINON
      	m_pclErreur.AjouteErreur(clSQL.p_sErreur)
      	RENVOYER sRes
      FIN
      	
      	PROCÉDURE INTERNE EstChaine(nType)
      	RENVOYER (nType DANS (wlChaîneUnicode,wlChaîneAnsi,wlChaîneASCIIZ,wlChaîneFixe,wlChaînePascal,50))
      	FIN
     type : 458752
   -
     name : ExécuteProcédure
     procedure_id : 2295173318545959791
     type_code : 12
     code : |1+
      // Résumé : Exécute une procédure stockée sur la base de données prise en charge par le passage de l'indice de connexion dans le constructeur.
      // Syntaxe : [ <Résultat> = ] ExécuteProcédure (<sNomDeProcédure> est chaîne [, <xParam1> [, <xParam2> [, <xParam3> [, <xParam4> [, <xParam5> [, <xParam6> [, <xParam7> [, <xParam8> [, <xParam9> [, <xParam10> [, <xParam11> [, <xParam12> [, <xParam13> [, <xParam14> [, <xParam15> [, <xParam16> [, <xParam17> [, <xParam18> [, <xParam19> [, <xParam20>]]]]]]]]]]]]]]]]]]]])
      // Paramètres :
      //	sNomDeProcédure (chaîne UNICODE) : Le nom de la procédure stockée à exécuter.
      // 	xParam1 (valeur optionnelle) : Les paramètres de la procédure stockée. 
      // 	xParam2 (valeur optionnelle) : Les paramètres de la procédure stockée. 
      // 	xParam3 (valeur optionnelle) : Les paramètres de la procédure stockée. 
      // 	xParam4 (valeur optionnelle) : Les paramètres de la procédure stockée. 
      // 	xParam5 (valeur optionnelle) : Les paramètres de la procédure stockée. 
      // 	xParam6 (valeur optionnelle) : Les paramètres de la procédure stockée. 
      // 	xParam7 (valeur optionnelle) : Les paramètres de la procédure stockée. 
      // 	xParam8 (valeur optionnelle) : Les paramètres de la procédure stockée. 
      // 	xParam9 (valeur optionnelle) : Les paramètres de la procédure stockée. 
      // 	xParam10 (valeur optionnelle) : Les paramètres de la procédure stockée. 
      // 	xParam11 (valeur optionnelle) : Les paramètres de la procédure stockée. 
      // 	xParam12 (valeur optionnelle) : Les paramètres de la procédure stockée. 
      // 	xParam13 (valeur optionnelle) : Les paramètres de la procédure stockée. 
      // 	xParam14 (valeur optionnelle) : Les paramètres de la procédure stockée. 
      // 	xParam15 (valeur optionnelle) : Les paramètres de la procédure stockée. 
      // 	xParam16 (valeur optionnelle) : Les paramètres de la procédure stockée. 
      // 	xParam17 (valeur optionnelle) : Les paramètres de la procédure stockée. 
      // 	xParam18 (valeur optionnelle) : Les paramètres de la procédure stockée. 
      // 	xParam19 (valeur optionnelle) : Les paramètres de la procédure stockée. 
      // 	xParam20 (valeur optionnelle) : Les paramètres de la procédure stockée. 
      // Valeur de retour : booléen : Indique si l'exécution de la procédure stockée a réussi. En cas d'erreur, elle renvoie Faux et enregistre les détails de l'erreur dans l'objet m_pclErreur.
      // Exemple :
      //
      PROCEDURE ExécuteProcédure(sNomDeProcédure est une chaine,xParam1 <utile> = Null,xParam2 <utile> = Null,xParam3 <utile> = Null,xParam4 <utile> = Null,xParam5 <utile> = Null,xParam6 <utile> = Null,xParam7 <utile> = Null,xParam8 <utile> = Null,xParam9 <utile> = Null,xParam10 <utile> = Null,xParam11 <utile> = Null,xParam12 <utile> = Null,xParam13 <utile> = Null,xParam14 <utile> = Null,xParam15 <utile> = Null,xParam16 <utile> = Null,xParam17 <utile> = Null,xParam18 <utile> = Null,xParam19 <utile> = Null,xParam20 <utile> = Null): booleen	//on ne peut pas faire * car pas compatible avec Java 
      SI cApplication._Application<>Null _ET_ cApplication._Application.m_pclTrace<>Null ALORS cApplication._Application.m_pclTrace.AjouteMéthode(sNomDeProcédure,xParam1,xParam2,xParam3,xParam4,xParam5)
      m_pclErreur.Raz()
      
      SI PAS cBaseDeDonnées.ConnexionActive(m_nIndiceDeConnexion) ALORS m_pclErreur.AjouteErreur(<§$0007§>);renvoyer faux
      
      sParams est une chaine
      
      POUR nParamètre =  1 _À_ 20	//WD23 : mesParamètres pas dispo en Java et PHP
      	sParams+=[", "]+(TypeVar({"xParam"+nParamètre,indVariable})=wlVariant ET {"xParam"+nParamètre,indVariable}=Null ? "" SINON (EstChaine(TypeVar({"xParam"+nParamètre,indVariable})) ? "'"+Remplace({"xParam"+nParamètre,indVariable},"'","''") SINON ""+{"xParam"+nParamètre,indVariable})+(EstChaine(TypeVar({"xParam"+nParamètre,indVariable})) ? "'" SINON ""))
      FIN
      
      clSQL est un csql(m_nIndiceDeConnexion)
      SI clSQL.Requête(ChaîneConstruit("%1"+[" "]+(sParams="" ? "" SINON sParams),sNomDeProcédure)) ALORS
      	RENVOYER Vrai
      SINON
      	m_pclErreur.AjouteErreur(clSQL.p_sErreur)
      	RENVOYER Faux
      FIN
      
      	PROCÉDURE INTERNE EstChaine(nType)
      	RENVOYER (nType DANS (wlChaîneUnicode,wlChaîneAnsi,wlChaîneASCIIZ,wlChaîneFixe,wlChaînePascal,50))
      	FIN
     type : 458752
   -
     name : HashDansBinaire
     procedure_id : 2295173413035262704
     type_code : 12
     code : |1-
      // Résumé : Exécute une fonction pour transférer le hash contenu dans une colonne dans le binaire.
      // Syntaxe : [ <Résultat> = ] HashDansBinaire (<sNomTable> est chaîne, <sColonneBinaire> est chaîne [, <sColonneHash> est chaîne [, <sCondition> est chaîne]])
      // Paramètres :
      //	sNomTable (chaîne UNICODE) : Le nom de la table dans lequel se trouve la colonne binaire.
      //	sColonneBinaire (chaîne UNICODE) : Le nom de la colonne binaire dans laquelle le hash sera ajouté.
      //	sColonneHash (chaîne UNICODE optionnelle) : Le nom de la colonne dans laquelle se trouve déjà le hash du binaire, par défaut le nom de la colonne binaire suffixé de "Hash".
      //	sCondition (chaîne UNICODE optionnelle) : Une condition optionnelle pour filtrer les lignes de la table qui vont voir appliquer ce traitement.
      // Valeur de retour : booléen : Indique si le transfert du hash a été effectué avec succès. En cas d'erreur, elle renvoie Faux et enregistre les détails de l'erreur dans l'objet m_pclErreur.
      // Exemple :
      //
      PROCEDURE HashDansBinaire(sNomTable est une chaîne,sColonneCléUnique est une chaine, sColonneBinaire est une chaîne,sColonneHash est une chaine = sColonneBinaire+"Hash",sCondition est une chaine = "") : booleen
      SI cApplication._Application<>Null _ET_ cApplication._Application.m_pclTrace<>Null ALORS cApplication._Application.m_pclTrace.AjouteMéthode(sNomTable,sColonneCléUnique,sColonneBinaire,sColonneHash,sCondition)
      m_pclErreur.Raz()
      
      SI PAS cBaseDeDonnées.ConnexionActive(m_nIndiceDeConnexion) ALORS m_pclErreur.AjouteErreur(<§$0007§>);renvoyer faux
      
      clMemoLit est un csql(m_nIndiceDeConnexion)
      SI clMemoLit.Requête("SELECT "+SQLAvantColonne()+sColonneCléUnique+SQLAprèsColonne()+" AS ID,"+SQLAvantColonne()+sColonneBinaire+SQLAprèsColonne()+" AS BetulaMemo, "+SQLAvantColonne()+sColonneHash+SQLAprèsColonne()+"] AS BetulaHash FROM "+SQLAvantTable()+sNomTable+SQLAprèsTable()+[" WHERE "]+sCondition) ALORS
      	bufBinaire,bufHash sont des buffers
      	clMemoEcrit est un csql(m_nIndiceDeConnexion)
      	POUR TOUT clMemoLit.m_sd
      		bufBinaire 	= {clMemoLit.m_sd+".BetulaMemo",indRubrique}
      		bufHash 	= {clMemoLit.m_sd+".BetulaHash",indRubrique}
      		SI bufHash="" ALORS
      			SI HashChaîne(HA_MD5_128,Milieu(bufBinaire,9))=Gauche(bufBinaire,8) ALORS 
      				CONTINUE	//le hash est déjà dedans
      			SINON
      				bufHash=HashChaîne(HA_MD5_128,bufBinaire)
      			FIN
      		FIN
      		bufBinaire=bufHash+bufBinaire
      		sValeurs est une chaine = SQLAvantColonne()+sColonneBinaire+SQLAprèsColonne()+"=0x"+BufferVersHexa(bufBinaire,SansRegroupement,SansLigne)+[","]+SQLAvantColonne()+sColonneHash+SQLAprèsColonne()+"=NULL"
      		SI PAS clMemoEcrit.Requête("UPDATE "+SQLAvantTable()+sNomTable+SQLAprèsTable()+" SET "+sValeurs+" WHERE ["+sColonneCléUnique+"] = "+clMemoLit.m_sd.ID) ALORS m_pclErreur.AjouteErreur(clMemoEcrit.p_sErreurTout);RENVOYER Faux
      	FIN
      	RENVOYER Vrai
      SINON
      	m_pclErreur.AjouteErreur(clMemoLit.p_sErreurTout);RENVOYER Faux
      FIN
     type : 458752
   -
     name : HashHorsBinaire
     procedure_id : 2295173533294439766
     type_code : 12
     code : |1-
      // Résumé : Exécute une fonction pour transférer le hash contenu dans une colonne binaire vers une autre colonne.
      // Syntaxe : [ <Résultat> = ] HashHorsBinaire (<sNomTable> est chaîne, <sColonneBinaire> est chaîne [, <sColonneHash> est chaîne [, <sCondition> est chaîne]])
      // Paramètres :
      //	sNomTable (chaîne UNICODE) : Le nom de la table dans lequel se trouve la colonne binaire
      //	sColonneBinaire (chaîne UNICODE) : Le nom de la colonne binaire dans laquelle le hash se trouve ajouté à la donnée binaire.
      //	sColonneHash (chaîne UNICODE optionnelle) : Le nom de la colonne dans laquelle se transféré le hash du binaire, par défaut le nom de la colonne binaire suffixé de "Hash"
      //	sCondition (chaîne UNICODE optionnelle) : Une condition optionnelle pour filtrer les lignes de la table qui vont voir appliquer ce traitement.
      // Valeur de retour : booléen : Indique si le transfert du hash a été effectué avec succès. En cas d'erreur, elle renvoie Faux et enregistre les détails de l'erreur dans l'objet m_pclErreur.
      // Exemple :
      //
      PROCEDURE HashHorsBinaire(sNomTable est une chaîne,sColonneCléUnique est une chaine, sColonneBinaire est une chaîne,sColonneHash est une chaine = sColonneBinaire+"Hash",sCondition est une chaine = "") : booleen
      SI cApplication._Application<>Null _ET_ cApplication._Application.m_pclTrace<>Null ALORS cApplication._Application.m_pclTrace.AjouteMéthode(sNomTable,sColonneCléUnique,sColonneBinaire,sColonneHash,sCondition)
      m_pclErreur.Raz()
      
      SI PAS cBaseDeDonnées.ConnexionActive(m_nIndiceDeConnexion) ALORS m_pclErreur.AjouteErreur(<§$0007§>);renvoyer faux
      
      clMemoLit est un csql(m_nIndiceDeConnexion)
      SI clMemoLit.Requête("SELECT "+SQLAvantColonne()+sColonneCléUnique+SQLAprèsColonne()+" AS ID,"+SQLAvantColonne()+sColonneBinaire+SQLAprèsColonne()+" AS BetulaMemo, "+SQLAvantColonne()+sColonneHash+SQLAprèsColonne()+"] AS BetulaHash FROM "+SQLAvantTable()+sNomTable+SQLAprèsTable()+[" WHERE "]+sCondition) ALORS
      	bufBinaire,bufHash sont des buffers
      	clMemoEcrit est un csql(m_nIndiceDeConnexion)
      	POUR TOUT clMemoLit.m_sd
      		bufBinaire 	= {clMemoLit.m_sd+".BetulaMemo",indRubrique}
      		bufHash 	= {clMemoLit.m_sd+".BetulaHash",indRubrique}
      		SI bufHash="" ALORS
      			SI HashChaîne(HA_MD5_128,Milieu(bufBinaire,9))=Gauche(bufBinaire,8) ALORS 
      				bufHash		= Gauche(bufBinaire,8)
      				bufBinaire	= Milieu(bufBinaire,9)
      			SINON
      				bufHash		= HashChaîne(HA_MD5_128,bufBinaire)
      			FIN
      		FIN
      		sValeurs est une chaine = SQLAvantColonne()+sColonneBinaire+SQLAprèsColonne()+"=0x"+BufferVersHexa(bufBinaire,SansRegroupement,SansLigne)+[","]+SQLAvantColonne()+sColonneHash+SQLAprèsColonne()+"=0x"+BufferVersHexa(bufHash,SansRegroupement,SansLigne)
      		SI PAS clMemoEcrit.Requête("UPDATE "+SQLAvantTable()+sNomTable+SQLAprèsTable()+" SET "+sValeurs+" WHERE "+sColonneCléUnique+"="+clMemoLit.m_sd.ID) ALORS m_pclErreur.AjouteErreur(clMemoEcrit.p_sErreurTout);RENVOYER Faux
      	FIN
      	RENVOYER Vrai
      SINON
      	m_pclErreur.AjouteErreur(clMemoLit.p_sErreurTout);RENVOYER Faux
      FIN
     type : 458752
   -
     name : SQLAvantTable
     procedure_id : 2295173726568013077
     type_code : 12
     group : 3
     code : |1-
      // Résumé : Renvoi du SQL à mettre devant le nom d'une table (ex [ pour SQLServer).
      // Syntaxe : [ <Résultat> = ] SQLAvantTable ()
      // Paramètres : Aucun
      // Valeur de retour : chaîne UNICODE : Représente l'expression/les caractères à mettre devant toute référence à une table lors d'une requête SQL.
      // Exemple :
      //
      PROCEDURE SQLAvantTable() : chaîne
      RENVOYER cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].sSchémaOuDC+"."+cGénérique._Guillemet
     type : 458752
   -
     name : SQLAprèsTable
     procedure_id : 2295173782402666643
     type_code : 12
     group : 3
     code : |1-
      // Résumé : Renvoi du SQL à mettre devant le nom d'une table (ex ] pour SQLServer).
      // Syntaxe : [ <Résultat> = ] SQLAprèsTable ()
      // Paramètres : Aucun
      // Valeur de retour : chaîne UNICODE : Représente l'expression/les caractères à mettre après toute référence à une table lors d'une requête SQL.
      // Exemple :
      //
      PROCEDURE SQLAprèsTable() : chaîne
      RENVOYER cGénérique._Guillemet
     type : 458752
   -
     name : SQLAvantColonne
     procedure_id : 2295173842532288347
     type_code : 12
     group : 3
     code : |1-
      // Résumé : Renvoi du SQL à mettre devant le nom d'une colonne (ex [ pour SQLServer).
      // Syntaxe : [ <Résultat> = ] SQLAvantColonne ()
      // Paramètres : Aucun
      // Valeur de retour : chaîne UNICODE : Représente l'expression/les caractères à mettre devant toute référence à une colonne lors d'une requête SQL.
      // Exemple :
      //
      PROCEDURE SQLAvantColonne() : chaîne
      RENVOYER cGénérique._Guillemet
     type : 458752
   -
     name : SQLAprèsColonne
     procedure_id : 2295173911251781136
     type_code : 12
     group : 3
     code : |1-
      // Résumé : Renvoi du SQL à mettre devant le nom d'une colonne (ex ] pour SQLServer).
      // Syntaxe : [ <Résultat> = ] SQLAprèsColonne ()
      // Paramètres : Aucun
      // Valeur de retour : chaîne UNICODE : Représente l'expression/les caractères à mettre après toute référence à une colonne lors d'une requête SQL.
      // Exemple :
      //
      PROCEDURE SQLAprèsColonne() : chaîne
      RENVOYER cGénérique._Guillemet
     type : 458752
   -
     name : TableColonnes
     procedure_id : 2295173975676371291
     type_code : 12
     code : |1+
      // Résumé : Charge les colonnes d'une table passée en paramètre.
      // Syntaxe : [ <Résultat> = ] TableColonnes (<sNomTableUnique> est chaîne [, <bDescriptionComplète> est booléen [, <bForceRechargement> est booléen]])
      // Paramètres :
      //	sNomTableUnique (chaîne UNICODE) : Le nom unique de la table pour laquelle les informations sur les colonnes doivent être récupérées.
      // 	bDescriptionComplète (booléen optionnel) : Indique s'il faut récupérer la description complète de chaque colonne ou pas. Si Faux, récupère le nom de la table, le nom de la colonne, sa position, si elle est nullable, le type de date, si elle est automatique, si elle est une clé, si elle est calculée
      //		Si vrai, ajoute les informations suivantes : Le type de numérique, le nombre de caractères max et la valeur par défaut
      // 	bForceRechargement (booléen optionnel) : Force le rechargement de la description même si celle-ci est déjà en mémoire
      // Valeur de retour : booléen : Vrai si les informations de la table ont été mémorisées dans cApplication.mg_taInfo[sNomTableUnique].p_tabColonnes, Faux en cas d'erreur.
      // Exemple :
      //
      PROCEDURE TableColonnes(LOCAL sNomTableUnique est une chaine,bDescriptionComplète est un booleen = faux,bForceRechargement est un booleen = faux) : booleen
      m_pclErreur.Raz()
      
      SI PAS cBaseDeDonnées.ConnexionActive(m_nIndiceDeConnexion) ALORS m_pclErreur.AjouteErreur(<§$0007§>);renvoyer faux
      
      clObjetBD	est un cBaseDeDonnées(m_nIndiceDeConnexion)
      sNomTable 	est une chaine
      
      si position(sNomTableUnique,cGénérique._sep)>0 alors
      	sNomTable = cApplication.mg_taInfo[sNomTableUnique].m_sNomOriginal
      	SI PAS TableExiste(sNomTable) ALORS m_pclErreur.AjouteErreur(ChaîneConstruit(<§$000c§>,sNomTable));renvoyer faux
      
      	SI (cApplication.mg_taInfo[sNomTableUnique].p_eColonnesChargées=cTable.TableDétailCompletChargé _OU_ (PAS bDescriptionComplète _ET_ cApplication.mg_taInfo[sNomTableUnique].p_eColonnesChargées=cTable.TableDétailBasiqueChargé)) _ET_ PAS bForceRechargement ALORS RENVOYER PAS cApplication.mg_taInfo[sNomTableUnique].p_eColonnesChargées=cTable.TableDétailNonChargé
      	SI bForceRechargement ALORS cApplication.mg_taInfo[sNomTableUnique].p_eColonnesChargées=cTable.TableDétailNonChargé
      	cApplication.mg_taInfo[sNomTableUnique].p_eColonnesChargées=(bDescriptionComplète ? cTable.TableDétailCompletChargé SINON cTable.TableDétailBasiqueChargé)
      	SI cApplication._Application<>Null _ET_ cApplication._Application.m_pclTrace<>Null ALORS cApplication._Application.m_pclTrace.AjouteMéthode(sNomTableUnique,bDescriptionComplète,bForceRechargement)
      sinon
      	sTables est une chaine = tables()
      	sTablesACharger est une chaine
      	sNomTable=remplace(sNomTableUnique,[rc,",",";"],tab)	//on remplace tout séparateur pour être un tab standard	
      	pour tout chaine sTable de sNomTable
      		sNomTableUnique = cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].sNomUnique+cGénérique._Sep+Minuscule(sTable)	//refaire la variable au cas où on envoie plusieurs tables dans cette méthode
      		si cApplication.mg_taInfo[sNomTableUnique]=Null alors 
      			pclTable est un cTable dynamique = allouer un ctable(m_nIndiceDeConnexion,sTable,*,*,*,faux)
      			cApplication.mg_taInfo[sNomTableUnique] = pclTable
      		FIN
      		SI (cApplication.mg_taInfo[sNomTableUnique].p_eColonnesChargées=cTable.TableDétailCompletChargé _OU_ (PAS bDescriptionComplète _ET_ cApplication.mg_taInfo[sNomTableUnique].p_eColonnesChargées=cTable.TableDétailBasiqueChargé)) _ET_ PAS bForceRechargement ALORS
      			//la table est déjà chargée comme on l'a demandé
      		sinon			
      			SI bForceRechargement ALORS cApplication.mg_taInfo[sNomTableUnique].p_eColonnesChargées=cTable.TableDétailNonChargé
      			cApplication.mg_taInfo[sNomTableUnique].p_eColonnesChargées=(bDescriptionComplète ? cTable.TableDétailCompletChargé SINON cTable.TableDétailBasiqueChargé)
      			si position(sTables,sTable,0,MotComplet+SansCasse)<1 alors m_pclErreur.AjouteErreur(ChaîneConstruit(<§$000c§>,sTable)) sinon sTablesACharger+=[tab]+sTable
      		FIN
      	FIN
      	si p_Serreur>"" alors 
      		renvoyer faux 
      	sinon si sTablesACharger>"" alors
      		sNomTable=Remplace(sTablesACharger,tab,"','")	//ainsi prêt pour le IN plus bas
      		SI cApplication._Application<>Null _ET_ cApplication._Application.m_pclTrace<>Null ALORS cApplication._Application.m_pclTrace.AjouteMéthode(sTablesACharger,bDescriptionComplète,bForceRechargement)
      	sinon
      		//rien à charger
      		RENVOYER PAS cApplication.mg_taInfo[sNomTableUnique].p_eColonnesChargées=cTable.TableDétailNonChargé
      	FIN
      fin
      
      pclUneColonne	est un ccolonne dynamique
      
      sReqColonnes est une chaine = [
      SELECT 
      	MAX(table2) AS TABLE,
      	MAX(name) AS COLUMN_NAME,
      	MAX(NUMBER) AS ORDINAL_POSITION,
      	bool_and(not notnull2) as IS_NULLABLE,
      	STRING_AGG(DISTINCT type_udt, ',') AS DATA_TYPE,
      	bool_and(isPK) AS IsIdentity,
      	STRING_AGG(DISTINCT typecontrainte, ',') AS TypeContrainte,
      	MAX(numeric_precision) AS NUMERIC_SCALE,
      	MAX(maxcaractere) AS CHARACTER_MAXIMUM_LENGTH, 
      	STRING_AGG(DISTINCT column_default, ',') AS COLUMN_DEFAULT,
      	bool_and(is_Unique) AS is_Unique,
      	bool_and(is_fk) AS is_fk ,
      	STRING_AGG(DISTINCT nomcontrainte, ',') AS nomcontrainte,
      	STRING_AGG(DISTINCT domaine, ',') AS domaine, 
      	MAX(numeric_scale) AS numeric_scale,
      	STRING_AGG(DISTINCT generator, ',') AS generator,
      	bool_and(is_autoinc) as is_autoinc 
      FROM (
      	SELECT  
      		c.oid, 
      		CASE 
      			WHEN  p.contype ='p' THEN true ELSE false
      			END AS isPK ,   
      		CASE 
      			WHEN p.contype IN ('u','p') THEN true ELSE false
      			END AS is_Unique,
      		CASE 
      			WHEN p.contype ='f' THEN true ELSE false
      			END AS is_fk,
      		n.nspname AS namespace,
      		c.relname  AS table2,
      		CAST(i.dtd_identifier AS int) AS NUMBER,
      		f.attname AS name,  
      		f.attnotnull AS notnull2,  
      		CAST(p.contype AS CHAR) AS typecontrainte ,
      		p.conname AS nomcontrainte,
      		i.udt_name type_udt,   -- vrai type 
      		i.domain_name AS domaine,  
      		i.character_maximum_length AS maxcaractere,
      		i.numeric_precision,
      		i.numeric_scale,
      		i.column_default,
      		CASE 
      			WHEN POSITION( 'nextval' IN i.column_default) > 0 THEN SUBSTR(i.column_default,POSITION('''' IN i.column_default)+1,POSITION('''' IN SUBSTR(i.column_default,POSITION('''' IN i.column_default)+1))-1) 
      			END AS generator,
      		CASE
      			WHEN (POSITION( 'nextval' in i.column_default) > 0 and p.contype ='p') then TRUE
      			END AS is_autoinc	  
      	FROM 
      		pg_attribute f  
      	JOIN pg_class c 
      		ON c.oid 			= f.attrelid  
      	JOIN pg_type t 
      		ON t.oid			= f.atttypid  
      	LEFT JOIN pg_attrdef d 
      		ON d.adrelid		= c.oid AND d.adnum = f.attnum  
      	LEFT JOIN pg_namespace n 
      		ON n.oid			= c.relnamespace  
      	LEFT JOIN pg_constraint p 
      		ON p.conrelid		= c.oid AND f.attnum = ANY (p.conkey)  
      	LEFT JOIN pg_class g 
      		ON p.confrelid		= g.oid
      	LEFT JOIN INFORMATION_SCHEMA.columns i 
      		ON i.table_schema	= n.nspname AND  i.table_name = c.relname AND I.COLUMN_NAME = f.attname
      	WHERE 
      		c.relkind = 'r'::CHAR  
      		AND c.relname IN ('%1')
      		AND n.nspname = '%2'
      		AND i.dtd_identifier IS NOT NULL
      		AND f.attnum > 0 
      	ORDER BY 
      		namespace, c.relname,NUMBER
      	) AS x
      	GROUP BY 
      		(x.namespace,x.table2,x.NUMBER)
      ]
      
      clSQLLocal est un csql(m_nIndiceDeConnexion)
      
      SI clSQLLocal.Requête(ChaîneConstruit(sReqColonnes,sNomTable,cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].sSchémaOuDC)) ALORS
      	POUR TOUT clSQLLocal.m_sd
      		SI bDescriptionComplète ALORS
      			TraiteColonne(clSQLLocal.m_sd.TABLE,clSQLLocal.m_sd.COLUMN_NAME,clSQLLocal.m_sd.ORDINAL_POSITION,(clSQLLocal.m_sd.IS_NULLABLE="YES"),
      			clSQLLocal.m_sd.DATA_TYPE,clSQLLocal.m_sd.IsIdentity,clSQLLocal.m_sd.TypeContrainte=PrimaryKey..Valeur,clSQLLocal.m_sd.generator,clSQLLocal.m_sd.NUMERIC_SCALE,
      			clSQLLocal.m_sd.CHARACTER_MAXIMUM_LENGTH,clSQLLocal.m_sd.COLUMN_DEFAULT)	//trouver la formule le cas échéant
      		SINON
      			TraiteColonne(clSQLLocal.m_sd.TABLE,clSQLLocal.m_sd.COLUMN_NAME,clSQLLocal.m_sd.ORDINAL_POSITION,(clSQLLocal.m_sd.IS_NULLABLE="YES"),
      			clSQLLocal.m_sd.DATA_TYPE,clSQLLocal.m_sd.IsIdentity,clSQLLocal.m_sd.TypeContrainte=PrimaryKey..Valeur,clSQLLocal.m_sd.generator)
      		FIN
      	FIN
      SINON
      	m_pclErreur.AjouteErreur(clSQLLocal.p_sErreur);RENVOYER Faux
      FIN
      
      SI capplication.mg_taInfo[sNomTableUnique].p_sToutesLesColonnes="" ALORS m_pclErreur.AjouteAvertissement(<§$000d§>)
      RENVOYER Vrai
      
      	PROCÉDURE INTERNE TraiteColonne(sTable est une chaine,sNomColonne est une chaine,nPosition est un entier,bNullable est un booleen,sType est une chaine,bEstIdentity est un booleen=faux,bCléPrimaire est un booleen=faux,sFormuleCalcule est une chaine="",nTailleDécimale est un entier=0,nTaille est un entier=0,sDéfaut est une chaine="")
      	sColonneMinus 	est une chaine = Minuscule(sNomColonne)
      	nType 			sont des entiers
      	bEstUnicode 	est un booleen
      	(nType,nTaille,bEstUnicode)=TypeVersWD(sType,nTailleDécimale,bEstIdentity)
      	
      	SI nType>0 ALORS 
      		sNomTableUnique = cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].sNomUnique+cGénérique._Sep+minuscule(sTable)	//refaire la variable au cas où on envoie plusieurs tables dans cette méthode
      		SI bEstIdentity ALORS capplication.mg_taInfo[sNomTableUnique].p_sColonneAutomatique=sColonneMinus	//ne peux en avoir qu'une
      		pclUneColonne = allouer un cColonne(clObjetBD,sNomTableUnique,sNomColonne,nPosition,nType,sType,nTaille,bNullable,sFormuleCalcule,Faux,0,"",sDéfaut)
      		cApplication.mg_taInfo[sNomTableUnique].p_tabColonnes=pclUneColonne
      	FIN
      	FIN
     type : 458752
   -
     name : TableIndexes
     procedure_id : 2295174160360073003
     type_code : 12
     code : |1+
      // Résumé : Charge les index d'une table passée en paramètre.
      // Syntaxe : [ <Résultat> = ] TableIndexes (<sNomTableUnique> est chaîne)
      // Paramètres :
      //	sNomTableUnique (chaîne UNICODE) : Le nom unique de la table pour laquelle les informations sur les index doivent être récupérées.
      // Valeur de retour : booleen : Vrai si les informations de la table ont été mémorisées dans cApplication.mg_taInfo[sNomTableUnique].p_tabIndexes, Faux en cas d'erreur.
      // Exemple :
      //
      PROCEDURE TableIndexes(LOCAL sNomTableUnique est une chaine,bDescriptionComplète est un booleen = faux,bForceRechargement est un booleen = faux) : booleen
      m_pclErreur.Raz()
      
      SI PAS cBaseDeDonnées.ConnexionActive(m_nIndiceDeConnexion) ALORS m_pclErreur.AjouteErreur(<§$0007§>);renvoyer faux
      sNomTable est une chaine 
      
      SI Position(sNomTableUnique,cGénérique._Sep)>0 ALORS
      	sNomTable = cApplication.mg_taInfo[sNomTableUnique].m_sNomOriginal
      	SI PAS TableExiste(sNomTable) ALORS m_pclErreur.AjouteErreur(ChaîneConstruit(<§$000c§>,sNomTable));renvoyer faux
      	
      	SI (cApplication.mg_taInfo[sNomTableUnique].p_eIndexesChargées=cTable.TableDétailCompletChargé _OU_ (PAS bDescriptionComplète _ET_ cApplication.mg_taInfo[sNomTableUnique].p_eIndexesChargées=cTable.TableDétailBasiqueChargé)) _ET_ PAS bForceRechargement ALORS RENVOYER PAS cApplication.mg_taInfo[sNomTableUnique].p_eIndexesChargées=cTable.TableDétailNonChargé
      	SI bForceRechargement ALORS cApplication.mg_taInfo[sNomTableUnique].p_eIndexesChargées=cTable.TableDétailNonChargé
      	cApplication.mg_taInfo[sNomTableUnique].p_eIndexesChargées=(bDescriptionComplète ? cTable.TableDétailCompletChargé SINON cTable.TableDétailBasiqueChargé)
      	SI cApplication._Application<>Null _ET_ cApplication._Application.m_pclTrace<>Null ALORS cApplication._Application.m_pclTrace.AjouteMéthode(sNomTableUnique,bDescriptionComplète,bForceRechargement)
      sinon
      	sTables est une chaine = tables()
      	sTablesACharger est une chaine
      	sNomTable=Remplace(sNomTableUnique,[RC," ",","],TAB)	//on remplace tout séparateur pour être un tab standard	
      	POUR TOUT CHAÎNE sTable de sNomTable
      		sNomTableUnique = cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].sNomUnique+cGénérique._Sep+Minuscule(sTable)	//refaire la variable au cas où on envoie plusieurs tables dans cette méthode
      		SI (cApplication.mg_taInfo[sNomTableUnique].p_eIndexesChargées=cTable.TableDétailCompletChargé _OU_ (PAS bDescriptionComplète _ET_ cApplication.mg_taInfo[sNomTableUnique].p_eIndexesChargées=cTable.TableDétailBasiqueChargé)) _ET_ PAS bForceRechargement ALORS
      			//la table est déjà chargée comme on l'a demandé
      		SINON			
      			SI bForceRechargement ALORS cApplication.mg_taInfo[sNomTableUnique].p_eIndexesChargées=cTable.TableDétailNonChargé
      			cApplication.mg_taInfo[sNomTableUnique].p_eIndexesChargées=(bDescriptionComplète ? cTable.TableDétailCompletChargé SINON cTable.TableDétailBasiqueChargé)
      			SI Position(sTables,sTable,0,MotComplet+SansCasse)<1 ALORS m_pclErreur.AjouteErreur(ChaîneConstruit(<§$000c§>,sTable)) sinon sTablesACharger+=[tab]+sTable
      		FIN
      	FIN
      	SI p_sErreur>"" ALORS 
      		RENVOYER Faux 
      	SINON SI sTablesACharger>"" ALORS
      		sNomTable=Remplace(sTablesACharger,TAB,"','")	//ainsi prêt pour le IN plus bas
      		SI cApplication._Application<>Null _ET_ cApplication._Application.m_pclTrace<>Null ALORS cApplication._Application.m_pclTrace.AjouteMéthode(sTablesACharger,bDescriptionComplète,bForceRechargement)
      	SINON
      		//rien à charger
      		RENVOYER PAS cApplication.mg_taInfo[sNomTableUnique].p_eIndexesChargées=cTable.TableDétailNonChargé
      	FIN
      fin
      
      sReqIndexes est une chaine = [
      SELECT 
      	p.conname as IndexName,
      	p.conindid as IndexId,
      	f.attnum AS ColumnId, 
      	f.attname AS ColumnName,  
      	0 as is_descending_key,
      	CASE 
      		WHEN p.contype in ('u','p') THEN True ELSE False
      		END AS is_Unique,
      	CASE 
      		WHEN p.contype = 'p' THEN True ELSE False
      		END AS is_pk,
      	c.relname as table,
      	p.contype as typecontrainte, 
      	CASE 
      		WHEN POSITION( 'nextval' in i.column_default) > 0 then substr(i.column_default,POSITION('''' in i.column_default)+1,POSITION('''' in substr(i.column_default,position('''' in i.column_default)+1))-1) 
      		END AS generator,
      	c.oid, 
      	n.nspname as namespace,
      	f.attnotnull AS notnull,  
      	i.udt_name type_udt,   -- vrai type 
      	i.domain_name as domaine,  
      	i.character_maximum_length as maxcaractere,
      	i.numeric_precision,
      	i.numeric_scale,
      	i.column_default
      	FROM 
      		pg_attribute f  
      	JOIN pg_class c 
      		ON c.oid = f.attrelid  
      	JOIN pg_type t 	
      		ON t.oid = f.atttypid  
      	LEFT JOIN pg_attrdef d 
      		ON d.adrelid = c.oid AND d.adnum = f.attnum  
      	LEFT JOIN pg_namespace n 
      		ON n.oid = c.relnamespace  
      	LEFT JOIN pg_constraint p 
      		ON p.conrelid = c.oid AND f.attnum = ANY (p.conkey)  
      	LEFT JOIN pg_class AS g 
      		ON p.confrelid = g.oid
      	LEFT JOIN INFORMATION_SCHEMA.columns i 
      		ON i.table_schema = n.nspname AND  i.table_name = c.relname AND I.COLUMN_NAME = f.attname
      	WHERE 
      		c.relkind = 'r'::char  
      		AND n.nspname = '%2'  -- Replace with Schema name  
      		AND c.relname IN ('%1')  -- Replace with table name  
      		AND p.contype is not null  
      		AND f.attnum > 0 
      	ORDER BY 
      		namespace,  p.conname,c.relname,ColumnId 
      ]
      
      clSQLLocal 	est un csql(m_nIndiceDeConnexion)
      SI clSQLLocal.Requête(ChaîneConstruit(sReqIndexes,sNomTable,cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].sSchémaOuDC)) ALORS
      	POUR TOUT clSQLLocal.m_sd
      		SI bDescriptionComplète ALORS
      			TraiteClé(clSQLLocal.m_sd.TABLE,clSQLLocal.m_sd.IndexName,clSQLLocal.m_sd.ColumnName,clSQLLocal.m_sd.is_Unique,clSQLLocal.m_sd.is_descending_key)
      		SINON
      			TraiteClé(clSQLLocal.m_sd.TABLE,clSQLLocal.m_sd.IndexName,clSQLLocal.m_sd.ColumnName,clSQLLocal.m_sd.is_Unique)
      		FIN
      	FIN
      	
      	pour toute chaine sTable de sNomTable separee par "','"
      		sNomTableUnique = cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].sNomUnique+cGénérique._Sep+Minuscule(sTable)	//refaire la variable au cas où on envoie plusieurs tables dans cette méthode
      		//trouver la clé unique si pas de clé primaire
      		SI cApplication.mg_taInfo[sNomTableUnique].p_sCléPrimaire="" ALORS
      			POUR TOUT pclUneClé de cApplication.mg_taInfo[sNomTableUnique].p_tabIndexes
      				SI pclUneClé.m_bEstAutomatique ALORS 
      					cApplication.mg_taInfo[sNomTableUnique].p_sCléPrimaire			= pclUneClé.m_sNom
      					cApplication.mg_taInfo[sNomTableUnique].p_sColonnesCléPrimaire	= pclUneClé.p_sComposantes
      					SORTIR
      				FIN
      			FIN
      		FIN
      		SI cApplication.mg_taInfo[sNomTableUnique].p_sCléPrimaire=""
      			POUR TOUT pclUneClé de cApplication.mg_taInfo[sNomTableUnique].p_tabIndexes
      				SI pclUneClé.m_bEstunique ALORS 
      					cApplication.mg_taInfo[sNomTableUnique].p_sCléPrimaire			= pclUneClé.m_snom
      					cApplication.mg_taInfo[sNomTableUnique].p_sColonnesCléPrimaire	= pclUneClé.p_sComposantes
      					SORTIR
      				FIN
      			FIN
      		FIN
      	fin
      	RENVOYER Vrai
      SINON
      	m_pclErreur.AjouteErreur(clSQLLocal.p_sErreur);RENVOYER Faux
      FIN
      
      	PROCÉDURE INTERNE TraiteClé(sTable est une chaine,sNomIndex est une chaine,sNomColonneClé est une chaine,bEstUnique est un booleen,bEstDescendant est un booleen = faux)
      	sNomIndexMinus 	est une chaine = minuscule(sNomIndex)
      	sNomTableUnique = cBaseDeDonnées.mg_tabConnexion[m_nIndiceDeConnexion].sNomUnique+cGénérique._Sep+Minuscule(sTable)	//refaire la variable au cas où on envoie plusieurs tables dans cette méthode
      	nIndice 		est un entier = tableaucherche(cApplication.mg_taInfo[sNomTableUnique].p_tabIndexes,tcLinéaire,"m_sNom",sNomIndexMinus)
      	SI nIndice<1 ALORS 
      		pclUneClé 	est un cIndex dynamique = allouer un cIndex(m_nIndiceDeConnexion,sNomTableUnique,sNomIndex,bEstUnique,vrai) 
      		nIndice=TableauAjoute(cApplication.mg_taInfo[sNomTableUnique].p_tabIndexes,pclUneClé)
      	FIN
      	cApplication.mg_taInfo[sNomTableUnique].p_tabIndexes[nIndice].ComposanteAjoute(Minuscule(sNomColonneClé),PAS bEstDescendant)
      	FIN
     type : 458752
   -
     name : TypeVersWD
     procedure_id : 2295174327863836672
     type_code : 12
     code : |1-
      // Résumé : Convertit un type de données de base de données vers son équivalent dans l'environnement WinDev
      // Syntaxe : [ <Résultat> = ] TypeVersWD (<sType> est chaîne, <nTailleDécimale> est entier, <bEstCléPrimaire> est booléen)
      // Paramètres :
      //	sType (chaîne UNICODE) : Le type de données de base de données à convertir.
      //	nTailleDécimale (entier) : Nombre de décimales pour un numérique (pas utilisé)
      //	bEstCléPrimaire (booléen) : Un indicateur pour spécifier la colonne est une clé primaire.
      // Valeur de retour : entier : Représente le type de données équivalent dans l'environnement WinDev.
      // Exemple :
      //
      PROCEDURE TypeVersWD(sType est une chaine,nTailleDécimale est un entier,bEstCléPrimaire est un booleen)
      nType,nTaille 	sont des entiers
      bEstUnicode 	est un booleen
      
      SELON sType
      	CAS "bit","bit varying","box","cidr","line"	: //pas d'équivalent Windev
      	CAS "circle","inet","interval","lseg"		: //pas d'équivalent Windev
      	CAS "macaddr","timetz","timestamptz"		: //pas d'équivalent Windev
      	CAS "bigserial","serial8"					: nType = hRubIdAuto;nTaille=8
      	CAS "money"									: nType = hRubMonétaire
      	CAS "bytea"									: nType = hRubMémoBinaire;nTaille=8
      	CAS "int2","smallint"						: nType = hRubEntier2;nTaille=2
      	CAS "bool","boolean"						: nType = hRubBooléen;nTaille=1
      	CAS "varbit"								: nType = hRubBinaire
      	CAS "int","int4","integer"					: nType = (bEstCléPrimaire ? hRubIdAuto4 SINON hRubEntier4);nTaille=4
      	CAS "int8","bigint"							: nType = (bEstCléPrimaire ? hRubIdAuto SINON hRubEntier8);nTaille=8
      	CAS "character" 							: nType = hRubCaractère
      	CAS "varchar","character varying","text"	: nType = hRubMémoTexte;nTaille=8
      	CAS "int unsigned"							: nType = hRubEntierNonSigné4
      	CAS "date"									: nType = hRubDate8;nTaille=8
      	CAS "timestamp"								: nType = hRubDateHeure
      	CAS "time"									: nType = hRubHeure;nTaille=9	//HHMMSSCCC = 9
      	CAS "numeric","decimal"						: nType = hRubNumérique
      	CAS "real","float4"							: nType = hRubRéel4;nTaille=4
      	CAS "float8","double precision"				: nType = hRubRéel8;nTaille=8
      	CAS "serial","serial4"						: nType = hRubIdAuto4
      	AUTRES CAS 									: m_pclErreur.AjouteErreur(ChaîneConstruit("Le type %1 n'est pas géré",sType));dbgAssertion(Faux,ChaîneConstruit("Le type %1 n'est pas géré",sType)) 
      FIN
      RENVOYER (nType,nTaille,bEstUnicode)
     type : 458752
   -
     name : BooléenVersSQL
     procedure_id : 2301528422536531734
     type_code : 12
     group : 2
     code : |1-
      // Résumé : Transforme un booléen dans le format SQL.
      // Syntaxe : [ <Résultat> = ] BooléenVersSQL (<xDateHeure>)
      // Paramètres : 
      // 	nValeur : Valeur booléenne à transformer en SQL.
      // Valeur de retour : chaîne UNICODE : Renvoie une chaîne un booléen au format SQL.
      // Exemple :
      //
      //
      PROCEDURE BooléenVersSQL(xValeur) : chaine
      renvoyer (xValeur="1" ? "True" sinon "False")
     type : 458752
   -
     name : SQLBinaireEcrit
     procedure_id : 2301561292019536955
     type_code : 12
     group : 3
     code : |1-
      // Résumé : Transforme une valeur hexadécimale en binaire dans le format SQL.
      // Syntaxe : [ <Résultat> = ] SQLBinaireÉcrit (<xValeur>)
      // Paramètres :
      // 	xValeur : Valeur à transformer en notation binaire
      // Valeur de retour : chaîne UNICODE : Renvoie la valeur transformée en notation binaire.
      // Exemple :
      //
      PROCEDURE SQLBinaireEcrit(sValeur est une chaine) : chaine
      renvoyer "decode('"+sValeur+"','hex')"
     type : 458752
   -
     name : Connecte_
     procedure_id : 2301568099558310617
     type_code : 12
     code : |1-
      // Résumé : Même fonction que Connecte() mais en passant en paramètre le nom de la section des paramètres de l'application (pour spécifier une valeur autre que "Postgres")
      // Syntaxe : [ <Résultat> = ] Connecte_ ( [<sSectionParamètres> est chaîne])
      // Paramètres :
      // 	sSectionParamètres (chaîne UNICODE) : Nom de la section des paramètres de l'application dans laquelle aller récupérer les autres paramètres de connexion, par défaut="Postgres".
      // Valeur de retour : entier : L'indice de la connexion si elle est établie.
      // Exemple :
      //
      PROCEDURE Connecte_(sSectionParamètres est une chaîne = "Postgres") : entier	
      RENVOYER Connecte(EnumérationDepuisNom(cBaseDeDonnées.ETypeAccès,cApplication._Application.m_pclParamètres.Lit(sSectionParamètres,"Access",Faux,"RequêteSQL")),	//ETypeAccès.RequêteSQL..Nom affiche une erreur en Android et Java
      	cApplication._Application.m_pclParamètres.Lit(sSectionParamètres,"Address")+[":"]+cApplication._Application.m_pclParamètres.Lit(sSectionParamètres,"Port"),
      	cApplication._Application.m_pclParamètres.Lit(sSectionParamètres,"User"),
      	cApplication._Application.m_pclParamètres.Lit(sSectionParamètres,"Password",Vrai),
      	cApplication._Application.m_pclParamètres.Lit(sSectionParamètres,"DB"),
      	cApplication._Application.m_pclParamètres.Lit(sSectionParamètres,"Schema"),
      	cApplication._Application.m_pclParamètres.Lit(sSectionParamètres,"Group",Faux,"*"),
      	cApplication._Application.m_pclParamètres.Lit(sSectionParamètres,"PathMemos"),
      	cApplication._Application.m_pclParamètres.Lit(sSectionParamètres,"CacheMemos",Faux,cApplication._Application.p_sRépertoireCacheMémo))
     type : 458752
   -
     name : SQLBinaireLit32
     procedure_id : 2301593594500011556
     type_code : 12
     group : 3
     code : |1-
      // Résumé : Renvoie le code SQL pour récupérer les 32 premiers bits d'un binaire (son hash)
      // Syntaxe : [ <Résultat> = ] SQLBinaireLit32 (<sNomColonne> est chaîne [, <bEstBinaireImage> est booléen])
      // Paramètres :
      //	sNomColonne (chaîne UNICODE) : Nom de la colonne depuis laquelle les 32 premiers bits seront récupérés.
      // 	bEstBinaireImage (booléen optionnel) : n'est pas utilisé ici
      // Exemple :
      //
      PROCEDURE SQLBinaireLit32(LOCAL sNomColonne est une chaine,bEstBinaireImage est un booleen = faux) : chaine
      RENVOYER "substring("+sNomColonne+",1,32)"
     type : 458752
   -
     name : SQLImageVersBinaire
     procedure_id : 2301593770593711799
     type_code : 12
     group : 3
     code : |1-
      // Résumé : Renvoie le code SQL pour convertir une image en chaine hexa (utilisant les caractères de 0 à F).
      // Syntaxe : [ <Résultat> = ] SQLImageVersBinaire (<sNomColonne> est chaîne)
      // Paramètres :
      //	sNomColonne (chaîne UNICODE) : Nom de la colonne dont on souhaite appliquer la conversion en binaire.
      // Valeur de retour : chaîne UNICODE : Résultat de la conversion en binaire de l'image.
      // Exemple :
      //
      PROCEDURE SQLImageVersBinaire(sNomColonne est une chaine) : chaine
      RENVOYER sNomColonne
     type : 458752
   -
     name : SQLTableAvantColonne
     procedure_id : 1156819336829375279
     type_code : 12
     group : 3
     code : |1-
      // Résumé : Indique si il faut ajouter le nom de la table devant le nom de la colonne lors d'une requête SQL.
      // Syntaxe : [ <Résultat> = ] SQLTableAvantColonne ()
      // Paramètres : Aucun
      // Valeur de retour : booléen : Vrai s'il faut ajouter le nom de la table devant le nom de la colonne, Faux sinon.
      // Exemple :
      //
      PROCEDURE SQLTableAvantColonne() : booleen
      renvoyer faux
     type : 458752
   -
     name : ODBCChemin
     procedure_id : 1222450600246124913
     type_code : 12
     code : |1-
      // Résumé : Retourne le chemin complet du répertoire contenant le driver ODBC Oracle. Elle recherche le driver Oracle dans les répertoires spécifiés par la variable d'environnement PATH de Windows.
      // Syntaxe : [ <Résultat> = ] ODBCChemin ()
      // Paramètres :	Aucun
      // Valeur de retour : chaîne UNICODE : Une chaîne représentant le chemin complet du répertoire contenant le driver ODBC Oracle. Si le driver est trouvé dans le PATH, la fonction renvoie le chemin complet du répertoire. Sinon, elle renvoie une chaîne vide.
      // Exemple :
      //
      PROCEDURE PUBLIQUE GLOBALE ODBCChemin() : chaine
      sODBC est une chaine = SysRep(srSystème)+["\"]+"psqlodbc.dll"
      si fFichierExiste(sODBC) alors renvoyer sODBC
      renvoyer ""
     type : 458752
   -
     name : ODBCInstalle
     procedure_id : 1222451064102700990
     type_code : 12
     code : |1+
      // Résumé : Installe une connexion ODBC dans Windows pour une base de données Oracle. Elle prend en charge différents types de drivers, notamment les drivers Microsoft et Oracle.
      // Syntaxe : [ <Résultat> = ] ODBCInstalle (<sServeurPort> est chaîne, <sBaseDeDonnées> est chaîne, <vParamètres> est variant)
      // Paramètres :
      //	sServeurPort (chaîne UNICODE) : Le nom du serveur et le port à utiliser pour la connexion ODBC.
      //	sBaseDeDonnées (chaîne UNICODE) : Le nom de la base de données Oracle.
      //	vParamètres (variant) : Les paramètres de connexion, notamment le driver, le nom d'utilisateur, le mot de passe, etc.
      // Valeur de retour : booléen : Indiquant si l'installation de la connexion ODBC a réussi (Vrai) ou échoué (Faux).
      // Exemple :
      //
      PROCEDURE ODBCInstalle(sServeurPort est une chaîne,sBaseDeDonnées est une chaîne,vParamètres est un variant) : booleen
      
      SI sServeurPort~="" ALORS ErreurDéclenche(ErreurODBC,<§@1bdafbc821abb0ce0006§>);renvoyer faux
      SI sBaseDeDonnées~="" ALORS ErreurDéclenche(ErreurODBC,<§$0010§>);renvoyer faux
      SI vParamètres=Null 	ALORS ErreurDéclenche(ErreurODBC,<§$0011§>);renvoyer faux
      
      vParamètres.Driver = ODBCChemin()
      SI vParamètres.Driver=Null ALORS ErreurDéclenche(ErreurODBC,<§@1bdafbc821abb0ce0005§>);renvoyer faux
      
      sConnexionODBC est une chaîne
      sConnexionODBC = ODBCRechercheParMembre("Server"+TAB+"Database",sServeurPort,sBaseDeDonnées)
      SI PAS sConnexionODBC="" ALORS RENVOYER Vrai sinon sConnexionODBC = sServeurPort+"-"+sBaseDeDonnées
      
      sClé 		est une chaîne = ODBCRegistreChemin+"\"+gauche(sConnexionODBC,32)		//32 est la limite du nombre de caractères de la source ODBC
      
      SI RegistreExiste(sClé) ALORS ErreurDéclenche(ErreurODBC,<§@1bdafbc821abb0ce0003§>);rENVOYER faux
      SI vParamètres.Servername=Null OU vParamètres.Servername~="" ALORS vParamètres.Servername=sServeurPort
      
      SI PAS RegistreCréeClé(sClé) _ET_ ErreurDétectée() ALORS ErreurClé(sClé);RENVOYER Faux
      SI PAS RegistreEcrit(sClé,"BI",(vParamètres.BI=Null ? "0" SINON vParamètres.BI)) ALORS ErreurClé(sClé);RENVOYER Faux
      SI PAS RegistreEcrit(sClé,"BoolsAsChar",(vParamètres.BoolsAsChar=Null ? "1" SINON vParamètres.BoolsAsChar)) ALORS ErreurClé(sClé);RENVOYER Faux
      SI PAS RegistreEcrit(sClé,"CancelAsFreeStmt",(vParamètres.CancelAsFreeStmt=Null ? "0" SINON vParamètres.CancelAsFreeStmt)) ALORS ErreurClé(sClé);RENVOYER Faux
      SI PAS RegistreEcrit(sClé,"CommLog",(vParamètres.CommLog=Null ? "0" SINON vParamètres.CommLog)) ALORS ErreurClé(sClé);RENVOYER Faux
      SI PAS RegistreEcrit(sClé,"ConnSettings",(vParamètres.ConnSettings=Null ? "set+datestyle+to+%27iso%2ceuropean%27" SINON vParamètres.ConnSettings)) ALORS ErreurClé(sClé);RENVOYER Faux
      SI PAS RegistreEcrit(sClé,"Database",(vParamètres.Database=Null ? "ada" SINON vParamètres.Database)) ALORS ErreurClé(sClé);RENVOYER Faux
      SI PAS RegistreEcrit(sClé,"Debug",(vParamètres.Debug=Null ? "0" SINON vParamètres.Debug)) ALORS ErreurClé(sClé);RENVOYER Faux
      SI PAS RegistreEcrit(sClé,"Description",(vParamètres.sDescription=Null ? "" SINON vParamètres.sDescription)) ALORS ErreurClé(sClé);RENVOYER Faux
      SI PAS RegistreEcrit(sClé,"DisallowPremature",(vParamètres.DisallowPremature=Null ? "0" SINON vParamètres.DisallowPremature)) ALORS ErreurClé(sClé);RENVOYER Faux
      SI PAS RegistreEcrit(sClé,"Driver",vParamètres.Driver) ALORS ErreurClé(sClé);RENVOYER Faux
      SI PAS RegistreEcrit(sClé,"ExtraSysTablePrefixes",(vParamètres.ExtraSysTablePrefixes=Null ? "dd_;" SINON vParamètres.ExtraSysTablePrefixes)) ALORS ErreurClé(sClé);RENVOYER Faux
      SI PAS RegistreEcrit(sClé,"FakeOidIndex",(vParamètres.FakeOidIndex=Null ? "0" SINON vParamètres.FakeOidIndex)) ALORS ErreurClé(sClé);RENVOYER Faux
      SI PAS RegistreEcrit(sClé,"Fetch",(vParamètres.Fetch=Null ? "100" SINON vParamètres.Fetch)) ALORS ErreurClé(sClé);RENVOYER Faux
      SI PAS RegistreEcrit(sClé,"Ksqo",(vParamètres.Ksqo=Null ? "1" SINON vParamètres.Ksqo)) ALORS ErreurClé(sClé);RENVOYER Faux
      SI PAS RegistreEcrit(sClé,"LFConversion",(vParamètres.LFConversion=Null ? "1" SINON vParamètres.LFConversion)) ALORS ErreurClé(sClé);RENVOYER Faux
      SI PAS RegistreEcrit(sClé,"MaxLongVarcharSize",(vParamètres.MaxLongVarcharSize=Null ? "8190" SINON vParamètres.MaxLongVarcharSize)) ALORS ErreurClé(sClé);RENVOYER Faux
      SI PAS RegistreEcrit(sClé,"MaxVarcharSize",(vParamètres.MaxVarcharSize=Null ? "254" SINON vParamètres.MaxVarcharSize)) ALORS ErreurClé(sClé);RENVOYER Faux
      SI PAS RegistreEcrit(sClé,"Optimizer",(vParamètres.Optimizer=Null ? "1" SINON vParamètres.Optimizer)) ALORS ErreurClé(sClé);RENVOYER Faux
      SI PAS RegistreEcrit(sClé,"Parse",(vParamètres.Parse=Null ? "0" SINON vParamètres.Parse)) ALORS ErreurClé(sClé);RENVOYER Faux
      SI PAS RegistreEcrit(sClé,"Password",(vParamètres.Password=Null ? "" SINON vParamètres.Password)) ALORS ErreurClé(sClé);RENVOYER Faux
      SI PAS RegistreEcrit(sClé,"Port",(vParamètres.Port=Null ? "5432" SINON vParamètres.Port)) ALORS ErreurClé(sClé);RENVOYER Faux
      SI PAS RegistreEcrit(sClé,"Protocol",(vParamètres.Protocol=Null ? "6.4" SINON vParamètres.Protocol)) ALORS ErreurClé(sClé);RENVOYER Faux
      SI PAS RegistreEcrit(sClé,"ReadOnly",(vParamètres.ReadOnly=Null ? "0" SINON vParamètres.ReadOnly)) ALORS ErreurClé(sClé);RENVOYER Faux
      SI PAS RegistreEcrit(sClé,"RowVersioning",(vParamètres.RowVersioning=Null ? "0" SINON vParamètres.RowVersioning)) ALORS ErreurClé(sClé);RENVOYER Faux
      SI PAS RegistreEcrit(sClé,"Servername",vParamètres.Servername) ALORS ErreurClé(sClé);RENVOYER Faux
      SI PAS RegistreEcrit(sClé,"ShowOidColumn",(vParamètres.ShowOidColumn=Null ? "0" SINON vParamètres.ShowOidColumn)) ALORS ErreurClé(sClé);RENVOYER Faux
      SI PAS RegistreEcrit(sClé,"ShowSystemTables",(vParamètres.ShowSystemTables=Null ? "0" SINON vParamètres.ShowSystemTables)) ALORS ErreurClé(sClé);RENVOYER Faux
      SI PAS RegistreEcrit(sClé,"TextAsLongVarchar",(vParamètres.TextAsLongVarchar=Null ? "1" SINON vParamètres.TextAsLongVarchar)) ALORS ErreurClé(sClé);RENVOYER Faux
      SI PAS RegistreEcrit(sClé,"TrueIsMinus1",(vParamètres.TrueIsMinus1=Null ? "0" SINON vParamètres.TrueIsMinus1)) ALORS ErreurClé(sClé);RENVOYER Faux
      SI PAS RegistreEcrit(sClé,"UniqueIndex",(vParamètres.UniqueIndex=Null ? "1" SINON vParamètres.UniqueIndex)) ALORS ErreurClé(sClé);RENVOYER Faux
      SI PAS RegistreEcrit(sClé,"UnknownsAsLongVarchar",(vParamètres.UnknownsAsLongVarchar=Null ? "0" SINON vParamètres.UnknownsAsLongVarchar)) ALORS ErreurClé(sClé);RENVOYER Faux
      SI PAS RegistreEcrit(sClé,"UnknownSizes",(vParamètres.UnknownSizes=Null ? "0" SINON vParamètres.UnknownSizes)) ALORS ErreurClé(sClé);RENVOYER Faux
      SI PAS RegistreEcrit(sClé,"UpdatableCursors",(vParamètres.UpdatableCursors=Null ? "1" SINON vParamètres.UpdatableCursors)) ALORS ErreurClé(sClé);RENVOYER Faux
      SI PAS RegistreEcrit(sClé,"UseDeclareFetch",(vParamètres.UseDeclareFetch=Null ? "0" SINON vParamètres.UseDeclareFetch)) ALORS ErreurClé(sClé);RENVOYER Faux
      SI PAS RegistreEcrit(sClé,"Username",(vParamètres.Username=Null ? "" SINON vParamètres.Username)) ALORS ErreurClé(sClé);RENVOYER Faux
      
      SI PAS RegistreCréeClé(ODBCRegistreChemin+"\ODBC Data Sources") _ET_ ErreurDétectée() ALORS ErreurClé(sClé);RENVOYER Faux
      SI PAS RegistreEcrit(ODBCRegistreChemin+"\ODBC Data Sources",sConnexionODBC,"PostgreSQL Native client") ALORS ErreurClé(sClé);RENVOYER Faux
      
      RENVOYER Vrai
      
      	PROCÉDURE INTERNE ErreurClé(sLaClé)
      	ErreurDéclenche(ErreurODBC,<§@1bdafbc821abb0ce0000§>+sLaClé+" : "+erreurinfo(errmessage))
      	FIN
     type : 458752
  properties :
   -
     name : p_bEstConnecté
     identifier : 0x1c7e749e08b25600
     type_code : 103
     p_codes :
      -
        code : |1-
         // Résumé : Renvoie le statut de la connexion
         PROCEDURE PUBLIQUE p_bEstConnecté() : booleen
         RENVOYER m_nIndiceDeConnexion>0
        type : 1966080
     template_refs : []
  procedure_templates : []
  property_templates : []
 code_parameters :
  internal_properties : CQAAAAkAAACVGQgYbalU7DKC3oH4ItDrjtcTHXXV/EuH8q0IbhyQlw==
  original_name : Classe1
resources :
 string_res :
  identifier : 0x1c783afa5e702fbc
  internal_properties : CQAAAAkAAACm76HWfKGWp33VjXInA4cRlqArlgTTA862QGt72W2ld5Y=
  strings :
   -
     text :
      fr-FR : "Dernière connexion déconnectée :"
      en-GB : "Last connection disconnected :"
      fr-CA : "Dernière connexion déconnectée :"
      en-US : "Last connection disconnected :"
     index : 0
   -
     text :
      fr-FR : "Impossible de fermer la connexion aux données (%1 - %2) : "
      en-GB : "Unable to close data connection (%1 - %2) : "
      fr-CA : "Impossible de fermer la connexion aux données (%1 - %2) : "
      en-US : "Unable to close data connection (%1 - %2) : "
     index : 1
   -
     text :
      fr-FR : La base de données n'était pas connectée
      en-GB : The database was not connected
      fr-CA : La base de données n'était pas connectée
      en-US : The database was not connected
     index : 2
   -
     text :
      fr-FR : Le nom de la base de données est obligatoire
      en-GB : The name of the database is required
      fr-CA : Le nom de la base de données est obligatoire
      en-US : The name of the database is required
     index : 3
   -
     text :
      fr-FR : "Impossible d'ouvrir la connexion aux données (%1 - %2) : "
      en-GB : "Unable to open data connection (%1 - %2) : "
      fr-CA : "Impossible d'ouvrir la connexion aux données (%1 - %2) : "
      en-US : "Unable to open data connection (%1 - %2) : "
     index : 4
   -
     text :
      fr-FR : Le nom serveur est obligatoire
      en-GB : The name of the server is required
      fr-CA : Le nom serveur est obligatoire
      en-US : The name of the server is required
     index : 5
   -
     text :
      fr-FR : Le nom d'utilisateur est obligatoire
      en-GB : Username is required
      fr-CA : Le nom d'utilisateur est obligatoire
      en-US : Username is required
     index : 6
   -
     text :
      fr-FR : Aucune connexion
      en-GB : No connection
      fr-CA : Aucune connexion
      en-US : No connection
     index : 7
   -
     text :
      fr-FR : La version de Postgres Server est inconnue
      en-GB : The version of SQL Server is unknown
      fr-CA : La version de SQL Server est inconnue
      en-US : The version of SQL Server is unknown
     index : 8
   -
     text :
      fr-FR : DateHeure invalide
      en-GB : Invalid dateTime
      fr-CA : DateHeure invalide
      en-US : Invalid dateTime
     index : 9
   -
     text :
      fr-FR : Pas de transaction en cours
      en-GB : No transaction in progress
      fr-CA : Pas de transaction en cours
      en-US : No transaction in progress
     index : 10
   -
     text :
      fr-FR : Une transaction est déjà en cours
      en-GB : A transaction is already in progress
      fr-CA : Une transaction est déjà en cours
      en-US : A transaction is already in progress
     index : 11
   -
     text :
      fr-FR : La table %1 n'existe pas dans la base de données
      en-GB : Table %1 does not exist in the database
      fr-CA : La table %1 n'existe pas dans la base de données
      en-US : Table %1 does not exist in the database
     index : 12
   -
     text :
      fr-FR : Aucune colonne
      en-GB : No columns
      fr-CA : Aucune colonne
      en-US : No columns
     index : 13
   -
     text :
      fr-FR : ODBC non supportée
      en-GB : ODBC not supported
      fr-CA : ODBC non supportée
      en-US : ODBC not supported
     index : 14
   -
     text :
      fr-FR : Les DLL de l'ODBC n'ont pas été trouvées
      en-GB : ODBC DLLs not found
      fr-CA : Les DLL de l'ODBC n'ont pas été trouvées
      en-US : ODBC DLLs not found
     index : 15
   -
     text :
      fr-FR : Le nom de la base de donné est obligatoire
      en-GB : Database name is mandatory
      fr-CA : Le nom de la base de donné est obligatoire
      en-US : Database name is mandatory
     index : 16
   -
     text :
      fr-FR : Les paramètres sont obligatoires
      en-GB : Parameters are mandatory
      fr-CA : Les paramètres sont obligatoires
      en-US : Parameters are mandatory
     index : 17
custom_note :
 internal_properties : CQAAAAkAAABtB9HWVzrXO2+4NDRVK0vmzaNKrCKqH1DBX30lMmGZ
