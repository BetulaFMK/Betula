#To edit and compare internal_properties, use WINDEV integrated tools.
#Internal properties refer to the properties of controls in windows, reports, etc.
info :
 name : COL_Conversion
 major_version : 29
 minor_version : 0
 type : 7
 description : ""
 subtype : 0
procedure_set :
 identifier : 0x1b155a3403be377f
 internal_properties : CQAAAAkAAABGLu41kG7fjQV3iS4F72qmnKaNh5694reolNKIW0iw
 code_elements :
  type_code : 31
  p_codes :
   -
     code : |1-
      //*************************************************************************************************************************************************************************
      //Ce fichier fait partie de Betula.
      //Betula est un logiciel libre ; vous pouvez le redistribuer ou le modifier suivant les termes de la GNU Lesser General Public License telle que publiée par la Free Software Foundation ; soit la version 3 de la licence, soit (à votre gré) toute version ultérieure.
      //Betula est distribué dans l'espoir qu'il sera utile, mais SANS AUCUNE GARANTIE ; sans même la garantie tacite de QUALITÉ MARCHANDE ou d'ADÉQUATION à UN BUT PARTICULIER. Consultez la GNU Lesser General Public License pour plus de détails.
      //Vous devez avoir reçu une copie de la GNU Lesser General Public License en même temps que Betula ; si ce n'est pas le cas, consultez <http://www.gnu.org/licenses>.
      //
      //This file is part of Betula.
      //Betula is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
      //Betula is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
      //You should have received a copy of the GNU Lesser General Public License along with Betula. If not, see <https://www.gnu.org/licenses/>
      //*************************************************************************************************************************************************************************
      
      COChaineHasard est une Combinaison
      	Minuscules
      	MinusculesAccentuées
      	Majuscules
      	MajusculesAccentuées
      	GrequesMajuscules
      	GrequesMinuscules
      	RussesMajuscules
      	RussesMinuscules
      	ArméniennesMajuscules
      	ArméniennesMinuscules
      	Chiffres
      	Ponctuations
      	Spéciaux
      FIN
      EFichierDécoupe est une Enumération
      	ParTaille
      	ParTailleSurRC
      	ParNbLignes
      FIN
      EMultiplicateur est une énumération
      	quetta				= 10e30
      	ronna				= 10e27
      	yotta				= 10e24
      	zetta				= 10e21
      	exa					= 10e18
      	peta				= 10e15
      	tera				= 10e12
      	giga				= 10e9
      	mega				= 10e6
      	kilo				= 10e3
      	hecto				= 10e2
      	déca				= 10e1
      	Aucun				= 10e0
      	déci				= 10e-1
      	centi				= 10e-2
      	milli				= 10e-3
      	micro				= 10e-6
      	nano				= 10e-9
      	pico				= 10e-12
      	femto				= 10e-15
      	atto				= 10e-18
      	zepto				= 10e-21
      	yocto				= 10e-24
      	ronto				= 10e-27
      	quecto				= 10e-30
      fin
      EMultiInformatique est une énumération
      	Aucun				= 1
      	kilo				= 1024
      	mega				= 1048576
      	giga				= 1073741824
      	tera				= 1099511627776
      	péta				= 1125899906842624
      	exa					= 1152921504606846976
      	zetta				= 1180591620717411303424
      	yotta				= 1208925819614629174706176
      fin
      
      ENumériqueEnChaine est une Enumération
      	PartieEntière
      	PartieDécimaleMonétaire
      	PartieDécimaleStandard
      FIN
      ENumériqueEnFrançaisLangue est une énumération
      	France	
      	Belgique
      	Suisse	
      	Canada	
      	AfriqueFrancophone	
      	RépubliqueDémocratiqueDuCongo
      FIN
      ENumériqueEnFrançaisOption est une Enumération
      	Classique
      	CentainesVigésimales
      FIN
      
      //la première unité est celle reconnue par le système international
      EUnitéLongueur est une énumération
      	Mètre				= 1
      	Angström			= 1.00001501e-10
      	UnitéAstronomique	= 149600000000
      	AnnéeLumière		= 946073047258080
      	Pied				= 0.3048
      	Pouce				= 0.0254
      	MilleInternational	= 1609.344
      	Verge				= 0.9144
      fin
      EUnitéAccélération est une énumération
      	MètreParSecondeCarré= 1
      	GravitéTerrestre	= 9.81
      	Gal					= 0.01
      fin
      EUnitéAngle est une énumération
      	Radian				= 1
      	Gradian				= 0.9
      	Degré				= 0.017453292519943
      	MinuteArc			= 2.908882086657167e-4
      	SecondeArc			= 4.848136811095278e-6
      fin
      EUnitéDurée est une énumération
      	Seconde				= 1
      	Minute				= 60
      	Heure				= 3600
      fin
      EUnitéForce est une énumération
      	Newton				= 1
      	Dyne				= 1e-5
      	LivreForce			= 4.4482216152605
      	KilogrammeForce		= 9.80665
      fin
      EUnitéFréquence est une énumération
      	Hertz				= 1
      	Jour				= 1.1574074074074e-5
      	Heure				= 0.00027777777777778
      	Minute				= 0.016666666666667
      fin
      EUnitéMasse est une énumération
      	Kilogramme			= 1
      	Tonne				= 1000
      	Quintal				= 50
      	Livre				= 0.5
      	LivreImpériale		= 0.45359237
      	OnceImpériale		= 0.028349523125
      	Carat				= 0.0002
      fin
      EUnitéPression est une énumération
      	Pascal_				= 1					//_ car Pascal est un mot réservé du WLangage
      	Bar					= 100000
      	NewtonParMètreCarré	= 1
      	LivreParPouceCarré	= 0n6894.757293168
      	AtmosphèreTechnique = 98066.5
      	AtmosphèrePhysique	= 101325
      	MilliMètreMercure	= 133.322
      fin
      EUnitéPuissance est une énumération
      	Watt				= 1
      	ChevalVapeur		= 735.39875
      	ChevalVapeurUS		= 745.66272
      fin
      EUnitéSurface est une énumération
      	MètreCarré			= 1
      	Hectare 			= 10000
      	Are_				= 100				//_ car are est un mot réservé du WLangage
      	centiare			= 1
      	PiedCarré			= 0.09290304
      	PouceCarré			= 0.00064516
      fin
      EUnitéTempérature est une énumération
      	Kelvin				= "Kelvin"	
      	Celsius				= "Celsius"		//voir fonction ConvertiTempérature
      	Fahrenheit          = "Fahrenheit"	//voir fonction ConvertiTempérature 	
      	Réaumur				= "Réaumur"		//voir fonction ConvertiTempérature
      	Rankine				= "Rankine"		//voir fonction ConvertiTempérature
      fin
      EUnitéÉnergie est une Enumération
      	Joule				= 1
      	Calorie				= 4.1855
      	KiloWattHeure		= 3600000
      	WattSeconde			= 1
      	Pascal_				= 1
      	ElectronVolt		= 1.60217733e-19
      	BTU					= 1055					//British Thermal Unit
      	tep					= 4.1868E10				//tonne d'équivalent pétrole
      	tec					= 2.93076E10 			//tonne d'équivalent charbon
      	PiedLivreForce		= 0n1.3558200043752493
      FIN
      EUnitéConsommation est une énumération
      	LitrePar1km			= 1
      	KmParLitre			= 1
      	MilleParGallonUS	= 2.35214
      	MilleParGallonUK	= 2.82482
      	MileParLitre		= 0.62137
      	LitrePar100km		= 100
      	GallonPar100MillesUS= 42.51438
      	GallonPar100MillesUK= 35.40055
      fin
      EUnitéInformatique est une énumération
      	bit					= 1
      	octet_				= 8
      fin
      EUnitéVitesse est une énumération
      	MètreParSeconde		= 1
      	MètreParMinute		= 0.016666666666667
      	KilomètreParSeconde	= 1000
      	MileParSeconde		= 1609.344
      	MileParHeure		= 0.44704
      	PiedParSeconde		= 0.3047999902464
      	PiedParMinute		= 0.00507999983744
      	MinuteParKilomètre	= 16.66666666667
      	Noeud				= 0.51444444444
      	MileNautiqueParHeure= 0.51444
      	VitesseLumière		= 299792458
      	Mach 				= 340
      fin
      EUnitéVolume est une énumération
      	MètreCube			= 1
      	Litre				= 0.001
      	PiedCube			= 0.028316846592
      	PouceCube			= 1.6387064e-5
      	GallonImpérial		= 0.00454609
      	Pinte				= 0.00056826125
      	Baril				= 0.1589873
      fin
      ETypeCoordonnéesLambert est une énumération
      	LambertI			= 1
      	LambertII			= 2
      	LambertIII			= 3
      	LambertIV			= 4
      	LambertIIétendu		= 5
      	Lambert93			= 6
      fin
      
      privé
      	constante
      		ErreurDeConverion	= 110
      	fin
      	gtaJSONEncode		est un tableau associatif de chaines
      
      InitHasard()		//pour chaineHasard()
     type : 720896
   -
     code : |1+
      //
     type : 720898
  procedures :
   -
     name : AnsiVersBase64
     procedure_id : 1985675329496149823
     type_code : 15
     code : |1+
      // Résumé : Convertit une chaîne ANSI en format Base64.
      // Syntaxe : AnsiVersBase64(sTexte est une chaîne ANSI) : chaîne
      // Paramètres :
      //   sTexte (chaîne ANSI) : La chaîne ANSI à convertir en format Base64.
      // Valeur de retour : chaîne unicode : La chaîne convertie en format Base64.
      // Exemple : voir tests automatiques
      PROCEDURE AnsiVersBase64(sTexte est une chaine ansi) : chaine
      SI sTexte="" ALORS RENVOYER ""
      
      
      <si CibleExécution=ApplicationWindows ou CibleExécution=Site ou CibleExécution=SitePHP ou CibleExécution=Webservice ou CibleExécution=AssemblageDotNet ou CibleExécution=ApplicationLinux64 ou CibleExécution=ServiceWindows ou CibleExécution=ServiceLinux64 ou CibleExécution=iOS ou CibleExécution=UniversalWindowsApp ou CibleExécution=WindowsMobile>
      	renvoyer Crypte(sTexte,"",compresseAucun + crypteAucun,encodeBASE64)
      	
      <sinon si CibleExécution=Java ou CibleExécution=Android ou CibleExécution=AppleWatch>
      	//ref : https://fr.wikipedia.org/wiki/Base64
      	sBinaire,sRésultat,sBloc est une chaine
      	nVal est un entier
      	POUR n=1 _a_ taille(sTexte)
      		SELON Asc(sTexte[[n]])
      			CAS 0x00 À 0x7f	: sBinaire+=NumériqueVersBinaire(Asc(sTexte[[n]]),8)
      			CAS 0x80 À 0xbf : sBinaire+=NumériqueVersBinaire(0xC2,8)+NumériqueVersBinaire(Asc(sTexte[[n]]),8)
      			AUTRE CAS		: sBinaire+=NumériqueVersBinaire(0xC3,8)+NumériqueVersBinaire(Asc(sTexte[[n]])-64,8)
      		FIN
      	FIN
      	POUR n=1 _a_ taille(sBinaire) pas 6
      		sBloc = Gauche(sBinaire[[(n-1)+1 À (n-1)+6]]+"000000",6)
      		nVal=BinaireVersEntier(sBloc)
      		SELON nVal
      			CAS 0 À 25	: sRésultat+=Caract(nVal+65)
      			CAS 26 À 51	: sRésultat+=Caract(nVal+71)
      			CAS 52 À 61	: sRésultat+=Caract(nVal-4)
      			CAS 62		: sRésultat+="+"
      			CAS 63		: sRésultat+="/"
      		FIN
      	FIN
      	SI modulo(Taille(sRésultat),4)<>0 ALORS sRésultat=(sRésultat+Répète("=",4-modulo(Taille(sRésultat),4)))
      	renvoyer sRésultat
      	
      <fin>
      
     type : 458752
   -
     name : JSONEncode
     procedure_id : 1986407187474883671
     type_code : 15
     code : |1-
      // Résumé : Cette fonction encode une chaîne de caractères en suivant les règles du format JSON. Elle remplace certains caractères spéciaux par leurs équivalents JSON pour assurer la validité du format.
      // Syntaxe : [ <Résultat> = ] JSONEncode (<sChaine> est chaîne)
      // Paramètres :
      //	sChaine (chaîne UNICODE) : La chaîne de caractères à encoder en format JSON.
      // Valeur de retour : chaîne UNICODE : La fonction renvoie la chaîne de caractères encodée en format JSON.
      // Exemple : 
      // sChaine = "Ceci est une chaîne avec des caractères spéciaux : éà"
      // sJSON = JSONEncode(sChaine)
      // résultat "Ceci est une cha\u00eene avec des caract\u00e8res sp\u00e9ciaux : \u00e9\u00e0"
      
      PROCEDURE JSONEncode(local sChaine est une chaine) : chaine	//LA METHODE CI-DESSOUS EST LA PLUS RAPIDE
      si sChaine~="" alors renvoyer ""
      si pas gtaJSONEncode[sChaine]..vide alors renvoyer gtaJSONEncode[sChaine]	//optimisation (notamment en cas de lecture d'enregistrement successif de la même table)
      sRes est une chaine
      nAsc est un entier
      pour n = 1 _a_ taille(sChaine)
      	nAsc=asc(sChaine[[n]])
      	selon nAsc
      		cas 9		: sRes+="\t"						//tab
      		cas 10		: sRes+="\n"						//line feed
      		cas 13		: sRes+="\r"						//carriage return
      		cas 34		: sRes+="\"+cGénérique._Guillemet	//quote
      		cas 47		: sRes+="\/"						//slash
      		cas 92		: sRes+="\\"						//backslash
      		autres cas	: si nAsc<128 alors sRes+=sChaine[[n]] sinon sRes+="\u"+NumériqueVersChaîne(nAsc,"04x") 	//EntierVersHexa(nAsc) pas compatible avec Windows Mobile	
      	FIN
      FIN
      gtaJSONEncode[sChaine]=sRes								//optimisation
      renvoyer sRes
     type : 458752
   -
     name : BinaireVersEntier
     procedure_id : 1985675398215643173
     type_code : 15
     code : |1-
      // Résumé : Convertit une chaîne binaire en sa valeur équivalente en base 10 (entier)
      // Syntaxe : [ <Résultat> = ] BinaireVersEntier (<sChaineBinaire> est chaîne)
      // Paramètres :
      //	sChaineBinaire (chaîne UNICODE) : Une chaîne représentant le nombre en format binaire.
      // Valeur de retour : entier : Un entier représentant la valeur décimale du nombre binaire.
      // Exemple : 
      // sBinaire est une chaine = "1101"
      // nEntier est un entier = BinaireVersEntier(sBinaire)
      // nEntier contient maintenant la valeur 13
      
      PROCEDURE BinaireVersEntier(local sChaineBinaire est une chaine) : entier sur 8 octets
      si sChaineBinaire>repete("1",62) alors renvoyer 0	//dépassement de capacité
      si sChaineBinaire~="" alors renvoyer 0 sinon sChaineBinaire=ChaîneInverse(sChaineBinaire)
      nRésultat est un entier sur 8 octets
      pour n = 1 _A_ taille(sChaineBinaire)
      	si sChaineBinaire[[n]]="1" alors nRésultat+=puissance(2,n-1)
      FIN
      renvoyer nRésultat
     type : 458752
   -
     name : ChaineHasard
     procedure_id : 1982807545827922795
     type_code : 15
     code : |1-
      // Résumé : Cette fonction génère une chaîne de caractères aléatoire en respectant les options spécifiées.
      // Syntaxe : [ <Résultat> = ] ChaineHasard (<nNombreCaractères> est entier, <coOptions> est COL_Conversion.COChaineHasard [, <bCompatibleNomDeFichier> est booléen [, <bUnique> est booléen]])
      // Paramètres :
      //	nNombreCaractères (entier) : Le nombre de caractères dans la chaîne générée.
      //	coOptions (COL_Conversion.COChaineHasard) : Les options de génération de la chaîne. Il s'agit d'une combinaison de constantes définies dans la COChaineHasard.
      // 	bCompatibleNomDeFichier (booléen, optionnel) : Indique si la chaîne générée doit être compatible avec les noms de fichiers. Par défaut, c'est Faux.
      // 	bUnique (booléen, optionnel) : Si Vrai, chaque caractère de la chaîne générée doit apparaître au plus une fois. Par défaut, c'est Faux.
      //  sCaractèresSupplémentaires (chaîne, optionnel) : Une chaîne de caractères supplémentaires qui peuvent être inclus dans la génération.
      // Valeur de retour :
      // 	chaîne UNICODE : La fonction renvoie une chaîne de caractères aléatoire selon les spécifications fournies.
      // Exemple :
      // ChaineHasard(8, COChaineHasard(Minuscules + Majuscules + Chiffres), Faux, Vrai)
      // Exemple de résultat : "aB3FgH7k"
      //
      PROCEDURE ChaineHasard(nNombreCaractères est un entier, coOptions est une COChaineHasard,bCompatibleNomDeFichier est un booleen=faux,bCaractèreApparaitUneFois est un booleen=faux,sCaractèresSupplémentaires est une chaine = "") : chaine
      //A FAIRE : bCompatibleNomDeFichier pour les OS autres que Windows 
      sResultat,sTemp sont des chaines
      nTaille,nHasard	sont des entiers
      
      SI nNombreCaractères>0 ALORS
      	SI coOptions[Minuscules] 			ALORS sTemp+=cGénérique._LettresMinuscules
      	SI coOptions[MinusculesAccentuées] 	ALORS sTemp+=cgenerique._LettresAccentMinuscules
      	SI coOptions[Majuscules] 			ALORS sTemp+=cgenerique._lettresmajuscules
      	SI coOptions[MajusculesAccentuées] 	ALORS sTemp+=cgenerique._LettresAccentMajuscules
      	SI coOptions[Chiffres] 				ALORS sTemp+=cGénérique._CaractèresNumériques
      	si coOptions[GrequesMinuscules]		alors sTemp+=cgenerique._LettresGrecquesMinuscules		
      	SI coOptions[GrequesMajuscules]		ALORS sTemp+=cGénérique._LettresGrecquesMajuscules		
      	SI coOptions[RussesMinuscules]		ALORS sTemp+=cGénérique._LettresRussesMinuscules		
      	SI coOptions[RussesMajuscules]		ALORS sTemp+=cGénérique._LettresRussesMajuscules		
      	SI coOptions[ArméniennesMinuscules]	aLORS sTemp+=cGénérique._LettresArméniennesMinuscules	
      	SI coOptions[ArméniennesMajuscules]	ALORS sTemp+=cGénérique._LettresArméniennesMajuscules	
      	SI coOptions[Ponctuations] 			ALORS sTemp+=",;!.'(-_)=~#{[`^]}+¨%±°"+cGénérique._Guillemet+(bCompatibleNomDeFichier ? "" sinon ":/|?*\"+cGénérique._Guillemet)
      	SI coOptions[Spéciaux] 				ALORS sTemp+="&$£€¢µ§@¤¬¦²³¼½¾§¶«»"+(bCompatibleNomDeFichier ? "" SINON "<>")
      	sTemp+=sCaractèresSupplémentaires
      
      	nTaille = taille(sTemp)
      	si nTaille>0 alors
      		si bCaractèreApparaitUneFois _et_ nTaille<nNombreCaractères alors
      			ErreurDéclenche(ErreurDeConverion,<§@1b155a2803bc06420050§>)
      		sinon
      			boucle
      				nHasard=Hasard(1,nTaille)
      				si pas bCaractèreApparaitUneFois _ou_ position(sResultat,sTemp[[nHasard]])<1 alors sResultat+=sTemp[[nHasard]]
      				si taille(sResultat)=nNombreCaractères alors sortir
      			FIN
      		FIN
      	sinon
      		erreurdéclenche(ErreurDeConverion,<§@1b155a2803bc06420045§>)
      	fin
      FIN
      RENVOYER sResultat
     type : 458752
   -
     name : ChaineVersHexa
     procedure_id : 1976057342778610912
     type_code : 15
     code : |1-
      // Résumé : Cette fonction convertit une chaîne de caractères en une représentation hexadécimale.
      // Syntaxe : [ <Résultat> = ] ChaineVersHexa (<sLaChaine> est chaîne [, <nTailleCaractère> est entier])
      // Paramètres :
      //	sLaChaine (chaîne UNICODE) : La chaîne de caractères à convertir en hexadécimal.
      // 	nTailleCaractère (entier, optionnel) : La taille souhaitée de chaque caractère hexadécimal. Par défaut, c'est 2.
      // Valeur de retour : chaîne UNICODE : La fonction renvoie une chaîne représentant la version hexadécimale de la chaîne d'entrée.
      // Exemple :
      // 	ChaineVersHexa("Bonjour")
      // 	Renvoie : "426F6E6A6F7572"
      //
      PROCEDURE ChaineVersHexa(sLaChaine est une chaine,nTailleCaractère est un entier = 2) : chaine
      si sLaChaine~="" alors renvoyer ""
      si nTailleCaractère<2 alors nTailleCaractère=2
      sRes est une chaine
      pour nPosition = 1 _a_ taille(sLaChaine) sRes+=NumériqueVersChaîne(asc(sLaChaine[[nPosition]]),"0"+nTailleCaractère+"x")
      renvoyer sRes
     type : 458752
   -
     name : ChaineVersNomDeFichier
     procedure_id : 2012873622805858078
     type_code : 15
     code : |1-
      // Résumé : Cette fonction convertit une chaîne en une version adaptée pour être utilisée comme nom de fichier, en supprimant les caractères interdits pour les noms de fichier sous Windows.
      // Syntaxe : [ <Résultat> = ] ChaineVersNomDeFichier (<sNomDuFichier> est chaîne)
      // Paramètres :
      //	sNomDuFichier (chaîne UNICODE) : La chaîne à convertir en nom de fichier.
      // Valeur de retour : chaîne UNICODE : La fonction renvoie une nouvelle chaîne où les caractères interdits pour les noms de fichier sous Windows ont été supprimés.
      // Exemple :
      // ChaineVersNomDeFichier("Mon fichier : super !.txt")
      // Renvoie : "Mon fichier  super .txt"
      //
      PROCEDURE ChaineVersNomDeFichier(sNomDuFichier est une chaîne) : chaine
      //A FAIRE : Pour les OS autres que Windows
      SI sNomDuFichier~="" ALORS RENVOYER ""
      sCaractèresInterditsWindows est une chaîne = cgenerique._Guillemet+"/\:*?<>|"
      sRes est une chaîne
      POUR nPosition = 1 _À_ Taille(sNomDuFichier)
      	SI Position(sCaractèresInterditsWindows,sNomDuFichier[[nPosition]])<1 ALORS sRes+=sNomDuFichier[[nPosition]]
      FIN
      RENVOYER sRes
     type : 458752
   -
     name : CheminVersURL
     procedure_id : 2012873884798924364
     type_code : 15
     code : |1-
      // Résumé : Cette fonction convertit un chemin local en une structure d'URL (cRéseau.STURL). Elle extrait des informations telles que le protocole, l'utilisateur, le mot de passe, le domaine, le port, le chemin absolu, le nom de fichier, les paramètres, et le signet d'une URL. La différence avec URLExtraitChemin est qu'ici c'est une structure qui est récupérée et tous les paramètres sont dans un tableau.
      // Syntaxe : [ <Résultat> = ] CheminVersURL (<sChemin> est chaîne)
      // Paramètres :
      //	sChemin (chaîne UNICODE) : Le chemin à convertir en structure URL.
      // Valeur de retour :
      // 	STURL : La fonction renvoie une structure d'URL (cRéseau.STURL) qui contient les éléments extraits du chemin.
      // Exemple :
      // CheminVersURL("C:\Documents\exemple\index.html?q=requête#section")
      //
      PROCEDURE CheminVersURL(LOCAL sChemin est une chaîne) : cRéseau.STURL	
      //exemple : http://Jojo:lApIn@www.example.com:8888/chemin/d/acc%C3%A8s.php?q=req&q2=req2#signet
      stURL est un cRéseau.STURL
      sTemp est une chaîne
      
      SI sChemin~="" ALORS RENVOYER stURL SINON sChemin=Remplace(sChemin,"\","/")
      si position(sChemin,"//")>0 alors	
      	stURL.sProtocole	= Minuscule(ExtraitChaîne(sChemin,1,":"))
      	sTemp				= ExtraitChaîne(sChemin,3,"/")	//Jojo:lApIn@www.example.com:8888
      sinon					//si http:// n'est pas dans le chemin car le protocole pourrait être géré autrement (voir FTP)
      	sTemp				= sChemin
      fin
      SI Position(sTemp,"@")>0 ALORS 
      	stURL.sUtilisateur	= Remplace(ExtraitChaîne(sTemp,1,"@"),"%40","@")
      	stURL.sMotDePasse	= ExtraitChaîne(stURL.sUtilisateur,2,":");stURL.sUtilisateur=ExtraitChaîne(stURL.sUtilisateur,1,":")
      	sTemp				= ExtraitChaîne(sTemp,2,"@")
      FIN
      SI Position(sTemp,":")>0 ALORS
      	SI Position(sTemp,"[")>0 ALORS 
      		stURL.nPort		= Val(ExtraitChaîne(sTemp,2,"]:"))
      		sTemp			= Milieu(ExtraitChaîne(sTemp,1,"]:"),2)	//ex : [1234:abcd::1234]:8888
      	SINON
      		stURL.nPort		= Val(ExtraitChaîne(sTemp,2,":"))
      		sTemp			= ExtraitChaîne(sTemp,1,":")
      	FIN
      SINON
      	SELON stURL.sProtocole
      		CAS "http"	: stURL.nPort=cRéseau._PortHTTP
      		CAS "https"	: stURL.nPort=cRéseau._PortHTTPS
      		CAS "ftp"	: stURL.nPort=cRéseau._PortFTP
      		CAS "sftp"	: stURL.nPort=cRéseau._PortSFTP
      		CAS "ftps"	: stURL.nPort=cRéseau._PortFTPS
      		CAS "ftpes" : stURL.nPort=cRéseau._PortFTPES
      		CAS "telnet": stURL.nPort=cRéseau._PortTelnet
      		CAS "dns"	: stURL.nPort=cRéseau._PortDNS
      		CAS "nntp"	: stURL.nPort=cRéseau._PortNNTP
      		CAS "ntp"	: stURL.nPort=cRéseau._PortNTP
      		CAS "irc"	: stURL.nPort=cRéseau._PortIRC
      	FIN
      FIN
      stURL.sDomaine			= sTemp
      stURL.sSousDomaine		= ExtraitChaîne(sTemp,1,".")
      stURL.sDomaine2ndNiveau	= (ExtraitChaîne(sTemp,2,".")=EOT ? "" SINON ExtraitChaîne(sTemp,2,"."))
      stURL.sDomaine1erNiveau	= Milieu(sTemp,Taille(stURL.sSousDomaine)+Taille(stURL.sDomaine2ndNiveau)+3)//pas ExtraitChaîne(sTemp,3,".") car doit gérer .qc.ca
      
      stURL.sCheminAbsolu		= Milieu(sChemin,PositionOccurrence(sChemin,"/",3),Position(sChemin,"/",0,DepuisFin)-PositionOccurrence(sChemin,"/",3))
      
      sTemp					= ExtraitChaîne(sChemin,1,"/",DepuisFin)
      SI Position(sTemp,"#")>0 ALORS
      	stURL.sSignet=ExtraitChaîne(sTemp,2,"#");sTemp=ExtraitChaîne(sTemp,1,"#")
      FIN
      SI Position(sTemp,"?")>0 ALORS
      	stURL.sNomFichier=ExtraitChaîne(sTemp,1,"?");stURL.sParamètres=ExtraitChaîne(sTemp,2,"?")
      	POUR TOUTE CHAÎNE sParamètre DE stURL.sParamètres SÉPARÉE PAR "&"
      		stURL.taParamètres[ExtraitChaîne(sParamètre,1,"=")]=ExtraitChaîne(sParamètre,2,"=")
      	FIN
      SINON
      	stURL.sNomFichier=sTemp
      FIN
      
      RENVOYER stURL
     type : 458752
   -
     name : NombreVersRomain
     procedure_id : 2012874017942941085
     type_code : 15
     code : |1-
      // Résumé : Cette fonction convertit un nombre entier en un nombre romain. La conversion est effectuée pour des nombres dans la plage de 1 à 3999 inclus, sans prise en compte des décimales. La conversion est limitée à la plage de 1 à 3999 inclus.
      // Syntaxe : [ <Résultat> = ] NombreVersRomain (<nNombre> est entier)
      // Paramètres :
      //	nNombre (entier) : Le nombre  à convertir en nombre romain.
      // Valeur de retour : chaîne UNICODE : La fonction renvoie une chaîne représentant le nombre romain correspondant à la valeur de l'entier fourni en paramètre.
      // Exemple :
      // 	NombreVersRomain(354)
      // 	Renvoie la chaîne "CCCLIV" représentant le nombre romain pour 354.
      //
      PROCEDURE NombreVersRomain(local nNombre est un entier) : chaîne
      //ref : cet algorithme a été suggéré par ChatGPT
      //pas de décimale dans les chiffres romains et nombre limité à 3999 qui est le maximum représentable de manière standard
      sRes est une chaîne
      SI nNombre>0 ET nNombre<=4000 ALORS
      	// Définition des symboles romains et de leurs valeurs
      	symbolesRomains est un tableau de chaine = ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]
      	valeursRomains est un tableau d'entiers = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
      	
      	// Parcours des symboles romains et conversion
      	pour i = 1 _à_ symbolesRomains..occurrence
      		tantque nNombre >= valeursRomains[i]
      			// Ajout du symbole romain au résultat
      			sRes += symbolesRomains[i]
      			// Soustraction de la valeur correspondante
      			nNombre -= valeursRomains[i]
      		fin
      	fin
      sinon
      	ErreurDéclenche(ErreurDeConverion,<§@1b155a2803bc06420046§>)
      FIN
      RENVOYER sRes
     type : 458752
   -
     name : DateHeureDifférenceEnMinutes
     procedure_id : 1951565235932322971
     type_code : 15
     group : 5
     code : |1-
      // Résumé : Cette fonction calcule la différence en minutes entre deux dates/heures. Elle prend en compte une date/heure de début, une date/heure de fin, et renvoie la différence en minutes sous forme d'un entier.
      // Syntaxe : [ <Résultat> = ] DateHeureDifférenceEnMinutes (<dhDébut> est dateheure [, <dhFin> est dateheure [, <nValeurRetourSiInvalide> est entier]])
      // Paramètres :
      //	dhDébut (dateheure) : La date/heure de début de la période.
      //	dhFin (dateheure optionnelle) : La date/heure de fin de la période. Si non spécifiée, elle est définie par défaut à la date/heure système.
      // 	nValeurRetourSiInvalide (entier optionnel) : La valeur de retour en cas d'invalidité des dates/heures. Par défaut, elle est définie à 99999.
      // Valeur de retour : entier : La fonction renvoie la différence en minutes entre les deux dates/heures en tant qu'entier.
      // Exemple :
      // DateHeureDifférenceEnMinutes("20230101120000", "20230101143000")
      // Renvoie 150, représentant la différence de 2 heures et 30 minutes.
      //
      PROCEDURE DateHeureDifférenceEnMinutes(dhDébut est une dateheure,dhFin est une dateheure = dateheuresys(),nValeurRetourSiInvalide est un entier = 99999) : entier
      SI PAS DateHeureValide(dhDébut) ALORS ErreurDéclenche(ErreurDeConverion,<§@1b155a2803bc06420040§>);RENVOYER nValeurRetourSiInvalide
      SI PAS DateHeureValide(dhFin) 	ALORS ErreurDéclenche(ErreurDeConverion,<§@1b155a2803bc06420041§>);RENVOYER nValeurRetourSiInvalide
      duDiff est une durée 	= ChaîneVersDurée(DateHeureDifférence(dhDébut,dhFin),duréeCentième)
      RENVOYER duDiff..EnMinutes
     type : 458752
   -
     name : DateHeureDifférenceEnSecondes
     procedure_id : 1951565235932388554
     type_code : 15
     group : 5
     code : |1-
      // Résumé : Cette fonction calcule la différence en secondes entre deux dates/heures. Elle prend en compte une date/heure de début, une date/heure de fin, et renvoie la différence en secondes sous forme d'un entier.
      // Syntaxe : [ <Résultat> = ] DateHeureDifférenceEnSecondes (<dhDébut> est dateheure [, <dhFin> est dateheure [, <nValeurRetourSiInvalide> est entier]])
      // Paramètres :
      //	dhDébut (dateheure) : La date/heure de début de la période.
      //	dhFin (dateheure, optionnel) : La date/heure de fin de la période. Si non spécifiée, elle est définie par défaut à la date/heure système.
      // 	nValeurRetourSiInvalide (entier optionnel) : La valeur de retour en cas d'invalidité des dates/heures. Par défaut, elle est définie à 99999.
      // Valeur de retour : La fonction renvoie la différence en secondes entre les deux dates/heures en tant qu'entier.
      // Exemple :
      // DateHeureDifférenceEnSecondes("20230101120000", "20230101143000")
      // Renvoie 9000, représentant la différence de 2 heures et 30 minutes en secondes.
      //
      PROCEDURE DateHeureDifférenceEnSecondes(dhDébut est une dateheure,dhFin est une dateheure = dateheuresys(),nValeurRetourSiInvalide est un entier = 99999) : entier
      SI PAS DateHeureValide(dhDébut) ALORS ErreurDéclenche(ErreurDeConverion,<§@1b155a2803bc06420040§>);RENVOYER nValeurRetourSiInvalide
      SI PAS DateHeureValide(dhFin) 	ALORS ErreurDéclenche(ErreurDeConverion,<§@1b155a2803bc06420041§>);RENVOYER nValeurRetourSiInvalide
      duDiff est une durée 	= ChaîneVersDurée(DateHeureDifférence(dhDébut,dhFin),duréeCentième)
      RENVOYER duDiff..Ensecondes
     type : 458752
   -
     name : GUIDVersHexa
     procedure_id : 1970130348406327644
     type_code : 15
     code : |1-
      // Résumé : Cette fonction convertit une chaîne représentant un GUID (Globally Unique Identifier) en format hexadécimal. Un GUID est généralement utilisé pour identifier de manière unique une ressource. La fonction suppose que la chaîne d'entrée a un format de GUID valide. Elle ne vérifie pas la validité du GUID, mais elle s'attend à une longueur de 32 caractères.
      // Syntaxe : [ <Résultat> = ] GUIDVersHexa (<sUnGUID> est chaîne)
      // Paramètres :
      //	sUnGUID (chaîne UNICODE) : La chaîne représentant le GUID à convertir.
      // Valeur de retour : chaîne UNICODE : La fonction renvoie une chaîne représentant le GUID converti en format hexadécimal avec des séparateurs.
      // Exemple :
      // 	GUIDVersHexa("{12345678-90AB-CDEF-1234-567890ABCDEF}")
      // 	Renvoie "7856341290ABCDEF1234567890ABCDEF"
      //
      PROCEDURE GUIDVersHexa(sUnGUID est une chaine) : chaine
      si taille(sUnGUID)=16 alors
      	sRes est une chaine
      	POUR nCaract = 6 À 1 PAS -1
      		sRes=NumériqueVersChaîne(Asc(sUnGUID[[10+nCaract]]),"02X")+sRes
      	FIN
      	sRes="-"+sRes
      	POUR nCaract = 2 À 1 PAS -1
      		sRes=NumériqueVersChaîne(Asc(sUnGUID[[8+nCaract]]),"02X")+sRes
      	FIN
      	sRes="-"+sRes
      	POUR nCaract = 1 À 2
      		sRes=NumériqueVersChaîne(Asc(sUnGUID[[6+nCaract]]),"02X")+sRes
      	FIN
      	sRes="-"+sRes
      	POUR nCaract = 1 À 2
      		sRes=NumériqueVersChaîne(Asc(sUnGUID[[4+nCaract]]),"02X")+sRes
      	FIN
      	sRes="-"+sRes
      	POUR nCaract = 1 À 4
      		sRes=NumériqueVersChaîne(Asc(sUnGUID[[nCaract]]),"02X")+sRes
      	FIN
      	RENVOYER "{"+sRes+"}"
      sinon
      	ErreurDéclenche(ErreurDeConverion,<§@1b155a2803bc06420047§>);renvoyer ""
      fin
     type : 458752
   -
     name : HexaVersChaine
     procedure_id : 1976066564081112682
     type_code : 15
     code : |1-
      // Résumé : Cette fonction convertit une chaîne hexadécimale en une chaîne de caractères ASCII correspondante. Chaque paire de caractères hexadécimaux représente un caractère ASCII dans la chaîne de sortie.
      // Syntaxe : [ <Résultat> = ] HexaVersChaine (<sChaineHexa> est chaîne)
      // Paramètres :
      //	sChaineHexa (chaîne UNICODE) : La chaîne hexadécimale à convertir en caractères ASCII.
      // Valeur de retour : chaîne UNICODE : La fonction renvoie une chaîne de caractères ASCII résultant de la conversion de la chaîne hexadécimale.
      // Exemple :
      // 	HexaVersChaine("48656C6C6F20576F726C64")
      // 	Renvoie "Hello World".
      //
      PROCEDURE HexaVersChaine(sChaineHexa est une chaine) : chaine
      sRes est une chaîne
      si sChaineHexa~="" _ou_ pas VérifieExpressionRégulière(sChaineHexa,"[A-Fa-f0-9]+") alors RENVOYER sRes
      si estpair(taille(sChaineHexa)) alors
      	pour nPosition = 1 _a_ taille(sChaineHexa) pas 2 sRes+=caract(val(sChaineHexa[[nPosition]]+sChaineHexa[[nPosition+1]],"x"))
      	renvoyer sRes
      sinon
      	ErreurDéclenche(ErreurDeConverion,<§@1b155a2803bc06420048§>)
      fin
     type : 458752
   -
     name : NumériqueVersBinaire
     procedure_id : 1985675398215708802
     type_code : 15
     code : |1-
      // Résumé : Cette fonction convertit un nombre entier en sa représentation binaire, en ajoutant des zéros à gauche pour atteindre la taille spécifiée.
      // Syntaxe : [ <Résultat> = ] NumériqueVersBinaire (<nValeur> est entier, <nTailleDuCodage> est entier)
      // Paramètres :
      //	nValeur (entier) : Le nombre entier à convertir en binaire.
      //	nTailleDuCodage (entier) : La taille souhaitée du codage binaire. Des zéros seront ajoutés à gauche si nécessaire pour atteindre cette taille.
      // Valeur de retour : chaîne UNICODE : La fonction renvoie une chaîne de caractères représentant le nombre entier en binaire, avec une taille éventuellement ajustée.
      // Exemple :
      // 	NumériqueVersBinaire(10, 8)
      // 	Renvoie "00001010" (la représentation binaire de 10 avec une taille de 8 bits).
      //
      PROCEDURE NumériqueVersBinaire(local nValeur est un entier sur 8 octets,nTailleDuCodage est un entier) : chaine        
      sRésultat 	est une chaîne
      nReste 		est entier sur 8 octets // reste de la division
      
      TANTQUE nValeur>1
      	nReste		= modulo(nValeur,2)
      	sRésultat	= nReste+sRésultat
      	nValeur		= PartieEntière(nValeur/2)
      	SI nValeur=1 ALORS sRésultat="1"+sRésultat
      FIN
      nReste=Taille(sRésultat)
      renvoyer (nReste>nTailleDuCodage ? "" sinon repete("0",nTailleDuCodage-nReste)+sRésultat)
     type : 458752
   -
     name : JSONDécode
     procedure_id : 1986406886827102376
     type_code : 15
     code : |1-
      // Résumé : Cette fonction permet de décoder une chaîne JSON encodée en utilisant des échappements tels que "\uXXXX" pour les caractères Unicode.
      // Syntaxe : [ <Résultat> = ] JSONDécode (<sChaineUnicode> est chaîne)
      // Paramètres :
      //	sChaineUnicode (chaîne UNICODE) : La chaîne JSON à décoder.
      // Valeur de retour : chaîne UNICODE : La fonction renvoie une chaîne de caractères décodée, remplaçant les séquences "\uXXXX" par les caractères correspondants et rétablissant les caractères spéciaux comme les retours à la ligne, les tabulations, les guillemets, etc.
      // Exemple :
      //	JSONDécode("{"key": "\u0048\u0065\u006C\u006C\u006F"}")
      //	Renvoie '{"key": "Hello"}'
      //
      PROCEDURE JSONDécode(LOCAL sChaineUnicode est une chaine) : chaine
      nValNum est un entier
      nPosU est un entier = Position(sChaineUnicode,"\u")
      TANTQUE nPosU
      	nValNum=Val(Milieu(sChaineUnicode,nPosU+2,4),"x")
      	Selon nValNum
      		cas 0 à 30		: // rien car ce sont des caractères non imprimables
      		cas 31 à 127 	: sChaineUnicode=Gauche(sChaineUnicode,nPosU-1)+Caract(nValNum)+Milieu(sChaineUnicode,nPosU+6)
      		AUTRE CAS		: sChaineUnicode=Gauche(sChaineUnicode,nPosU-1)+CaractUnicode(nValNum)+Milieu(sChaineUnicode,nPosU+6)
      	FIN
      	nPosU = Position(sChaineUnicode,"\u",nPosU+1)
      FIN
      sChaineUnicode=Remplace(sChaineUnicode,"\"+cGénérique._Guillemet,cGénérique._Guillemet)
      sChaineUnicode=Remplace(sChaineUnicode,"\r\n",RC)
      sChaineUnicode=Remplace(sChaineUnicode,"\n",Caract(10))
      sChaineUnicode=Remplace(sChaineUnicode,"\t",TAB)
      sChaineUnicode=Remplace(sChaineUnicode,"\\","\")
      sChaineUnicode=Remplace(sChaineUnicode,"\/","/")
      RENVOYER sChaineUnicode
     type : 458752
   -
     name : VariantVersTexte
     procedure_id : 1975670886767452725
     type_code : 15
     code : |1-
      // Résumé : La fonction renvoie une chaîne de caractères représentant la variable Variant sous forme de texte. La fonction utilise une indentation (TAB) pour refléter la structure hiérarchique des tableaux et des objets. (p.e. pour  l'envoi par courriel)
      // Syntaxe : [ <Résultat> = ] ChiffreRomainVersArabe (<sChiffre> est chaîne)
      // Paramètres :
      //	vRéférence (Variant) : La variable Variant à convertir en texte.
      //	nNiveau (entier optionnel) : Niveau d'indentation pour la lisibilité du texte (par défaut, 0).
      //	bValeurSeulement (booléen optionnel) : Indique si seul la valeur des membres doit être affichée (par défaut, Faux).
      // Valeur de retour : chaine UNICODE : La fonction renvoie une chaîne de caractères représentant la variable Variant sous forme de texte.
      // Exemple :
      //	vVariant est un variant
      //	vErreur est un variant
      //	vVariant.ligne1 = "ligne 1"
      //	vErreur.errCode=50
      //	vErreur.errMessage="un message d'erreur"
      //	tableauajoute(vVariant.erreurs,vErreur)
      //	vErreur.errCode=60
      //	vErreur.errMessage="un autre message d'erreur"
      //	tableauajoute(vVariant.erreurs,vErreur)
      //	vVariant.ligne2 = "ligne 2"
      //	info(VariantVersTexte(vVariant))
      //Résultat
      //	"ligne1 = ligne 1
      //	erreurs
      //		errCode = 50
      //		errMessage = un message d'erreur
      //		errCode = 60
      //		errMessage = un autre message d'erreur
      //	ligne2 = ligne 2"
      PROCEDURE VariantVersTexte(vRéférence,nNiveau est un entier = 0,bValeurSeulement est un booleen = faux) : chaine
      sRes est une chaine
      sBufferAnsi est une chaine ansi
      si vRéférence..Type=wlVariantTableau alors	//par exemple une liste d'erreurs
      	sRes+=[RC]+tabVersTexte(vRéférence,nNiveau,bValeurSeulement)
      sinon
      	POUR TOUT mMembre DE vRéférence..Membre
      		SELON mMembre..Type
      			CAS wlVariant : 
      				sRes+=[RC]+VariantVersTexte(mMembre,nNiveau+1)
      			CAS wlVariantTableau,108
      				sRes+=[RC]+Répète(TAB,nNiveau)+mMembre..Nom
      				sRes+=[RC]+tabVersTexte(mMembre,nNiveau+1,bValeurSeulement)
      			CAS wlVariantObjet
      				sRes+=[RC]+VariantVersTexte(mMembre,nNiveau,bValeurSeulement)
      			AUTRE CAS
      				sBufferAnsi=mMembre..Valeur
      				sRes+=[RC]+Répète(TAB,nNiveau)+(bValeurSeulement ? "" sinon mMembre..Nom+" = ")+sBufferAnsi
      		FIN
      	FIN
      FIN
      renvoyer sRes
      
      	procédure interne tabVersTexte(xTableau,nNbTab,bValeur) : chaine
      	sResTab est une chaine
      	POUR n = 1 _a_ xTableau..Occurrence
      		SELON xTableau[n]..Type
      			CAS wlVariant : 
      				sResTab+=[RC]+VariantVersTexte(xTableau[n],nNbTab+1,bValeur)
      			CAS wlVariantTableau,108
      				sResTab+=[RC]+tabVersTexte(xTableau[n],nNbTab,bValeur)
      			cas wlVariantObjet
      				sResTab+=[RC]+VariantVersTexte(xTableau[n],nNbTab,bValeur)
      			AUTRE CAS
      				sResTab+=[RC]+Répète(TAB,nNbTab)+"["+n+"] = "+xTableau[n]
      		FIN
      	FIN
      	renvoyer sResTab
      	FIN
     type : 458752
   -
     name : RomainVersNombre
     procedure_id : 2014691854595944446
     type_code : 15
     code : |1-
      // Résumé : Cette fonction convertit un nombre romain représenté par une chaîne en son équivalent en nombre entier.
      // Syntaxe : [ <Résultat> = ] RomainVersNombre (<sChiffre> est chaîne)
      // Paramètres :
      //	sChiffre (chaîne UNICODE) : La chaîne représentant le nombre romain à convertir.
      // Valeur de retour : entier : Le chiffre romain converti
      // Exemple :
      // 	RomainVersNombre("XIV")
      //	Renvoie 14
      //
      PROCEDURE RomainVersNombre(local sChiffre est une chaine) : entier
      //pas de décimale dans les chiffres romains si de valeur dépassant 4000
      i est un entier
      sChiffre=Remplace(sChiffre," ","")
      si sChiffre~="" alors renvoyer 0
      nCar1,nCar2,nRes sont des entiers
      sChiffresArabes est une chaine = "1"+Tab+"5"+tab+"10"+tab+"50"+tab+"100"+tab+"500"+tab+"1000"
      sChiffresRomains est une chaine = "IVXLCDM"
      POUR i=1 _A_ Taille(sChiffre)
      	si Position(sChiffresRomains,sChiffre[[i]])>0 alors nCar1=Val(ExtraitChaîne(sChiffresArabes,Position(sChiffresRomains,sChiffre[[i]]))) sinon nCar1=0
      	SI nCar1=0 alors ErreurDéclenche(ErreurDeConverion,ChaîneConstruit(<§@1b155a2803bc06420042§>,sChiffre[[i]]));RENVOYER 0
      	si i<taille(sChiffre) alors
      		si Position(sChiffresRomains,sChiffre[[i+1]])>0 alors nCar2=Val(ExtraitChaîne(sChiffresArabes,Position(sChiffresRomains,sChiffre[[i+1]]))) sinon nCar2=0
      		si nCar2=0 ALORS ErreurDéclenche(ErreurDeConverion,ChaîneConstruit(<§@1b155a2803bc06420042§>,sChiffre[[i+1]]));RENVOYER 0
      		SI nCar2>nCar1 ALORS nRes+=(nCar2-nCar1);i++ SINON nRes+=nCar1
      	sinon
      		nRes+=nCar1
      	fin
      FIN
      RENVOYER nRes
     type : 458752
   -
     name : DateUnixVersWD
     procedure_id : 2014691923315502708
     type_code : 15
     group : 5
     code : |1-
      // Résumé : Cette fonction convertit un nombre de secondes depuis l'époque UNIX (1er janvier 1970) en une chaîne de caractères représentant la date et l'heure au format "JJ/MM/AAAA HH:MM:SS".
      //	Cette fonction est particulièrement utile lorsqu'on travaille avec des dates en provenance de sources utilisant le format UNIX timestamp, comme c'est souvent le cas dans le contexte du langage PHP.
      // Syntaxe : [ <Résultat> = ] DatePHPVersWD (<nNbsec> est entier)
      // Paramètres :
      //	nNbsec (entier) : Le nombre de secondes depuis l'époque UNIX à convertir.
      // Valeur de retour : dateHeure : La fonction renvoie une chaîne de caractères représentant la date et l'heure au format
      // Exemple :
      // 	DatePHPVersWD(1609459200)
      //	Renvoie "20210101000000"
      //
      PROCEDURE DateUnixVersWD(nNbsec est un entier) : dateheure
      //ref : code publié par Emmanuel Haefelé sur http://windev.dev4u.org
      si nNbsec<0 alors ErreurDéclenche(ErreurDeConverion,<§@1b155a2803bc06420043§>);renvoyer ""
      isec est un entier sur 8 = nNbsec+5364748800
      dDate	est une Date 	= EntierVersDate(isec/86400 )
      hHeure	est une Heure 	= EntierVersHeure(100*modulo(isec,86400))
      RENVOYER (dDate+hHeure)
     type : 458752
   -
     name : DateWDVersUnix
     procedure_id : 2014691961970348789
     type_code : 15
     group : 5
     code : |1-
      // Résumé : Cette fonction convertit une date et heure au format WinDev en un nombre d'entiers représentant le nombre de secondes écoulées depuis l'époque UNIX (1er janvier 1970).
      //	Cette fonction est utile lorsque vous devez manipuler des dates dans un contexte où le format UNIX timestamp est utilisé, comme dans le langage PHP.
      // Syntaxe : [ <Résultat> = ] DateWDVersPHP (<dhWD> est dateheure [, <nValeurRetourSiInvalide> est entier])
      // Paramètres :
      //	dhWD (dateheure) : La date et l'heure au format WinDev à convertir.
      // 	nValeurRetourSiInvalide (entier, optionnel) : La valeur à renvoyer en cas de date invalide. Par défaut, la valeur est 0.
      // Valeur de retour : entier : La fonction renvoie un entier représentant le nombre de secondes écoulées depuis l'époque UNIX (1er janvier 1970) jusqu'à la date et l'heure fournies.
      // Exemple :
      // 	DateWDVersUnix("20210101000000")
      //	Renvoie 1609459200
      //
      PROCEDURE DateWDVersUnix(dhWD est une DateHeure,nValeurRetourSiInvalide est un entier=0) : entier
      //ref : code publié à l'origine par Emmanuel Haefelé sur http://windev.dev4u.org
      si pas DateHeureValide(dhWD) alors ErreurDéclenche(ErreurDeConverion,<§@1b155a2803bc06420044§>);renvoyer nValeurRetourSiInvalide
      nDate	est un entier sur 8 octets = DateVersEntier(dhWD..PartieDate)*86400
      nJour 	est un entier sur 8 octets = HeureVersEntier(dhWD..partieheure)/100
      RENVOYER nDate + nJour - 5364748800
     type : 458752
   -
     name : MètreVersPiedPouce
     procedure_id : 2014692223963545227
     type_code : 15
     group : 1
     code : |1-
      // Résumé : Cette fonction convertit une valeur de longueur en mètres en une chaîne de format "nPieds'nPouces". La conversion est basée sur la conversion entre les unités de mètres, pieds et pouces.
      // Syntaxe : [ <Résultat> = ] MètreVersPiedPouce (<sValeur> est chaîne)
      // Paramètres :
      //	rValeur (réel) : La valeur en mètres à convertir en format "nPieds'nPouces".
      // Valeur de retour : chaîne UNICODE : La fonction renvoie une chaîne représentant la valeur convertie en pieds et pouces.
      // Exemple :
      //	MètreVersPiedPouce("1.83")
      //	Renvoie "6'0"
      //
      PROCEDURE MètreVersPiedPouce(rValeur est un réel) : chaine
      rRésultat est un réel = COL_Conversion.ConvertiLongueur(rValeur,Mètre,Pied)
      RENVOYER PartieEntière(rRésultat)+"'"+Arrondi(PartieDécimale(rRésultat)*12,0)		//format nPieds'nPouces
     type : 458752
   -
     name : PhonétiqueFrançais
     procedure_id : 2014692223963611121
     type_code : 15
     code : |1-
      // Résumé : Contrairement à la fonction Phonétique() plutôt anglophone, cette fonction génère une version phonétique française d'une chaîne de caractères donnée. La phonétique est basée sur une série de règles de transformation visant à approximer la prononciation en français.
      // Syntaxe : [ <Résultat> = ] PhonétiqueFrançais (<sValeur> est chaîne)
      // Paramètres :
      //	sValeur (chaîne UNICODE) : La chaîne de caractères pour laquelle la phonétique française doit être générée.
      // Valeur de retour : chaîne UNICODE : La fonction renvoie une chaîne représentant la version phonétique française de la chaîne d'entrée.
      // Exemple :
      //	PhonétiqueFrançais("Bonjour")
      //	Renvoie "fong3r"
      //
      PROCEDURE PhonétiqueFrançais(LOCAL sValeur est une chaîne) : chaine	//fonction pas dispo en Java
      //ref : http://www.trickytools.com/php/phonex.php
      si sValeur~="" alors renvoyer ""
      sTemp,sRes,sMot est une chaîne
      n 				est un entier
      	
      POUR TOUTE CHAÎNE sMot DE sValeur SEPAREE PAR " "
      	//R1
      	sMot=Minuscule(sMot)
      	sMot=remplace(sMot,["à","â","ä"],"a")
      	sMot=Remplace(sMot,["é","è","ê","ë"],"e")
      	sMot=Remplace(sMot,["ì","î""ï"],"i")
      	sMot=Remplace(sMot,["ò","ô","ö"],"o")
      	sMot=Remplace(sMot,["ù","û","ü"],"u")
      	sMot=Remplace(sMot,"ÿ","i")
      	sMot=Remplace(sMot,"ç","ss")
      	//R1' : enlever tous les caractères spéciaux
      	sTemp=""
      	POUR n = 1 _À_ Taille(sMot)
      		SI 96<Asc(sMot[[n]])<123 ALORS sTemp+=sMot[[n]]
      	FIN
      	sMot=sTemp
      	//R2
      	sMot=Remplace(sMot,"ph","f")
      	//R3
      	sMot=Remplace(Remplace(Remplace(Remplace(Remplace(sMot,"ch","*"),"sh","+"),"h",""),"*","ch"),"+","sh")
      	//R4
      	sMot=Remplace(Remplace(Remplace(Remplace(sMot,"gan","kan"),"gam","kam"),"gain","kain"),"gaim","kaim")
      	//R5
      	sMot=Remplace(sMot,["aina","eina","aima","eima"],"yna")
      	sMot=Remplace(sMot,["aine","eine","aime","eime"],"yne")
      	sMot=Remplace(sMot,["aini","eini","aimi","eimi"],"yni")
      	sMot=Remplace(sMot,["aino","eino","aimo","eimo"],"yno")
      	sMot=Remplace(sMot,["ainu","einu","aimu","eimu"],"ynu")
      	//R6
      	sMot=Remplace(sMot,"eau","o")
      	sMot=Remplace(sMot,"oua","2")
      	sMot=Remplace(sMot,["ein","ain"],"4")
      	//R7
      	sMot=Remplace(sMot,["ai","ei","ee"],"y")
      	sMot=Remplace(sMot,"er","yr")
      	sMot=Remplace(sMot,"ess","yss")
      	sMot=Remplace(sMot,"et","yt")
      	sMot=Remplace(sMot,"ez","yz")
      	//R8
      	SI Taille(sMot)>1 ALORS
      		sTemp=sMot[[1]]
      		POUR n = 2 _À_ Taille(sMot)
      			SI sMot[[n]]<>sMot[[n-1]] ALORS sTemp+=sMot[[n]]
      		FIN
      		sMot=sTemp
      	FIN
      	//R9
      	POUR TOUTE CHAÎNE sSousChaine DE "an"+TAB+"am"+TAB+"en"+TAB+"em"
      		n=Position(sMot,sSousChaine)
      		TANTQUE n>0
      			SI n>0 _ET_ Position("aeiouy1234",sMot[[n+1]])<1 ALORS sMot=Gauche(sMot,n-1)+"1"+Milieu(sMot,n+2)
      			n=Position(sMot,sSousChaine,n+1)
      		FIN
      	FIN
      	n=Position(sMot,"in")
      	TANTQUE n>0
      		SI n>0 _ET_ Position("aeiouy1234",sMot[[n+1]])<1 ALORS sMot=Gauche(sMot,n-1)+"1"+Milieu(sMot,n+2)
      		n=Position(sMot,"in",n+1)
      	FIN
      	//R10
      	SI sMot[[1]]="z" ALORS sMot="s"+Milieu(sMot,2)
      	n=Position(sMot,"z")
      	TANTQUE n>0
      		SI Position("aeiouy1234",sMot[[n-1]])>0 _OU_ Position("aeiouy1234",sMot[[n+1]])>0 ALORS sMot[[n]]="s"
      		n=Position(sMot,"z",n+1)
      	FIN
      	//R11
      	sMot=Remplace(sMot,["oe","eu"],"e")
      	sMot=Remplace(sMot,"au","o")
      	sMot=Remplace(sMot,"oi","2")
      	sMot=Remplace(sMot,"ou","3")
      	//R12
      	sMot=Remplace(sMot,["sch","ch","sh"],"5")
      	sMot=Remplace(sMot,"ss","s")
      	sMot=Remplace(sMot,"sci","si")
      	sMot=Remplace(sMot,"sce","se")
      	//R13
      	sMot=Remplace(sMot,"ci","si")
      	sMot=Remplace(sMot,"ce","se")
      	//R14
      	sMot=Remplace(sMot,["c","qu","q"],"k")
      	sMot=Remplace(sMot,"gu","ku")
      	sMot=Remplace(sMot,"ga","ka")
      	sMot=Remplace(sMot,"go","ko")
      	//R15
      	sMot=Remplace(sMot,"a","o")
      	sMot=Remplace(sMot,["d","p"],"t")
      	sMot=Remplace(sMot,"j","g")
      	sMot=Remplace(sMot,["b","v"],"f")
      	sMot=Remplace(sMot,"m","n")
      	//R16
      	sMot=Remplace(sMot,"y","e")
      	//R17
      	SI Droite(sMot,1) DANS ("t","x","s","z") ALORS sMot=Gauche(sMot,Taille(sMot)-1)
      	//R18
      	SI Taille(sMot)>1 ALORS
      		sTemp=sMot[[1]]
      		POUR n = 2 _À_ Taille(sMot)
      			SI sMot[[n]]<>sMot[[n-1]] ALORS sTemp+=sMot[[n]]
      		FIN
      		sMot=sTemp
      	FIN
      	//R19
      	sTemp=""
      	POUR n = 1 _À_ Taille(sMot)
      		SI Position("12345efghiklnorstuwxyz",sMot[[n]])>0 ALORS sTemp+=sMot[[n]]
      	FIN
      	sRes+=[" "]+sMot
      FIN
      RENVOYER sRes
     type : 458752
   -
     name : PiedPouceVersMètre
     procedure_id : 2014692228258710628
     type_code : 15
     group : 1
     code : |1-
      // Résumé : Cette fonction convertit une valeur de longueur exprimée en pieds et pouces en mètres. La chaîne d'entrée doit être dans le format nPieds'nPouces.
      // Syntaxe : [ <Résultat> = ] PiedPouceVersMètre (<sValeur>)
      // Paramètres :
      // 	sValeur : La chaîne représentant la valeur de longueur en pieds et pouces à convertir en mètres.
      // Valeur de retour : réel : La fonction renvoie un nombre réel représentant la valeur de longueur convertie en mètres.
      // Exemple :
      //	PiedPouceVersMètre("5'6")
      //	Renvoie 1.68
      //
      PROCEDURE PiedPouceVersMètre(sValeur est une chaine) : réel
      RENVOYER Arrondi((Val(ExtraitChaîne(sValeur,1,"'"))+Val(ExtraitChaîne(sValeur,2,"'"))/12)*EUnitéLongueur.Pied..valeur,2)	//la valeur arrive en nPieds'nPouces
     type : 458752
   -
     name : ConvertiLongueur
     procedure_id : 2014714075711168988
     type_code : 15
     group : 1
     code : |1-
      // Résumé : Cette fonction convertit une valeur de longueur d'une unité à une autre, avec la possibilité de spécifier des multiplicateurs pour chaque unité. Les unités de longueur et les multiplicateurs peuvent être définis à l'aide des énumérations EUnitéLongueur et EMultiplicateur respectivement.
      //	La différence avec la fonction Conversion() est qu'on peut spécifier ici le multiplicateur, les unités et multiplicateurs sont des énumérations et non des chaines (qui peuvent introduire un risque d'erreur), il y a plus de conversions possibles (et vous pouvez en ajouter) et vous pouvez vérifier/modifier le facteur entre deux unités.
      // Syntaxe : [ <Résultat> = ] ConvertiLongueur (<rValeur> est réel, <eUnitéDépart> est COL_Conversion.EUnitéLongueur [, <eUnitéFinale> est COL_Conversion.EUnitéLongueur [, <eMultiplicateurDépart> est COL_Conversion.EMultiplicateur [, <eMultiplicateurFinal> est COL_Conversion.EMultiplicateur [, <nArrondi> est entier]]]])
      // Paramètres :
      //	rValeur (réel) : La valeur de longueur à convertir.
      //	eUnitéDépart (COL_Conversion.EUnitéLongueur) : L'unité de départ de la valeur de longueur.
      //	eUnitéFinale (COL_Conversion.EUnitéLongueur optionnel) : L'unité finale dans laquelle la valeur de longueur doit être convertie (par défaut, en mètres).
      //	eMultiplicateurDépart (COL_Conversion.EMultiplicateur optionnel) : Le multiplicateur associé à l'unité de départ (par défaut, aucun).
      //	eMultiplicateurFinal (COL_Conversion.EMultiplicateur optionnel) : Le multiplicateur associé à l'unité finale (par défaut, aucun).
      // 	nArrondi (entier optionnel) : Le nombre de décimales auquel arrondir le résultat (par défaut, -1 signifie aucun arrondi).
      // Valeur de retour : réel : La fonction renvoie un nombre réel représentant la valeur de longueur convertie dans l'unité finale spécifiée.
      // Exemple :
      // 	rResultat est un réel = ConvertiLongueur(10, EUnitéLongueur.Pied, EUnitéLongueur.Mètre)
      //	rRésultat contient la valeur 3.48
      //
      PROCEDURE ConvertiLongueur(local rValeur est un réel,eUnitéDépart est EUnitéLongueur,eUnitéFinale est un EUnitéLongueur = Mètre,eMultiplicateurDépart est un EMultiplicateur = EMultiplicateur.Aucun,eMultiplicateurFinal est un EMultiplicateur = EMultiplicateur.Aucun,nArrondi est un entier=-1) : réel
      RENVOYER ConvertiUnité(rValeur,eUnitéDépart..valeur,eUnitéFinale..Valeur,eMultiplicateurDépart..Valeur,eMultiplicateurFinal..Valeur,nArrondi)
     type : 458752
   -
     name : UnitéVersNom
     procedure_id : 2014715845237779758
     type_code : 15
     group : 1
     code : |1-
      // Résumé : Cette fonction convertit une unité spécifiée (représentée par l'énumération xUnité) en une chaîne de caractères représentant le nom de l'unité.
      // Syntaxe : [ <Résultat> = ] UnitéVersNom (<xUnité>)
      // Paramètres :
      // 	xUnité : Un paramètre représentant une unité définie par les énumérations associées à chaque type d'unité (longueur, masse, temps, etc.).
      // Valeur de retour : chaîne UNICODE : La fonction renvoie une chaîne de caractères représentant le nom de l'unité spécifiée.
      // Exemple :
      //	sNomUnité est une chaîne = UnitéVersNom(EUnitéLongueur.Mètre)
      //	sNomUnité contiendra "mètre" en français et "meter" en anglais
      //
      PROCEDURE UnitéVersNom(xUnité) : chaine
      quand exception dans
      	selon xUnité..nom
      		cas EUnitéLongueur.Mètre..Nom														: renvoyer <§@1b155a2803bc06420002§>
      		CAS EUnitéLongueur.Angström..Nom													: renvoyer "Angström"
      		CAS EUnitéLongueur.UnitéAstronomique..Nom											: RENVOYER <§@1b155a2803bc06420003§>
      		CAS EUnitéLongueur.AnnéeLumière..Nom												: RENVOYER <§@1b155a2803bc06420004§>
      		CAS EUnitéLongueur.Pied..Nom														: RENVOYER <§@1b155a2803bc06420005§>
      		CAS EUnitéLongueur.Pouce..Nom														: RENVOYER <§@1b155a2803bc06420006§>
      		CAS EUnitéLongueur.MilleInternational..Nom											: RENVOYER <§@1b155a2803bc06420007§>
      		CAS EUnitéLongueur.Verge..Nom														: RENVOYER <§@1b155a2803bc06420008§>
      		cas EUnitéAccélération.MètreParSecondeCarré..Nom									: renvoyer <§@1b155a2803bc0642000a§>
      		CAS EUnitéAccélération.GravitéTerrestre..Nom										: renvoyer <§@1b155a2803bc06420009§>
      		CAS EUnitéAccélération.Gal..Nom														: renvoyer "gal"	
      		cas EUnitéAngle.Radian..Nom															: renvoyer "radian"
      		CAS EUnitéAngle.Gradian..Nom														: renvoyer "grade"
      		CAS EUnitéAngle.Degré..Nom															: renvoyer <§@1b155a2803bc0642000b§>
      		CAS EUnitéAngle.Minutearc..Nom,EUnitéDurée.minute..Nom,EUnitéFréquence.Minute..Nom 	: renvoyer "minute"
      		CAS EUnitéAngle.Secondearc..Nom,EUnitéDurée.Seconde..Nom							: renvoyer <§@1b155a2803bc0642000c§>
      		cas EUnitéDurée.Heure..Nom,EUnitéFréquence.heure..Nom 								: renvoyer <§@1b155a2803bc0642000d§>
      		cas EUnitéForce.Newton..Nom															: renvoyer "newton"
      		CAS EUnitéForce.Dyne..Nom															: renvoyer "dyne"
      		CAS EUnitéForce.LivreForce..Nom														: renvoyer <§@1b155a2803bc0642000e§>
      		CAS EUnitéForce.KilogrammeForce..Nom												: renvoyer <§@1b155a2803bc0642000f§>
      		cas EUnitéFréquence.Hertz..Nom														: renvoyer "hertz"
      		CAS EUnitéFréquence.Jour..Nom														: renvoyer <§@1b155a2803bc06420010§>
      		cas	EUnitéMasse.Kilogramme..Nom														: renvoyer <§@1b155a2803bc06420011§>
      		CAS	EUnitéMasse.Tonne..Nom															: renvoyer <§@1b155a2803bc06420012§>
      		CAS	EUnitéMasse.Quintal..Nom														: renvoyer "quintal"
      		CAS	EUnitéMasse.Livre..Nom															: renvoyer <§@1b155a2803bc06420013§>
      		CAS	EUnitéMasse.LivreImpériale..Nom													: renvoyer <§@1b155a2803bc06420014§>
      		CAS	EUnitéMasse.OnceImpériale..Nom													: renvoyer <§@1b155a2803bc06420015§>
      		CAS	EUnitéMasse.Carat..Nom															: renvoyer "carat"
      		cas EUnitéPression.Pascal_..Nom														: renvoyer "pascal"
      		CAS EUnitéPression.Bar..Nom															: renvoyer "bar"
      		CAS EUnitéPression.NewtonParMètreCarré..Nom											: renvoyer <§@1b155a2803bc06420016§>
      		CAS EUnitéPression.LivreParPouceCarré..Nom											: renvoyer <§@1b155a2803bc06420017§>	
      		CAS EUnitéPression.AtmosphèreTechnique..Nom 										: renvoyer <§@1b155a2803bc06420018§>
      		CAS EUnitéPression.AtmosphèrePhysique..Nom											: renvoyer <§@1b155a2803bc06420019§>
      		CAS EUnitéPression.MilliMètreMercure..Nom											: renvoyer <§@1b155a2803bc0642001a§>
      		cas EUnitéPuissance.Watt..Nom														: renvoyer "watt"
      		CAS EUnitéPuissance.ChevalVapeur..Nom												: renvoyer <§@1b155a2803bc0642001b§>
      		CAS EUnitéPuissance.ChevalVapeurUS..Nom												: renvoyer <§@1b155a2803bc0642001c§>
      		cas	EUnitéSurface.MètreCarré..Nom													: renvoyer <§@1b155a2803bc0642001d§>
      		CAS	EUnitéSurface.Hectare..Nom 														: renvoyer "hectare"
      		CAS	EUnitéSurface.are_..Nom															: renvoyer "are"		
      		CAS	EUnitéSurface.centiare..Nom														: renvoyer "centiare"	
      		CAS	EUnitéSurface.PiedCarré..Nom													: renvoyer <§@1b155a2803bc0642001f§>
      		CAS	EUnitéSurface.PouceCarré..Nom													: renvoyer <§@1b155a2803bc06420020§>
      		cas EUnitéTempérature.Kelvin..Nom													: renvoyer "kelvin"
      		CAS EUnitéTempérature.Celsius..Nom													: renvoyer "celsius"		
      		CAS EUnitéTempérature.Fahrenheit..Nom												: renvoyer "fahrenheit"
      		CAS EUnitéTempérature.Réaumur..Nom													: renvoyer "réaumur"
      		CAS EUnitéTempérature.Rankine..Nom													: renvoyer "rankine"
      		cas EUnitéVitesse.MètreParSeconde..Nom												: renvoyer <§@1b155a2803bc06420021§>
      		CAS EUnitéVitesse.MètreParMinute..Nom												: renvoyer <§@1b155a2803bc06420022§>
      		CAS EUnitéVitesse.KilomètreParSeconde..Nom											: renvoyer <§@1b155a2803bc06420023§>
      		CAS EUnitéVitesse.MileParSeconde..Nom												: renvoyer <§@1b155a2803bc06420024§>
      		CAS EUnitéVitesse.MileParHeure..Nom													: renvoyer <§@1b155a2803bc06420025§>
      		CAS EUnitéVitesse.PiedParSeconde..Nom												: renvoyer <§@1b155a2803bc06420026§>
      		CAS EUnitéVitesse.PiedParMinute..Nom												: renvoyer <§@1b155a2803bc06420027§>
      		CAS EUnitéVitesse.MinuteParKilomètre..Nom											: renvoyer <§@1b155a2803bc06420028§>
      		CAS EUnitéVitesse.noeud..Nom														: renvoyer <§@1b155a2803bc06420029§>
      		CAS EUnitéVitesse.MileNautiqueParHeure..Nom											: renvoyer <§@1b155a2803bc0642002a§>
      		CAS EUnitéVitesse.VitesseLumière..Nom												: renvoyer <§@1b155a2803bc0642002b§>
      		CAS EUnitéVitesse.Mach..Nom 														: renvoyer "mach"
      		cas EUnitéVolume.MètreCube..Nom														: renvoyer <§@1b155a2803bc0642002c§>
      		CAS EUnitéVolume.Litre..Nom															: renvoyer <§@1b155a2803bc0642002d§>
      		CAS EUnitéVolume.PiedCube..Nom														: renvoyer <§@1b155a2803bc0642002e§>
      		CAS EUnitéVolume.PouceCube..Nom														: renvoyer <§@1b155a2803bc0642002f§>
      		CAS EUnitéVolume.GallonImpérial..Nom												: renvoyer <§@1b155a2803bc06420030§>
      		CAS EUnitéVolume.Pinte..Nom															: renvoyer <§@1b155a2803bc06420031§>
      		CAS EUnitéVolume.Baril..Nom															: renvoyer <§@1b155a2803bc06420032§>	
      		cas EUnitéÉnergie.Joule..Nom														: renvoyer "joule"
      		CAS EUnitéÉnergie.Calorie..Nom														: renvoyer "calorie"
      		CAS EUnitéÉnergie.KiloWattHeure..Nom												: renvoyer "kilowatt heure"
      		CAS EUnitéÉnergie.WattSeconde..Nom													: renvoyer "watt seconde"
      		CAS EUnitéÉnergie.Pascal_..Nom														: renvoyer "pascal"
      		CAS EUnitéÉnergie.ElectronVolt..Nom													: renvoyer "électron volt"
      		cas EUnitéInformatique.bit..Nom														: renvoyer "bit"
      		CAS EUnitéInformatique.octet_..Nom													: renvoyer <§@1b155a2803bc06420033§>
      		autres cas																			: renvoyer ""
      	fin
      FAIRE
      	ErreurDéclenche(ErreurDeConverion,<§@1b155a2803bc06420057§>);renvoyer ""
      FIN	
     type : 458752
   -
     name : MultiplicateurVersNom
     procedure_id : 2014719843852410834
     type_code : 15
     group : 1
     code : |1-
      // Résumé : Cette fonction convertit un multiplicateur spécifié (représenté par l'énumération xMultiplicateur) en une chaîne de caractères représentant le nom du multiplicateur. Les multiplicateurs sont généralement utilisés pour définir des unités plus petites ou plus grandes que les unités de base.
      // Syntaxe : [ <Résultat> = ] MultiplicateurVersNom (<xMultiplicateur>)
      // Paramètres :
      // 	xMultiplicateur : Un paramètre représentant un multiplicateur défini par l'énumération EMultiplicateur ou EMultiInformatique.
      // Valeur de retour : chaîne UNICODE : La fonction renvoie une chaîne de caractères représentant le nom du multiplicateur spécifié.
      // Exemple :
      //	sNomMultiplicateur est une chaîne = MultiplicateurVersNom(EMultiplicateur.kilo)
      //	sNomMultiplicateur contiendra "kilo"
      //
      PROCEDURE MultiplicateurVersNom(xMultiplicateur) : chaine
      selon xMultiplicateur
      	CAS EMultiplicateur.yotta				: RENVOYER "yotta"
      	CAS EMultiplicateur.zetta				: RENVOYER "zetta"
      	CAS EMultiplicateur.exa					: RENVOYER "exa"
      	cas EMultiplicateur.peta				: renvoyer "peta"
      	CAS EMultiplicateur.tera				: RENVOYER "tera"
      	CAS EMultiplicateur.giga				: RENVOYER "giga"
      	CAS EMultiplicateur.mega				: RENVOYER "mega"
      	CAS EMultiplicateur.kilo				: RENVOYER "kilo"
      	CAS EMultiplicateur.hecto				: RENVOYER "hecto"
      	CAS EMultiplicateur.déca				: RENVOYER "déca"
      	CAS EMultiplicateur.aucun				: RENVOYER ""
      	CAS EMultiplicateur.déci				: RENVOYER "déci"
      	CAS EMultiplicateur.centi				: RENVOYER "centi"
      	CAS EMultiplicateur.milli				: RENVOYER "milli"
      	CAS EMultiplicateur.micro				: RENVOYER "micro"
      	CAS EMultiplicateur.nano				: RENVOYER "nano"
      	CAS EMultiplicateur.pico				: RENVOYER "pico"
      	CAS EMultiplicateur.femto				: RENVOYER "femto"
      	CAS EMultiplicateur.atto				: RENVOYER "atto"
      	CAS EMultiplicateur.zepto				: RENVOYER "zepto"
      	CAS EMultiplicateur.yocto				: RENVOYER "yocto"
      	CAS EMultiInformatique.yotta			: RENVOYER "yotta"
      	CAS EMultiInformatique.zetta			: RENVOYER "zetta"
      	CAS EMultiInformatique.exa				: RENVOYER "exa"
      	cas EMultiInformatique.peta				: renvoyer "peta"
      	CAS EMultiInformatique.tera				: RENVOYER "tera"
      	CAS EMultiInformatique.giga				: RENVOYER "giga"
      	CAS EMultiInformatique.mega				: RENVOYER "mega"
      	CAS EMultiInformatique.kilo				: RENVOYER "kilo"
      	cas	EMultiInformatique.Aucun 			: renvoyer ""
      	autres cas								: renvoyer ""
      fin
     type : 458752
   -
     name : ConvertiAccélération
     procedure_id : 2014723456008303587
     type_code : 15
     group : 1
     code : |1-
      // Résumé : Cette fonction permet de convertir une valeur d'accélération d'une unité à une autre. Elle prend en compte les unités de départ et d'arrivée, ainsi que les multiplicateurs associés, fournissant ainsi une flexibilité dans les conversions.
      //	La différence avec la fonction Conversion() est qu'on peut spécifier ici le multiplicateur, les unités et multiplicateurs sont des énumérations et non des chaines (qui peuvent introduire un risque d'erreur), il y a plus de conversions possibles (et vous pouvez en ajouter) et vous pouvez vérifier/modifier le facteur entre deux unités.
      // Syntaxe : [ <Résultat> = ] ConvertiAccélération (<rValeur> est réel, <eUnitéDépart> est COL_Conversion.EUnitéAccélération [, <eUnitéFinale> est COL_Conversion.EUnitéAccélération [, <eMultiplicateurDépart> est COL_Conversion.EMultiplicateur [, <eMultiplicateurFinal> est COL_Conversion.EMultiplicateur [, <nArrondi> est entier]]]])
      // Paramètres :
      //	rValeur (réel) : La valeur de longueur à convertir.
      //	eUnitéDépart (COL_Conversion.EUnitéAccélération) : L'unité de départ de la valeur de longueur.
      //	eUnitéFinale (COL_Conversion.EUnitéAccélération) : L'unité finale dans laquelle la valeur d'accélération doit être convertie (par défaut, en mètres par seconde).
      //	eMultiplicateurDépart (COL_Conversion.EMultiplicateur optionnel) : Le multiplicateur associé à l'unité de départ (par défaut, aucun).
      //	eMultiplicateurFinal (COL_Conversion.EMultiplicateur optionnel) : Le multiplicateur associé à l'unité finale (par défaut, aucun).
      // 	nArrondi (entier optionnel) : Le nombre de décimales auquel arrondir le résultat (par défaut, -1 signifie aucun arrondi).
      // Valeur de retour : réel : La fonction renvoie un nombre réel représentant la valeur de l'accélération convertie dans l'unité finale spécifiée.
      // Exemple :
      //	rAccélérationEnG est un réel = ConvertiAccélération(9.81, EUnitéAccélération.MètreParSecondeCarré, EUnitéAccélération.GravitéTerrestre)
      //	rAccélérationEnG contiendra 1
      //
      PROCEDURE ConvertiAccélération(LOCAL rValeur est un réel,eUnitéDépart est EUnitéAccélération,eUnitéFinale est un EUnitéAccélération = MètreParSecondeCarré,eMultiplicateurDépart est un EMultiplicateur = EMultiplicateur.Aucun,eMultiplicateurFinal est un EMultiplicateur = EMultiplicateur.Aucun,nArrondi est un entier=-1) : reel
      renvoyer ConvertiUnité(rValeur,eUnitéDépart..Valeur,eUnitéFinale..valeur,eMultiplicateurDépart..valeur,eMultiplicateurFinal..Valeur,nArrondi)
     type : 458752
   -
     name : ConvertiUnité
     procedure_id : 2014723632102003845
     type_code : 15
     group : 1
     code : |1-
      // Résumé : Fonction privée permettant de coder facilement toutes les autres conversions
      PROCEDURE privé ConvertiUnité(rValeur est un réel,xUnitéDépart,xUnitéFinale,xMultiplicateurDépart,xMultiplicateurFinal,nArrondi) : reel
      //ref : https://fr.wikipedia.org/wiki/Unit%C3%A9s_d%C3%A9riv%C3%A9es_du_Syst%C3%A8me_international 
      SI xUnitéDépart<>xUnitéFinale ALORS rValeur=(rValeur*xUnitéDépart)/xUnitéFinale
      SI xMultiplicateurDépart<>xMultiplicateurFinal ALORS rValeur=rValeur*xMultiplicateurDépart/xMultiplicateurFinal
      si nArrondi<0 alors renvoyer rValeur sinon renvoyer wl.arrondi(rValeur,nArrondi)
     type : 458752
   -
     name : ConvertiAngle
     procedure_id : 2014731801129868074
     type_code : 15
     group : 1
     code : |1-
      // Résumé : Cette fonction permet de convertir une valeur d'angle d'une unité à une autre. Elle prend en compte les unités de départ et d'arrivée, fournissant ainsi une flexibilité dans les conversions.
      //	La différence avec la fonction Conversion() est qu'on peut spécifier ici le multiplicateur, les unités et multiplicateurs sont des énumérations et non des chaines (qui peuvent introduire un risque d'erreur), il y a plus de conversions possibles (et vous pouvez en ajouter) et vous pouvez vérifier/modifier le facteur entre deux unités.
      // Syntaxe : [ <Résultat> = ] ConvertiAngle (<rValeur> est réel, <eUnitéDépart> est COL_Conversion.EUnitéAngle [, <eUnitéFinale> est COL_Conversion.EUnitéAngle [, <nArrondi> est entier]])
      // Paramètres :
      //	rValeur (réel) : Un paramètre réel représentant la valeur de l'angle à convertir.
      //	eUnitéDépart (COL_Conversion.EUnitéAngle) : Un paramètre de l'énumération EUnitéAngle représentant l'unité d'angle de départ.
      //	eUnitéFinale (COL_Conversion.EUnitéAngle optionnel) : Un paramètre de l'énumération EUnitéAngle représentant l'unité d'angle finale. Par défaut, il est défini sur Radian.
      // 	nArrondi (entier optionnel) : Un entier permettant de spécifier le nombre de décimales à conserver dans le résultat. Si non spécifié, la fonction n'effectuera pas d'arrondi.
      // Valeur de retour :
      // 	réel : La fonction renvoie la valeur d'angle convertie.
      // Exemple :
      //	rAngleEnRadian est un réel = ConvertiAngle(90, EUnitéAngle.Degré, EUnitéAngle.Radian)
      //	rAngleEnRadian contiendra
      //
      PROCEDURE ConvertiAngle(LOCAL rValeur est un réel,eUnitéDépart est EUnitéAngle,eUnitéFinale est un EUnitéAngle = Radian,nArrondi est un entier=-1) : reel
      RENVOYER ConvertiUnité(rValeur,eUnitéDépart..Valeur,eUnitéFinale..Valeur,1,1,nArrondi)
     type : 458752
   -
     name : ConvertiDurée
     procedure_id : 2014731835489679512
     type_code : 15
     group : 1
     code : |1-
      // Résumé : Cette fonction permet de convertir une valeur de durée d'une unité à une autre. Elle prend en compte les unités de départ et d'arrivée, fournissant ainsi une flexibilité dans les conversions.
      //	La différence avec la fonction Conversion() est qu'on peut spécifier ici le multiplicateur, les unités et multiplicateurs sont des énumérations et non des chaines (qui peuvent introduire un risque d'erreur), il y a plus de conversions possibles (et vous pouvez en ajouter) et vous pouvez vérifier/modifier le facteur entre deux unités.
      // Syntaxe : [ <Résultat> = ] ConvertiDurée (<rValeur> est réel, <eUnitéDépart> est COL_Conversion.EUnitéDurée [, <eUnitéFinale> est COL_Conversion.EUnitéDurée [, <nArrondi> est entier]])
      // Paramètres :
      //	rValeur (réel) : Un paramètre réel représentant la valeur de la durée à convertir.
      //	eUnitéDépart (COL_Conversion.EUnitéDurée) : Un paramètre de l'énumération EUnitéDurée représentant l'unité de durée de départ.
      //	eUnitéFinale (COL_Conversion.EUnitéDurée optionnel) : Un paramètre de l'énumération EUnitéDurée représentant l'unité de durée finale. Par défaut, il est défini sur Seconde.
      // 	nArrondi (entier optionnel) : Un entier permettant de spécifier le nombre de décimales à conserver dans le résultat. Si non spécifié, la fonction n'effectuera pas d'arrondi.
      // Valeur de retour : réel : La fonction renvoie la valeur de durée convertie.
      // Exemple :
      //	rDuréeEnHeures est un réel = ConvertiDurée(120, EUnitéDurée.Minute, EUnitéDurée.Heure)
      //	rDuréeEnHeures contiendra 2
      //
      PROCEDURE ConvertiDurée(LOCAL rValeur est un réel,eUnitéDépart est EUnitéDurée,eUnitéFinale est un EUnitéDurée = EUnitéDurée.Seconde,nArrondi est un entier=-1) : reel
      RENVOYER ConvertiUnité(rValeur,eUnitéDépart..Valeur,eUnitéFinale..Valeur,1,1,nArrondi)
     type : 458752
   -
     name : ConvertiForce
     procedure_id : 2014731861259554831
     type_code : 15
     group : 1
     code : |1-
      // Résumé : Cette fonction permet de convertir une valeur de force d'une unité à une autre. Elle prend en compte les unités de départ et d'arrivée, ainsi que les multiplicateurs associés, fournissant ainsi une flexibilité dans les conversions.
      //	La différence avec la fonction Conversion() est qu'on peut spécifier ici le multiplicateur, les unités et multiplicateurs sont des énumérations et non des chaines (qui peuvent introduire un risque d'erreur), il y a plus de conversions possibles (et vous pouvez en ajouter) et vous pouvez vérifier/modifier le facteur entre deux unités.
      // Syntaxe : [ <Résultat> = ] ConvertiForce (<rValeur> est réel, <eUnitéDépart> est COL_Conversion.EUnitéForce [, <eUnitéFinale> est COL_Conversion.EUnitéForce [, <eMultiplicateurDépart> est COL_Conversion.EMultiplicateur [, <eMultiplicateurFinal> est COL_Conversion.EMultiplicateur [, <nArrondi> est entier]]]])
      // Paramètres :
      //	rValeur (réel) : Un paramètre réel représentant la valeur de la force à convertir.
      //	eUnitéDépart (COL_Conversion.EUnitéForce) : Un paramètre de l'énumération EUnitéForce représentant l'unité de force de départ.
      //	eUnitéFinale (COL_Conversion.EUnitéForce optionnel) : Un paramètre de l'énumération EUnitéForce représentant l'unité de force finale. Par défaut, il est défini sur Newton.
      //	eMultiplicateurDépart (COL_Conversion.EMultiplicateur optionnel) : Un paramètre de l'énumération EMultiplicateur représentant le multiplicateur de la force de départ. Par défaut, il est défini sur Aucun.
      //	eMultiplicateurFinal (COL_Conversion.EMultiplicateur optionnel) : Un paramètre de l'énumération EMultiplicateur représentant le multiplicateur de la force finale. Par défaut, il est défini sur Aucun.
      // 	nArrondi (entier optionnel) : Un entier permettant de spécifier le nombre de décimales à conserver dans le résultat. Si non spécifié, la fonction n'effectuera pas d'arrondi.
      // Valeur de retour : réel : La fonction renvoie la valeur de force convertie.
      // Exemple :
      //	rForceEnNewton est un réel = ConvertiForce(10, EUnitéForce.LivreForce, EUnitéForce.Newton)
      //	rForceEnNewton contiendra 44.48221615261
      //
      PROCEDURE ConvertiForce(LOCAL rValeur est un réel,eUnitéDépart est EUnitéForce,eUnitéFinale est un EUnitéForce = Newton,eMultiplicateurDépart est un EMultiplicateur = EMultiplicateur.Aucun,eMultiplicateurFinal est un EMultiplicateur = EMultiplicateur.Aucun,nArrondi est un entier=-1) : reel
      RENVOYER ConvertiUnité(rValeur,eUnitéDépart..Valeur,eUnitéFinale..Valeur,eMultiplicateurDépart..Valeur,eMultiplicateurFinal..Valeur,nArrondi)
     type : 458752
   -
     name : ConvertiFréquence
     procedure_id : 2014731895619366581
     type_code : 15
     group : 1
     code : |1-
      // Résumé : Cette fonction permet de convertir une valeur de fréquence d'une unité à une autre. Elle prend en compte les unités de départ et d'arrivée, ainsi que les multiplicateurs associés, fournissant ainsi une flexibilité dans les conversions.
      //	La différence avec la fonction Conversion() est qu'on peut spécifier ici le multiplicateur, les unités et multiplicateurs sont des énumérations et non des chaines (qui peuvent introduire un risque d'erreur), il y a plus de conversions possibles (et vous pouvez en ajouter) et vous pouvez vérifier/modifier le facteur entre deux unités.
      // Syntaxe : [ <Résultat> = ] ConvertiFréquence (<rValeur> est réel, <eUnitéDépart> est COL_Conversion.EUnitéFréquence [, <eUnitéFinale> est COL_Conversion.EUnitéFréquence [, <eMultiplicateurDépart> est COL_Conversion.EMultiplicateur [, <eMultiplicateurFinal> est COL_Conversion.EMultiplicateur [, <nArrondi> est entier]]]])
      // Paramètres :
      //	rValeur (réel) : Un paramètre réel représentant la valeur de la fréquence à convertir.
      //	eUnitéDépart (COL_Conversion.EUnitéFréquence) : Un paramètre de l'énumération EUnitéFréquence représentant l'unité de fréquence de départ.
      //	eUnitéFinale (COL_Conversion.EUnitéFréquence optionnel) : Un paramètre de l'énumération EUnitéFréquence représentant l'unité de fréquence finale. Par défaut, il est défini sur Hertz.
      //	eMultiplicateurDépart (COL_Conversion.EMultiplicateur optionnel) : Un paramètre de l'énumération EMultiplicateur représentant le multiplicateur de la fréquence de départ. Par défaut, il est défini sur Aucun.
      //	eMultiplicateurFinal (COL_Conversion.EMultiplicateur optionnel) : Un paramètre de l'énumération EMultiplicateur représentant le multiplicateur de la fréquence finale. Par défaut, il est défini sur Aucun.
      // 	nArrondi (entier optionnel) : Un entier permettant de spécifier le nombre de décimales à conserver dans le résultat. Si non spécifié, la fonction n'effectuera pas d'arrondi.
      // Valeur de retour : réel : La fonction renvoie la valeur de fréquence convertie.
      // Exemple :
      //	rFréquenceEnMégahertz est un réel = ConvertiFréquence(500, EUnitéFréquence.Hertz, EUnitéFréquence.Heure)
      //	rFréquenceEnMégahertz contiendra 1800000
      //
      PROCEDURE ConvertiFréquence(LOCAL rValeur est un réel,eUnitéDépart est EUnitéFréquence,eUnitéFinale est un EUnitéFréquence = Hertz,eMultiplicateurDépart est un EMultiplicateur = EMultiplicateur.Aucun,eMultiplicateurFinal est un EMultiplicateur = EMultiplicateur.Aucun,nArrondi est un entier=-1) : reel
      RENVOYER ConvertiUnité(rValeur,eUnitéDépart..Valeur,eUnitéFinale..Valeur,eMultiplicateurDépart..Valeur,eMultiplicateurFinal..Valeur,nArrondi)
     type : 458752
   -
     name : ConvertiMasse
     procedure_id : 2014731968633893653
     type_code : 15
     group : 1
     code : |1-
      // Résumé : Cette fonction permet de convertir une valeur de masse d'une unité à une autre. Elle prend en compte les unités de départ et d'arrivée, ainsi que les multiplicateurs associés, fournissant ainsi une flexibilité dans les conversions.
      //	La différence avec la fonction Conversion() est qu'on peut spécifier ici le multiplicateur, les unités et multiplicateurs sont des énumérations et non des chaines (qui peuvent introduire un risque d'erreur), il y a plus de conversions possibles (et vous pouvez en ajouter) et vous pouvez vérifier/modifier le facteur entre deux unités.
      // Syntaxe : [ <Résultat> = ] ConvertiMasse (<rValeur> est réel, <eUnitéDépart> est COL_Conversion.EUnitéMasse [, <eUnitéFinale> est COL_Conversion.EUnitéMasse [, <eMultiplicateurDépart> est COL_Conversion.EMultiplicateur [, <eMultiplicateurFinal> est COL_Conversion.EMultiplicateur [, <nArrondi> est entier]]]])
      // Paramètres :
      //	rValeur (réel) : Un paramètre réel représentant la valeur de la masse à convertir.
      //	eUnitéDépart (COL_Conversion.EUnitéMasse) : Un paramètre de l'énumération EUnitéMasse représentant l'unité de masse de départ.
      //	eUnitéFinale (COL_Conversion.EUnitéMasse optionnel) : Un paramètre de l'énumération EUnitéMasse représentant l'unité de masse finale. Par défaut, il est défini sur Kilogramme.
      //	eMultiplicateurDépart (COL_Conversion.EMultiplicateur optionnel) : Un paramètre de l'énumération EMultiplicateur représentant le multiplicateur de la masse de départ. Par défaut, il est défini sur Aucun.
      //	eMultiplicateurFinal (COL_Conversion.EMultiplicateur optionnel) : Un paramètre de l'énumération EMultiplicateur représentant le multiplicateur de la masse finale. Par défaut, il est défini sur Aucun.
      // 	nArrondi (entier optionnel) : Un entier permettant de spécifier le nombre de décimales à conserver dans le résultat. Si non spécifié, la fonction n'effectuera pas d'arrondi.
      // Valeur de retour : réel : La fonction renvoie la valeur de masse convertie.
      // Exemple :
      //	rMasseEnKilogrammes est un reél = ConvertiMasse(150, EUnitéMasse.Livre, EUnitéMasse.Kilogramme)
      //	rMasseEnKilogrammes contiendra 75
      //
      PROCEDURE ConvertiMasse(LOCAL rValeur est un réel,eUnitéDépart est EUnitéMasse,eUnitéFinale est un EUnitéMasse = Kilogramme,eMultiplicateurDépart est un EMultiplicateur = EMultiplicateur.Aucun,eMultiplicateurFinal est un EMultiplicateur = EMultiplicateur.Aucun,nArrondi est un entier=-1) : reel
      RENVOYER ConvertiUnité(rValeur,eUnitéDépart..Valeur,eUnitéFinale..Valeur,eMultiplicateurDépart..Valeur,eMultiplicateurFinal..Valeur,nArrondi)
     type : 458752
   -
     name : ConvertiPuissance
     procedure_id : 2014732020173512967
     type_code : 15
     group : 1
     code : |1-
      // Résumé : Cette fonction permet de convertir une valeur de puissance d'une unité à une autre. Elle prend en compte les unités de départ et d'arrivée, ainsi que les multiplicateurs associés, fournissant ainsi une flexibilité dans les conversions.
      //	La différence avec la fonction Conversion() est qu'on peut spécifier ici le multiplicateur, les unités et multiplicateurs sont des énumérations et non des chaines (qui peuvent introduire un risque d'erreur), il y a plus de conversions possibles (et vous pouvez en ajouter) et vous pouvez vérifier/modifier le facteur entre deux unités.
      // Syntaxe : [ <Résultat> = ] ConvertiPuissance (<rValeur> est réel, <eUnitéDépart> est COL_Conversion.EUnitéPuissance [, <eUnitéFinale> est COL_Conversion.EUnitéPuissance [, <eMultiplicateurDépart> est COL_Conversion.EMultiplicateur [, <eMultiplicateurFinal> est COL_Conversion.EMultiplicateur [, <nArrondi> est entier]]]])
      //
      // Paramètres :
      //	rValeur (réel) : Un paramètre réel représentant la valeur de la puissance à convertir.
      //	eUnitéDépart (COL_Conversion.EUnitéPuissance) : Un paramètre de l'énumération EUnitéPuissance représentant l'unité de puissance de départ.
      //	eUnitéFinale (COL_Conversion.EUnitéPuissance optionnel) : Un paramètre de l'énumération EUnitéPuissance représentant l'unité de puissance finale. Par défaut, il est défini sur Watt.
      //	eMultiplicateurDépart (COL_Conversion.EMultiplicateur optionnel) : Un paramètre de l'énumération EMultiplicateur représentant le multiplicateur de la puissance de départ. Par défaut, il est défini sur Aucun.
      //	eMultiplicateurFinal (COL_Conversion.EMultiplicateur optionnel) : Un paramètre de l'énumération EMultiplicateur représentant le multiplicateur de la puissance finale. Par défaut, il est défini sur Aucun.
      // 	nArrondi (entier optionnel) : Un entier permettant de spécifier le nombre de décimales à conserver dans le résultat. Si non spécifié, la fonction n'effectuera pas d'arrondi.
      // Valeur de retour : réel : La fonction renvoie la valeur de puissance convertie.
      // Exemple :
      //	rPuissanceEnWatts est un réel = ConvertiPuissance(150, EUnitéPuissance.ChevalVapeur, EUnitéPuissance.Watt)
      //	rPuissanceEnWatts contiendra 110309.8125
      //
      PROCEDURE ConvertiPuissance(LOCAL rValeur est un réel,eUnitéDépart est EUnitéPuissance,eUnitéFinale est un EUnitéPuissance = Watt,eMultiplicateurDépart est un EMultiplicateur = EMultiplicateur.Aucun,eMultiplicateurFinal est un EMultiplicateur = EMultiplicateur.Aucun,nArrondi est un entier=-1) : reel
      RENVOYER ConvertiUnité(rValeur,eUnitéDépart..Valeur,eUnitéFinale..Valeur,eMultiplicateurDépart..Valeur,eMultiplicateurFinal..Valeur,nArrondi)
     type : 458752
   -
     name : ConvertiSurface
     procedure_id : 2014732041648420069
     type_code : 15
     group : 1
     code : |1-
      // Résumé : Cette fonction permet de convertir une valeur de surface d'une unité à une autre. Elle prend en compte les unités de départ et d'arrivée, ainsi que les multiplicateurs associés, offrant ainsi une flexibilité dans les conversions de surfaces.
      //	La différence avec la fonction Conversion() est qu'on peut spécifier ici le multiplicateur, les unités et multiplicateurs sont des énumérations et non des chaines (qui peuvent introduire un risque d'erreur), il y a plus de conversions possibles (et vous pouvez en ajouter) et vous pouvez vérifier/modifier le facteur entre deux unités.
      // Syntaxe : [ <Résultat> = ] ConvertiSurface (<rValeur> est réel, <eUnitéDépart> est COL_Conversion.EUnitéSurface [, <eUnitéFinale> est COL_Conversion.EUnitéSurface [, <eMultiplicateurDépart> est COL_Conversion.EMultiplicateur [, <eMultiplicateurFinal> est COL_Conversion.EMultiplicateur [, <nArrondi> est entier]]]])
      // Paramètres :
      //	rValeur (réel) : Un paramètre réel représentant la valeur de la surface à convertir.
      //	eUnitéDépart (COL_Conversion.EUnitéSurface) : Un paramètre de l'énumération EUnitéSurface représentant l'unité de surface de départ.
      //	eUnitéFinale (COL_Conversion.EUnitéSurface optionnel) : Un paramètre de l'énumération EUnitéSurface représentant l'unité de surface finale. Par défaut, il est défini sur MètreCarré.
      //	eMultiplicateurDépart (COL_Conversion.EMultiplicateur optionnel) : Un paramètre de l'énumération EMultiplicateur représentant le multiplicateur de la surface de départ. Par défaut, il est défini sur Aucun.
      //	eMultiplicateurFinal (COL_Conversion.EMultiplicateur optionnel) : Un paramètre de l'énumération EMultiplicateur représentant le multiplicateur de la surface finale. Par défaut, il est défini sur Aucun.
      // 	nArrondi (entier optionnel) : Un entier permettant de spécifier le nombre de décimales à conserver dans le résultat. Si non spécifié, la fonction n'effectuera pas d'arrondi.
      // Valeur de retour : réel : La fonction renvoie la valeur de surface convertie.
      // Exemple :
      //	rSurfaceEnHectares est un réel = ConvertiSurface(5000, EUnitéSurface.MètreCarré, EUnitéSurface.Hectare)
      //	rSurfaceEnHectares contiendra 0.5
      //
      PROCEDURE ConvertiSurface(LOCAL rValeur est un réel,eUnitéDépart est EUnitéSurface,eUnitéFinale est un EUnitéSurface = MètreCarré,eMultiplicateurDépart est un EMultiplicateur = EMultiplicateur.Aucun,eMultiplicateurFinal est un EMultiplicateur = EMultiplicateur.Aucun,nArrondi est un entier=-1) : reel
      RENVOYER ConvertiUnité(rValeur,eUnitéDépart..Valeur,eUnitéFinale..Valeur,eMultiplicateurDépart..Valeur,eMultiplicateurFinal..Valeur,nArrondi)
     type : 458752
   -
     name : ConvertiPression
     procedure_id : 2014732071713264087
     type_code : 15
     group : 1
     code : |1-
      // Résumé : Cette fonction permet de convertir une valeur de pression d'une unité à une autre. Elle prend en compte les unités de départ et d'arrivée, ainsi que les multiplicateurs associés, offrant ainsi une flexibilité dans les conversions de pression.
      //	La différence avec la fonction Conversion() est qu'on peut spécifier ici le multiplicateur, les unités et multiplicateurs sont des énumérations et non des chaines (qui peuvent introduire un risque d'erreur), il y a plus de conversions possibles (et vous pouvez en ajouter) et vous pouvez vérifier/modifier le facteur entre deux unités.
      // Syntaxe : [ <Résultat> = ] ConvertiPression (<rValeur> est réel, <eUnitéDépart> est COL_Conversion.EUnitéPression [, <eUnitéFinale> est COL_Conversion.EUnitéPression [, <eMultiplicateurDépart> est COL_Conversion.EMultiplicateur [, <eMultiplicateurFinal> est COL_Conversion.EMultiplicateur [, <nArrondi> est entier]]]])
      // Paramètres :
      //	rValeur (réel) : Un paramètre réel représentant la valeur de la pression à convertir.
      //	eUnitéDépart (COL_Conversion.EUnitéPression) : Un paramètre de l'énumération EUnitéPression représentant l'unité de pression de départ.
      //	eUnitéFinale (COL_Conversion.EUnitéPression optionnel) : Un paramètre de l'énumération EUnitéPression représentant l'unité de pression finale. Par défaut, il est défini sur Bar.
      //	eMultiplicateurDépart (COL_Conversion.EMultiplicateur optionnel) : Un paramètre de l'énumération EMultiplicateur représentant le multiplicateur de la pression de départ. Par défaut, il est défini sur Aucun.
      //	eMultiplicateurFinal (COL_Conversion.EMultiplicateur optionnel) : Un paramètre de l'énumération EMultiplicateur représentant le multiplicateur de la pression finale. Par défaut, il est défini sur Aucun.
      // 	nArrondi (entier optionnel) : Un entier permettant de spécifier le nombre de décimales à conserver dans le résultat. Si non spécifié, la fonction n'effectuera pas d'arrondi.
      // Valeur de retour : réel : La fonction renvoie la valeur de pression convertie.
      // Exemple :
      //	rPressionEnBars est un réel = ConvertiPression(100000, EUnitéPression.Pascal_, EUnitéPression.Bar)
      //	rPressionEnBars contiendra 1
      //
      PROCEDURE ConvertiPression(LOCAL rValeur est un réel,eUnitéDépart est EUnitéPression,eUnitéFinale est un EUnitéPression = Bar,eMultiplicateurDépart est un EMultiplicateur = EMultiplicateur.Aucun,eMultiplicateurFinal est un EMultiplicateur = EMultiplicateur.Aucun,nArrondi est un entier=-1) : reel
      RENVOYER ConvertiUnité(rValeur,eUnitéDépart..Valeur,eUnitéFinale..Valeur,eMultiplicateurDépart..Valeur,eMultiplicateurFinal..Valeur,nArrondi)
     type : 458752
   -
     name : ConvertiTempérature
     procedure_id : 2014732157612695246
     type_code : 15
     group : 1
     code : |1-
      // Résumé : Cette fonction permet de convertir une valeur de température d'une unité à une autre. Elle prend en compte les unités de départ et d'arrivée, offrant ainsi une flexibilité dans les conversions de température. Les conversions sont basées sur les formules de conversion standard.
      //	La différence avec la fonction Conversion() est qu'on peut spécifier ici le multiplicateur, les unités et multiplicateurs sont des énumérations et non des chaines (qui peuvent introduire un risque d'erreur), il y a plus de conversions possibles (et vous pouvez en ajouter) et vous pouvez vérifier/modifier le facteur entre deux unités.
      // Syntaxe : [ <Résultat> = ] ConvertiTempérature (<rValeur> est réel, <eUnitéDépart> est COL_Conversion.EUnitéTempérature [, <eUnitéFinale> est COL_Conversion.EUnitéTempérature [, <nArrondi> est entier]])
      // Paramètres :
      //	rValeur (réel) : Un paramètre réel représentant la valeur de la température à convertir.
      //	eUnitéDépart (COL_Conversion.EUnitéTempérature) : Un paramètre de l'énumération EUnitéTempérature représentant l'unité de température de départ.
      //	eUnitéFinale (COL_Conversion.EUnitéTempérature optionnel) : Un paramètre de l'énumération EUnitéTempérature représentant l'unité de température finale. Par défaut, il est défini sur Kelvin.
      // 	nArrondi (entier optionnel) : Un entier permettant de spécifier le nombre de décimales à conserver dans le résultat. Si non spécifié, la fonction n'effectuera pas d'arrondi.
      // Valeur de retour : réel : La fonction renvoie la valeur de température convertie.
      // Exemple :
      //	rTempFahrenheit est un réel = ConvertiTempérature(25, EUnitéTempérature.Celsius, EUnitéTempérature.Fahrenheit)
      //	rTempFahrenheit contiendra 77, en effet (25°C × 9/5) + 32 = 77°F
      //
      PROCEDURE ConvertiTempérature(LOCAL rValeur est un réel,eUnitéDépart est EUnitéTempérature,eUnitéFinale est un EUnitéTempérature = Kelvin,nArrondi est un entier=-1) : reel
      //ref : http://www.gaudry.be/conversions-temperatures.html
      rRésultat est un réel = rValeur
      si eUnitéDépart<>eUnitéFinale alors
      	selon eUnitéDépart
      		CAS Kelvin
      			selon eUnitéFinale
      				CAS Celsius		: rRésultat=rValeur-273.16
      				CAS Fahrenheit	: rRésultat=((rValeur-273.16)*9/5)+32
      				CAS Réaumur		: rRésultat=(rValeur-273.16)*4/5
      				cas Rankine		: rRésultat=rValeur*1.8
      			FIN
      		CAS Celsius
      			SELON eUnitéFinale
      				CAS Kelvin		: rRésultat=rValeur+273.16
      				CAS Fahrenheit	: rRésultat=(rValeur*1.8)+32
      				CAS Réaumur		: rRésultat=rValeur*4/5
      				cas Rankine		: rRésultat=(rValeur*1.8)+491.67
      			FIN
      		CAS Fahrenheit
      			SELON eUnitéFinale
      				CAS Kelvin		: rRésultat=(rValeur*0.555556)-255.37
      				CAS Celsius		: rRésultat=(rValeur-32)*5/9
      				CAS Réaumur		: rRésultat=(rValeur-32)*4/9
      				cas Rankine		: rRésultat=rValeur+459.67
      			FIN
      		CAS Réaumur
      			SELON eUnitéFinale
      				CAS Kelvin		: rRésultat=(rValeur*5/4)+273.16
      				CAS Celsius		: rRésultat=rValeur*5/4
      				CAS Fahrenheit	: rRésultat=(rValeur*9/4)+32
      				cas Rankine		: rRésultat=((rValeur*5/4)+273.16)*1.8
      			FIN
      		cas Rankine
      			selon eUnitéFinale
      				CAS Kelvin		: rRésultat=rValeur*0.555556
      				CAS Celsius		: rRésultat=(rValeur-491.67)*0.555556
      				CAS Fahrenheit	: rRésultat=((rValeur-273.16)*9/5)+32
      				CAS Réaumur		: rRésultat=((rValeur/1.8)-273.16)*4.5
      			FIN
      	FIN
      fin
      SI nArrondi<0 ALORS RENVOYER rRésultat SINON RENVOYER Arrondi(rRésultat,nArrondi)
     type : 458752
   -
     name : ConvertiTravail
     procedure_id : 2014732179087602550
     type_code : 15
     group : 1
     code : |1-
      // Résumé : <indiquez ici ce que fait la procédure>
      // Syntaxe :
      // ConvertiTravail ()
      //
      // Paramètres :
      //	Aucun
      // Valeur de retour :
      // 	Aucune
      //
      // Exemple :
      // Indiquez ici un exemple d'utilisation.
      //
      //
      PROCEDURE ConvertiTravail()	//à compléter
     type : 458752
   -
     name : ConvertiVitesse
     procedure_id : 2014732213447413817
     type_code : 15
     group : 1
     code : |1-
      // Résumé : Cette fonction permet de convertir une valeur de vitesse d'une unité à une autre. Elle prend en compte les unités de départ et d'arrivée, ainsi que les multiplicateurs, offrant une flexibilité dans les conversions de vitesse.
      //	La différence avec la fonction Conversion() est qu'on peut spécifier ici le multiplicateur, les unités et multiplicateurs sont des énumérations et non des chaines (qui peuvent introduire un risque d'erreur), il y a plus de conversions possibles (et vous pouvez en ajouter) et vous pouvez vérifier/modifier le facteur entre deux unités.
      // Syntaxe : [ <Résultat> = ] ConvertiVitesse (<rValeur> est réel, <eUnitéDépart> est COL_Conversion.EUnitéVitesse [, <eUnitéFinale> est COL_Conversion.EUnitéVitesse [, <eMultiplicateurDépart> est COL_Conversion.EMultiplicateur [, <eMultiplicateurFinal> est COL_Conversion.EMultiplicateur [, <nArrondi> est entier]]]])
      // Paramètres :
      //	rValeur (réel) : Un paramètre réel représentant la valeur de la vitesse à convertir.
      //	eUnitéDépart (COL_Conversion.EUnitéVitesse) : Un paramètre de l'énumération EUnitéVitesse représentant l'unité de vitesse de départ.
      //	eUnitéFinale (COL_Conversion.EUnitéVitesse optionnel) : Un paramètre de l'énumération EUnitéVitesse représentant l'unité de vitesse finale. Par défaut, il est défini sur MètreParSeconde.
      //	eMultiplicateurDépart (COL_Conversion.EMultiplicateur optionnel) : Un paramètre de l'énumération EMultiplicateur représentant le multiplicateur de l'unité de départ. Par défaut, il est défini sur Aucun.
      //	eMultiplicateurFinal (COL_Conversion.EMultiplicateur optionnel) : Un paramètre de l'énumération EMultiplicateur représentant le multiplicateur de l'unité finale. Par défaut, il est défini sur Aucun.
      // 	nArrondi (entier optionnel) : Un entier permettant de spécifier le nombre de décimales à conserver dans le résultat. Si non spécifié, la fonction n'effectuera pas d'arrondi.
      // Valeur de retour : réel : La fonction renvoie la valeur de vitesse convertie.
      // Exemple :
      //	rVitesseMPS est un réel = ConvertiVitesse(120, EUnitéVitesse.MileParHeure, EUnitéVitesse.MètreParSeconde)
      //	rVitesseMPS contiendra 54.6448
      //
      PROCEDURE ConvertiVitesse(LOCAL rValeur est un réel,eUnitéDépart est EUnitéVitesse,eUnitéFinale est un EUnitéVitesse = MètreParSeconde,eMultiplicateurDépart est un EMultiplicateur = EMultiplicateur.Aucun,eMultiplicateurFinal est un EMultiplicateur = EMultiplicateur.Aucun,nArrondi est un entier=-1) : reel
      RENVOYER ConvertiUnité(rValeur,eUnitéDépart..Valeur,eUnitéFinale..Valeur,eMultiplicateurDépart..Valeur,eMultiplicateurFinal..Valeur,nArrondi)
     type : 458752
   -
     name : ConvertiVolume
     procedure_id : 2014732239217289229
     type_code : 15
     group : 1
     code : |1-
      // Résumé : Cette fonction permet de convertir une valeur de volume d'une unité à une autre. Elle prend en compte les unités de départ et d'arrivée, ainsi que les multiplicateurs, offrant une flexibilité dans les conversions de volume.
      //	La différence avec la fonction Conversion() est qu'on peut spécifier ici le multiplicateur, les unités et multiplicateurs sont des énumérations et non des chaines (qui peuvent introduire un risque d'erreur), il y a plus de conversions possibles (et vous pouvez en ajouter) et vous pouvez vérifier/modifier le facteur entre deux unités.
      // Syntaxe : [ <Résultat> = ] ConvertiVolume (<rValeur> est réel, <eUnitéDépart> est COL_Conversion.EUnitéVolume [, <eUnitéFinale> est COL_Conversion.EUnitéVolume [, <eMultiplicateurDépart> est COL_Conversion.EMultiplicateur [, <eMultiplicateurFinal> est COL_Conversion.EMultiplicateur [, <nArrondi> est entier]]]])
      // Paramètres :
      //	rValeur (réel) : Un paramètre réel représentant la valeur du volume à convertir.
      //	eUnitéDépart (COL_Conversion.EUnitéVolume) : Un paramètre de l'énumération EUnitéVolume représentant l'unité de volume de départ.
      //	eUnitéFinale (COL_Conversion.EUnitéVolume optionnel) : Un paramètre de l'énumération EUnitéVolume représentant l'unité de volume finale. Par défaut, il est défini sur MètreCube.
      //	eMultiplicateurDépart (COL_Conversion.EMultiplicateur optionnel) : Un paramètre de l'énumération EMultiplicateur représentant le multiplicateur de l'unité de départ. Par défaut, il est défini sur Aucun.
      //	eMultiplicateurFinal (COL_Conversion.EMultiplicateur optionnel) : Un paramètre de l'énumération EMultiplicateur représentant le multiplicateur de l'unité finale. Par défaut, il est défini sur Aucun.
      // 	nArrondi (entier optionnel) : Un entier permettant de spécifier le nombre de décimales à conserver dans le résultat. Si non spécifié, la fonction n'effectuera pas d'arrondi.
      // Valeur de retour : réel : La fonction renvoie la valeur du volume converti.
      // Exemple :
      //	rVolumeMC est un réel = ConvertiVolume(100, EUnitéVolume.Litre, EUnitéVolume.MètreCube)
      //	rVolumeMC contiendra 0.1
      //
      PROCEDURE ConvertiVolume(LOCAL rValeur est un réel,eUnitéDépart est EUnitéVolume,eUnitéFinale est un EUnitéVolume = MètreCube,eMultiplicateurDépart est un EMultiplicateur = EMultiplicateur.Aucun,eMultiplicateurFinal est un EMultiplicateur = EMultiplicateur.Aucun,nArrondi est un entier=-1) : reel
      RENVOYER ConvertiUnité(rValeur,eUnitéDépart..Valeur,eUnitéFinale..Valeur,eMultiplicateurDépart..Valeur,eMultiplicateurFinal..Valeur,nArrondi)
     type : 458752
   -
     name : MultiplicateurVersSymbole
     procedure_id : 2015456877568428114
     type_code : 15
     group : 1
     code : |1-
      // Résumé : Cette fonction permet de convertir un multiplicateur de l'énumération EMultiplicateur en son équivalent en symboles. La fonction prend en compte une variante d'énumération EMultiInformatique spécifique aux unités informatiques.
      // Syntaxe : [ <Résultat> = ] MultiplicateurVersSymbole (<xMultiplicateur>)
      // Paramètres :
      // 	xMultiplicateur : Un paramètre de l'énumération EMultiplicateur représentant le multiplicateur à convertir en symbole.
      // Valeur de retour : chaîne UNICODE : La fonction renvoie une chaîne de caractères représentant le symbole correspondant au multiplicateur. Si le multiplicateur n'a pas de symbole associé, la fonction renvoie une chaîne vide.
      // Exemple :
      //	sSymbole est une chaîne = MultiplicateurVersSymbole(EMultiplicateur.kilo)
      //	sSymbole contiendra "k"
      //
      PROCEDURE MultiplicateurVersSymbole(xMultiplicateur) : chaine
      quand exception dans
      	SELON xMultiplicateur..nom
      		CAS EMultiplicateur.aucun..Nom									: RENVOYER ""
      		CAS	EMultiInformatique.Aucun..Nom 								: RENVOYER ""
      		CAS EMultiplicateur.yotta..Nom,EMultiInformatique.yotta..Nom	: RENVOYER "Y"
      		CAS EMultiplicateur.zetta..Nom,EMultiInformatique.zetta..Nom	: RENVOYER "Z"
      		CAS EMultiplicateur.exa..Nom,EMultiInformatique.exa..Nom		: RENVOYER "E"
      		CAS EMultiplicateur.peta..Nom,EMultiInformatique.peta..Nom		: RENVOYER "P"
      		CAS EMultiplicateur.tera..Nom,EMultiInformatique.tera..Nom		: RENVOYER "T"
      		CAS EMultiplicateur.giga..Nom,EMultiInformatique.giga..Nom		: RENVOYER "G"
      		CAS EMultiplicateur.mega..Nom,EMultiInformatique.mega..Nom		: RENVOYER "M"
      		CAS EMultiplicateur.kilo..Nom,EMultiInformatique.kilo..Nom		: RENVOYER "k"
      		CAS EMultiplicateur.hecto..Nom									: RENVOYER "h"
      		CAS EMultiplicateur.déca..Nom									: RENVOYER "da"
      		CAS EMultiplicateur.déci..Nom									: RENVOYER "d"
      		CAS EMultiplicateur.centi..Nom									: RENVOYER "c"
      		CAS EMultiplicateur.milli..Nom									: RENVOYER "m"
      		CAS EMultiplicateur.micro..Nom									: RENVOYER "µ"
      		CAS EMultiplicateur.nano..Nom									: RENVOYER "n"
      		CAS EMultiplicateur.pico..Nom									: RENVOYER "p"
      		CAS EMultiplicateur.femto..Nom									: RENVOYER "f"
      		CAS EMultiplicateur.atto..Nom									: RENVOYER "a"
      		CAS EMultiplicateur.zepto..Nom									: RENVOYER "z"
      		CAS EMultiplicateur.yocto..Nom									: RENVOYER "y"
      		AUTRES CAS														: RENVOYER ""
      	FIN
      faire
      	ErreurDéclenche(ErreurDeConverion,<§@1b155a2803bc06420058§>);renvoyer ""
      fin
     type : 458752
   -
     name : UnitéVersSymbole
     procedure_id : 2015460425293242600
     type_code : 15
     group : 1
     code : |1-
      // Résumé : Cette fonction convertit une unité de mesure de l'énumération EUnitéLongueur, EUnitéAccélération, EUnitéAngle, EUnitéDurée, EUnitéForce, EUnitéFréquence, EUnitéMasse, EUnitéPression, EUnitéPuissance, EUnitéSurface, EUnitéTempérature, EUnitéVitesse, ou EUnitéVolume en son symbole correspondant.
      // Syntaxe : [ <Résultat> = ] UnitéVersSymbole (<xUnité>)
      // Paramètres :
      // 	xUnité : Un paramètre de l'une des énumérations mentionnées ci-dessus représentant l'unité à convertir en symbole.
      // Valeur de retour : chaîne UNICODE : La fonction renvoie une chaîne de caractères représentant le symbole de l'unité correspondante. Si l'unité n'a pas de symbole associé, la fonction renvoie une chaîne vide.
      // Exemple :
      //	sSymbole est une chaine = UnitéVersSymbole(EUnitéPuissance.ChevalVapeur)
      //	sSymbole contiendra "ch" en français et "hp" en anglais
      //
      PROCEDURE UnitéVersSymbole(xUnité) : chaine
      quand exception dans
      	SELON xUnité..nom
      		CAS EUnitéLongueur.Mètre..nom								: RENVOYER "m"
      		CAS EUnitéLongueur.Angström	..nom							: RENVOYER "Å"
      		CAS EUnitéLongueur.UnitéAstronomique..nom					: RENVOYER "au"
      		CAS EUnitéLongueur.AnnéeLumière..nom						: RENVOYER <§@1b155a2803bc06420034§>
      		CAS EUnitéLongueur.Pied..nom								: RENVOYER <§@1b155a2803bc06420055§>
      		CAS EUnitéLongueur.Pouce..nom								: RENVOYER <§@1b155a2803bc06420056§>
      		CAS EUnitéLongueur.MilleInternational..nom					: RENVOYER "mi"
      		CAS EUnitéLongueur.Verge..nom								: RENVOYER <§@1b155a2803bc06420035§>
      		CAS EUnitéAccélération.MètreParSecondeCarré..nom			: RENVOYER "m/s²"
      		CAS EUnitéAccélération.GravitéTerrestre..nom				: RENVOYER "g"
      		CAS EUnitéAccélération.Gal..nom								: RENVOYER "Gal"
      		CAS EUnitéAngle.Radian..nom									: RENVOYER "rad"
      		CAS EUnitéAngle.Gradian..nom								: RENVOYER "gon"
      		CAS EUnitéAngle.Degré..nom									: RENVOYER "°"
      		CAS EUnitéAngle.Minutearc..nom								: renvoyer "'"
      		cas EUnitéAngle.Secondearc..nom								: renvoyer "''"	
      		cas EUnitéDurée.Minute..nom,EUnitéFréquence.Minute..nom 	: RENVOYER "min"
      		CAS EUnitéDurée.Seconde..nom								: RENVOYER "sec"
      		CAS EUnitéDurée.Heure..nom,EUnitéFréquence.Heure..nom 		: RENVOYER "h"
      		CAS EUnitéForce.Newton..nom									: RENVOYER "N"
      		CAS EUnitéForce.Dyne..nom									: RENVOYER "dyn"
      		CAS EUnitéForce.LivreForce..nom								: RENVOYER "lbf"
      		CAS EUnitéForce.KilogrammeForce..nom						: RENVOYER "kgf"
      		CAS EUnitéFréquence.Hertz..nom								: RENVOYER "Hz"
      		CAS EUnitéFréquence.Jour..nom								: RENVOYER <§@1b155a2803bc06420036§>
      		CAS	EUnitéMasse.Kilogramme..nom								: RENVOYER "kg"
      		CAS	EUnitéMasse.Tonne..nom									: RENVOYER "t"
      		CAS	EUnitéMasse.Quintal..nom								: RENVOYER "q"
      		CAS	EUnitéMasse.Livre..nom									: RENVOYER "lb"
      		CAS	EUnitéMasse.LivreImpériale..nom							: RENVOYER "lb"
      		CAS	EUnitéMasse.OnceImpériale..nom							: RENVOYER "oz"
      		CAS	EUnitéMasse.Carat..nom									: RENVOYER "ct"
      		CAS EUnitéPression.Pascal_..nom								: RENVOYER "Pa"
      		CAS EUnitéPression.Bar..nom									: RENVOYER "bar"
      		CAS EUnitéPression.NewtonParMètreCarré..nom					: RENVOYER "N/m²"
      		CAS EUnitéPression.LivreParPouceCarré..nom					: RENVOYER "psi"
      		CAS EUnitéPression.AtmosphèreTechnique..nom 				: RENVOYER "at"
      		CAS EUnitéPression.AtmosphèrePhysique..nom					: RENVOYER "atm"
      		CAS EUnitéPression.MilliMètreMercure..nom					: RENVOYER "mmHg"
      		CAS EUnitéPuissance.Watt..nom								: RENVOYER "W"
      		CAS EUnitéPuissance.ChevalVapeur..nom						: RENVOYER <§@1b155a2803bc06420037§>
      		CAS EUnitéPuissance.ChevalVapeurUS..nom						: RENVOYER <§@1b155a2803bc06420037§>
      		CAS	EUnitéSurface.MètreCarré..nom							: RENVOYER "m²"
      		CAS	EUnitéSurface.Hectare..nom 								: RENVOYER "ha"
      		CAS	EUnitéSurface.Are_..nom									: RENVOYER "a"
      		CAS	EUnitéSurface.centiare..nom								: RENVOYER "ca"
      		CAS	EUnitéSurface.PiedCarré..nom							: RENVOYER "pi²"
      		CAS	EUnitéSurface.PouceCarré..nom							: RENVOYER "po²"
      		CAS EUnitéTempérature.Kelvin..nom							: RENVOYER "°K"
      		CAS EUnitéTempérature.Celsius..nom							: RENVOYER "°C"
      		CAS EUnitéTempérature.Fahrenheit..nom						: RENVOYER "°F"
      		CAS EUnitéTempérature.Réaumur..nom							: RENVOYER "°Ré"
      		CAS EUnitéTempérature.Rankine..nom							: RENVOYER "°Ra"
      		CAS EUnitéVitesse.MètreParSeconde..nom						: RENVOYER "m/s"
      		CAS EUnitéVitesse.MètreParMinute..nom						: RENVOYER "m/min"
      		CAS EUnitéVitesse.KilomètreParSeconde..nom					: RENVOYER "km/s"
      		CAS EUnitéVitesse.MileParSeconde..nom						: RENVOYER "mps"
      		CAS EUnitéVitesse.MileParHeure..nom							: RENVOYER "mph"
      		CAS EUnitéVitesse.PiedParSeconde..nom						: RENVOYER "fps"
      		CAS EUnitéVitesse.PiedParMinute..nom						: RENVOYER "ft/min"
      		CAS EUnitéVitesse.MinuteParKilomètre..nom					: RENVOYER "min/km"
      		CAS EUnitéVitesse.noeud..nom								: RENVOYER "kt"
      		CAS EUnitéVitesse.MileNautiqueParHeure..nom					: RENVOYER "seamiles/hour"
      		CAS EUnitéVitesse.VitesseLumière..nom						: RENVOYER "c"
      		CAS EUnitéVitesse.Mach..nom 								: RENVOYER "Ma"
      		CAS EUnitéVolume.MètreCube..nom								: RENVOYER "m³"
      		CAS EUnitéVolume.Litre..nom									: RENVOYER "l"
      		CAS EUnitéVolume.PiedCube..nom								: RENVOYER "ft³"
      		CAS EUnitéVolume.PouceCube..nom								: RENVOYER "in³"
      		CAS EUnitéVolume.GallonImpérial..nom						: RENVOYER "gallon"
      		CAS EUnitéVolume.Pinte..nom									: RENVOYER "pint"
      		CAS EUnitéVolume.Baril..nom									: RENVOYER "bbl"
      		CAS EUnitéÉnergie.Joule..nom								: RENVOYER "J"
      		CAS EUnitéÉnergie.Calorie..nom								: RENVOYER "cal"
      		CAS EUnitéÉnergie.KiloWattHeure..nom						: RENVOYER "kWh"
      		CAS EUnitéÉnergie.WattSeconde..nom							: RENVOYER "Ws"
      		CAS EUnitéÉnergie.Pascal_..nom								: RENVOYER "Pa"
      		CAS EUnitéÉnergie.ElectronVolt..nom							: RENVOYER "eV"
      		CAS EUnitéInformatique.bit..nom								: RENVOYER "b"
      		CAS EUnitéInformatique.octet_..nom							: RENVOYER "o"
      		AUTRES CAS													: RENVOYER ""
      	fin
      faire
      	ErreurDéclenche(ErreurDeConverion,<§@1b155a2803bc06420057§>);renvoyer ""
      fin
     type : 458752
   -
     name : fDécoupeTexte
     procedure_id : 2016884017847663837
     type_code : 15
     group : 1
     code : |1+
      // Résumé : Cette fonction découpe un fichier texte en plusieurs fichiers plus petits en fonction des critères spécifiés. Les critères de découpage peuvent être basés sur la taille du fichier, le nombre de lignes ou la présence de séparateurs de lignes (par exemple, retour chariot).
      // Syntaxe : [ <Résultat> = ] fDécoupeTexte (<sFichierADécouper> est chaîne, <eTypeDécoupage> est COL_Conversion.EFichierDécoupe, <nTaille> est entier sur 8 octets [, <sRépertoireDestination> est chaîne [, <sNomDestination> est chaîne [, <bAligneNomDesFichiers> est booléen]]])
      // Paramètres :
      //	sFichierADécouper (chaîne UNICODE) : Le chemin du fichier à découper.
      //	eTypeDécoupage (COL_Conversion.EFichierDécoupe) : Un paramètre de l'énumération EFichierDécoupe indiquant le type de découpage à effectuer (ParTaille, ParTailleSurRC, ParNbLignes).
      //	nTaille (entier sur 8 octets) : La taille maximale d'un fichier découpé (en octets, lignes, etc., en fonction du critère de découpage choisi).
      //	sRépertoireDestination (chaîne UNICODE) : Le répertoire où seront stockés les fichiers découpés. Si non spécifié, le répertoire du fichier d'origine est utilisé.
      //	sNomDestination (chaîne UNICODE) : Le nom de base des fichiers découpés. Si non spécifié, le nom du fichier d'origine est utilisé.
      // 	bAligneNomDesFichiers (booléen) : Un booléen indiquant si les noms des fichiers découpés doivent être alignés en fonction du nombre de fichiers générés.
      // Valeur de retour : booléen : La fonction renvoie Vrai si la découpe s'est déroulée avec succès, sinon Faux.
      // Exemple :
      //	SI fDécoupeTexte("C:\Chemin\FichierSource.txt", ParTaille, 1024, "C:\Chemin\Destination\", "NouveauNom", Vrai) ALORS
      //		INFO("Découpe réussie.")
      //	SINON
      //		ERREUR("La découpe a échoué.",ErreurInfo())
      //	FIN
      //
      PROCEDURE fDécoupeTexte(sFichierADécouper est une chaine,eTypeDécoupage est un EFichierDécoupe,nTaille est un entier sur 8 octets, LOCAL sRépertoireDestination est une chaîne = "", LOCAL sNomDestination est une chaîne = "",bAligneNomDesFichiers est un booléen=Faux) : booléen
      nSeqFichierSortie 			est un entier = 1
      sFormatNumFichier			est une chaîne = "01d"
      sSéparateur					est une chaîne = RC
      sBlocLu,sBlocÉcrit,sLigne,sFichierExt	est une chaîne
      nIdFichierDestination,nTailleBlocALire,nPosSéparateur,nPosCur,nNbLignes,nTailleFichier sont des entiers
      nTailleFichierOrigineLue,nTailleDejaEcrite,nTailleBufferEcrit,nIDFichier sont des entiers
      
      //A FAIRE : jauge et regroupe
      si ffichierexiste(sFichierADécouper) alors
      	sFichierExt 	= fExtraitChemin(sFichierADécouper,fExtension)
      	nTailleFichier	= ftaille(sFichierADécouper)
      	nIDFichier		= fouvre(sFichierADécouper)
      	SI nIDFichier=-1 ALORS
      		ErreurDéclenche(ErreurDeConverion,<§@1b155a2803bc06420039§>+erreurinfo(errmessaGE));renvoyer faux
      	SINON
      		SI sRépertoireDestination="" 	ALORS sRépertoireDestination=fExtraitChemin(sFichierADécouper,fDisque+fRépertoire)
      		SI sNomDestination="" 			ALORS sNomDestination=fExtraitChemin(sFichierADécouper,fFichier)
      		
      		nTailleBlocALire=Min(nTaille,30000)
      		SI CrééFichierDestination(nSeqFichierSortie) ALORS
      			SELON eTypeDécoupage
      				CAS ParTaille
      					TANTQUE nTailleFichierOrigineLue<nTailleFichier
      //						SI m_bDécoupeArrête ALORS fFerme(nIdFichierDestination);RENVOYER <§@1b155a2803bc0642003a§>
      						LitBloc()
      						TANTQUE sBlocLu>""
      							SI nTailleDejaEcrite+Taille(sBlocLu)<nTailleBlocALire ALORS
      								//on met le buffer en entier dans le fichier destination
      								nTailleDejaEcrite+=Taille(sBlocLu)
      								SI PAS fEcrit(nIdFichierDestination,sBlocLu) ALORS
      									fFerme(nIdFichierDestination)
      									ErreurDéclenche(ErreurDeConverion,<§@1b155a2803bc0642003b§>+nSeqFichierSortie+" : "+erreurinfo(errmessage));renvoyer faux
      								FIN
      								sBlocLu=""	//on attend la prochaine lecture
      							SINON
      								//on ne met qu'une partie du buffer dans le fichier destination
      								//le fichier destination a la bonne taille, il est fermé et le compteur de fichier écrit est augmenté
      								sBlocÉcrit=Gauche(sBlocLu,PartieEntière(nTailleBlocALire-nTailleDejaEcrite))
      								SI PAS fEcrit(nIdFichierDestination,sBlocÉcrit) ALORS
      									fFerme(nIdFichierDestination)
      									ErreurDéclenche(ErreurDeConverion,<§@1b155a2803bc0642003b§>+nSeqFichierSortie+" : "+erreurinfo(errmessage));renvoyer faux
      								FIN
      								fFerme(nIdFichierDestination)
      								//on prend la seconde partie du buffer et initialise les variables pour la suite
      								sBlocLu=Milieu(sBlocLu,nTailleBlocALire-nTailleDejaEcrite+1)
      								nTailleDejaEcrite=0
      								SI PAS CréeFichierDestinationSuivant() ALORS 
      									ErreurDéclenche(ErreurDeConverion,<§@1b155a2803bc0642003c§>+nSeqFichierSortie+" : "+erreurinfo(errmessage));renvoyer faux
      								FIN
      							FIN
      						FIN
      					FIN
      				CAS ParTailleSurRC,ParNbLignes
      					nPosSéparateur=Position(sBlocLu,sSéparateur);nPosSéparateur=1
      					TANTQUE nPosSéparateur>0
      						Multitâche(-1)
      //						SI m_bDécoupeArrête ALORS fFerme(nIdFichierDestination);RENVOYER <§@1b155a2803bc0642003a§>
      						
      						sLigne=Milieu(sBlocLu,nPosCur,nPosSéparateur-nPosCur)
      						nPosSéparateur		= nPosSéparateur+Taille(sSéparateur)
      						nNbLignes++
      						sBlocÉcrit			= sBlocÉcrit+sLigne+sSéparateur		//on alimente buffer2 qui sert à l'écriture
      						nTailleBufferEcrit	= Taille(sBlocÉcrit)
      						
      						SI nTailleBufferEcrit>=nTailleBlocALire ALORS
      							SI PAS fEcrit(nIdFichierDestination,sBlocÉcrit) ALORS
      								fFerme(nIdFichierDestination)
      								ErreurDéclenche(ErreurDeConverion,<§@1b155a2803bc0642003b§>+nSeqFichierSortie+" : "+erreurinfo(errmessage));renvoyer faux
      							FIN
      							sBlocÉcrit=""
      						SINON
      							SI (eTypeDécoupage=ParTailleSurRC ET nTailleBufferEcrit>=nTaille) _OU_ (eTypeDécoupage=ParNbLignes ET nNbLignes>=nTaille) ALORS
      								SI PAS fEcrit(nIdFichierDestination,sBlocÉcrit) ALORS
      									fFerme(nIdFichierDestination)
      									ErreurDéclenche(ErreurDeConverion,<§@1b155a2803bc0642003b§>+nSeqFichierSortie+" : "+erreurinfo(errmessage));renvoyer faux
      								FIN
      								fFerme(nIdFichierDestination)
      								sBlocÉcrit="";nNbLignes=0
      								SI PAS CréeFichierDestinationSuivant() ALORS 
      									ErreurDéclenche(ErreurDeConverion,<§@1b155a2803bc0642003c§>+nSeqFichierSortie+" : "+erreurinfo(errmessage));renvoyer faux
      								FIN
      							FIN
      						FIN
      						nPosSéparateur=Position(sBlocLu,sSéparateur,nPosCur)
      					FIN	
      					sBlocLu=Milieu(sBlocLu,nPosCur)		
      			FIN
      			//dernier bloc
      			SI sBlocÉcrit>"" ALORS
      				SI PAS fEcrit(nIdFichierDestination,sBlocÉcrit) ALORS
      					fFerme(nIdFichierDestination)
      					ErreurDéclenche(ErreurDeConverion,<§@1b155a2803bc0642003b§>+nSeqFichierSortie+" : "+erreurinfo(errmessage));renvoyer faux
      				FIN
      				fFerme(nIdFichierDestination)
      			FIN
      			//alignement des noms de fichiers
      			SI bAligneNomDesFichiers _et_ pas AligneNom() alors 
      				ErreurDéclenche(ErreurDeConverion,<§@1b155a2803bc0642003f§>+ErreurInfo(errMessage));renvoyer faux
      			FIN
      			renvoyer vrai
      		SINON
      			ErreurDéclenche(ErreurDeConverion,<§@1b155a2803bc0642003c§>+nSeqFichierSortie+" : "+erreurinfo(errmessage));renvoyer faux
      		FIN
      	FIN
      sinon
      	ErreurDéclenche(ErreurDeConverion,<§@1b155a2803bc0642003d§>);renvoyer faux
      fin
      
      	PROCÉDURE INTERNE LitBloc()
      	SI nTailleFichierOrigineLue+nTailleBlocALire<=nTailleFichier ALORS 
      		sBlocLu=sBlocLu+fLit(nIDFichier,nTailleBlocALire);nTailleFichierOrigineLue+=nTailleBlocALire
      	SINON 
      		sBlocLu=sBlocLu+fLit(nIDFichier,nTailleFichier-nTailleFichierOrigineLue);nTailleFichierOrigineLue=nTailleFichier
      	FIN
      	FIN
      
      	PROCÉDURE INTERNE CrééFichierDestination(nNumFichier est un entier) : booléen
      	nIdFichierDestination=fCrée(sRépertoireDestination+["\"]+sNomDestination+NumériqueVersChaîne(nNumFichier,sFormatNumFichier)+sFichierExt)
      	RENVOYER (nIdFichierDestination<>-1)
      	FIN
      
      	PROCÉDURE INTERNE CréeFichierDestinationSuivant() : booléen
      	nSeqFichierSortie++
      	SI Taille(NumériqueVersChaîne(nSeqFichierSortie))>Val(sFormatNumFichier) ALORS sFormatNumFichier="0"+Taille(NumériqueVersChaîne(nSeqFichierSortie))+"d"
      	RENVOYER CrééFichierDestination(nSeqFichierSortie)
      	FIN
      
      	PROCÉDURE INTERNE AligneNom() : booleen
      	i est un entier
      	j est un entier = nSeqFichierSortie
      	sFichierOrigine,sFichierRenommé est une chaîne
      	
      	SI sFormatNumFichier<>"01d" ET nSeqFichierSortie>1 ALORS
      		POUR nNumFichierDestination = 1 À nSeqFichierSortie
      			SI Taille(NumériqueVersChaîne(nNumFichierDestination))<Val(sFormatNumFichier) ALORS
      				sFichierOrigine=sRépertoireDestination+["\"]+sNomDestination+NumériqueVersChaîne(nNumFichierDestination,"0"+Taille(NumériqueVersChaîne(i))+"d")+sFichierExt
      				sFichierRenommé=sRépertoireDestination+["\"]+sNomDestination+NumériqueVersChaîne(nNumFichierDestination,sFormatNumFichier)+sFichierExt
      				fSupprime(sFichierRenommé)
      				SI PAS fRenomme(sFichierOrigine,sFichierRenommé) ALORS renvoyer faux
      			FIN
      		FIN
      	FIN
      	RENVOYER Vrai
      	FIN
     type : 458752
   -
     name : VariableVersJSON
     procedure_id : 2017686098891441154
     type_code : 15
     code : |1+
      // Résumé : Cette fonction convertit une variable WinDev en format JSON. Elle prend en charge les types de variables tels que les variants, les tableaux, les énumérations, les structures, les instances et les variables composées. Lorsqu'une variable a un statut JSON spécifié, la fonction inclut ce statut dans le résultat.
      // Syntaxe : [ <Résultat> = ] VariableVersJSON (<xElément> [, <sStatutJson> est chaîne])
      // Paramètres :
      //	xElément : La variable WinDev à convertir en format JSON.
      //	sStatutJson (chaîne UNICODE - valeur par défaut="") : Un statut JSON à inclure dans le résultat. Par défaut, il est une chaîne vide.
      // Valeur de retour : chaîne UNICODE : La variable convertie au format JSON
      // Exemple :
      //	MaVariable est un entier = 5
      //	sResultatJSON est une chaine = VariableVersJSON(MaVariable)
      //	INFO("Variable convertie en JSON : " + sResultatJSON)
      //
      PROCEDURE VariableVersJSON(local xElément,sStatutJson est une chaine = "") : chaine
      sRésultat est une chaine
      sPrefixeStatut est une chaine ansi = [
      	{"status":"%1",%2}
      ]
      SELON TypeVar(xElément)
      	CAS wlVide 							: sRésultat=<§@1b155a2803bc0642003e§>
      	CAS wlVariant						: sRésultat=StructureVersJSON(xElément,Faux)
      	CAS wlVariantTableau,wlTableau 		: sRésultat=StructureVersJSON(xElément,Faux)
      	CAS wlEnumération,wlCombinaison		: sRésultat=xElément..Nom	//elles ont toujours un nom, la valeur pourrait générer des exceptions
      	CAS wlStructure,wlInstance			: sRésultat=StructureVersJSON(xElément,Faux)
      	CAS wlVariableComposée				: sRésultat=StructureVersJSON(xElément,Faux)
      	AUTRES CAS							: sRésultat=StructureVersJSON(xElément,Faux)
      FIN
      RENVOYER sStatutJson <> "" ?  ChaîneConstruit(sPrefixeStatut,sStatutJson,(sRésultat[[1]]="{" _ET_ sRésultat[[Taille(sRésultat)]]="}" ? sRésultat[[2 À Taille(sRésultat)-1]] SINON sRésultat)) SINON sRésultat
     type : 458752
   -
     name : AprèsDemain
     procedure_id : 2022519603496374892
     type_code : 15
     group : 3
     code : |1-
      // Résumé : La fonction renvoie la date correspondant au jour après demain par rapport à la date système actuelle.
      // Syntaxe : [ <Résultat> = ] AprèsDemain ()
      // Paramètres :
      //	Aucun
      // Valeur de retour : date : La fonction renvoie une Date représentant la date après demain par rapport à la date système actuelle.
      // Exemple :
      //	dDateApresDemain est une date = AprèsDemain()
      //	INFO("Date après demain : " + DateVersChaîne(dDateApresDemain))
      //
      PROCEDURE AprèsDemain() : date
      dAujourdhui est une date = datesys()
      dAujourdhui..Jour+=2
      RENVOYER dAujourdhui
     type : 458752
   -
     name : Demain
     procedure_id : 2022519607791408301
     type_code : 15
     group : 3
     code : |1-
      // Résumé : La fonction Demain renvoie la date correspondant au jour suivant par rapport à la date système actuelle.
      // Syntaxe : [ <Résultat> = ] Demain ()
      // Paramètres :
      //	Aucun
      // Valeur de retour : date : La fonction renvoie une Date représentant la date du jour suivant par rapport à la date système actuelle.
      // Exemple :
      //	dDateDemain est une date = Demain()
      //	INFO("Date demain : " + DateVersChaîne(dDateDemain))
      //
      PROCEDURE Demain() : date
      dAujourdhui est une date = datesys()
      dAujourdhui..jour++
      renvoyer dAujourdhui
     type : 458752
   -
     name : Hier
     procedure_id : 2024283722372996255
     type_code : 15
     group : 3
     code : |1-
      // Résumé : La fonction renvoie la date correspondant à la veille par rapport à la date système actuelle.
      // Syntaxe : [ <Résultat> = ] Hier ()
      // Paramètres :
      //	Aucun
      // Valeur de retour : date : La fonction renvoie une Date représentant la date de la veille par rapport à la date système actuelle.
      // Exemple :
      //	dDateHier est une date = Hier()
      //	INFO("Date hier : " + DateVersChaîne(dDateHier))
      //
      PROCEDURE Hier() : Date
      dAujourdhui est une Date = DateSys()
      dAujourdhui..Jour--
      RENVOYER dAujourdhui
     type : 458752
   -
     name : AvantHier
     procedure_id : 2024283816862299263
     type_code : 15
     group : 3
     code : |1-
      // Résumé : La fonction AvantHier renvoie la date correspondant à deux jours avant la date système actuelle.
      // Syntaxe : [ <Résultat> = ] AvantHier ()
      // Paramètres :
      //	Aucun
      // Valeur de retour : date : La fonction renvoie une Date représentant la date de deux jours avant la date système actuelle.
      // Exemple :
      //	dDateAvantHier est une date = AvantHier()
      //	INFO("Date avant-hier : " + DateVersChaîne(dDateAvantHier))
      //
      PROCEDURE AvantHier() : Date
      dAujourdhui est une Date = DateSys()
      dAujourdhui..Jour-=2
      RENVOYER dAujourdhui
     type : 458752
   -
     name : EntreGuillemets
     procedure_id : 2035501958202159258
     type_code : 15
     code : |1-
      // Résumé : La fonction permet d'entourer une chaîne de caractères avec des guillemets. Si la chaîne fournie en paramètre est vide, la fonction renvoie une paire de guillemets vides.
      // Syntaxe : [ <Résultat> = ] EntreGuillemets (<sContenu>)
      // Paramètres :
      // 	sContenu (chaîne UNICODE) : Une chaîne de caractères à entourer de guillemets.
      // Valeur de retour :
      // 	chaîne UNICODE : La fonction renvoie une chaîne de caractères avec le contenu entouré de guillemets. Si la chaîne initiale est vide, elle renvoie une paire de guillemets vides.
      //
      // Exemple :
      //	sTexte est une chaîne = "Bonjour, monde!"
      //	sTexteEntreGuillemets est une chaîne = EntreGuillemets(sTexte)
      //	INFO("Texte entre guillemets : " + sTexteEntreGuillemets)
      //	sTexteEntreGuillemets contiendra "Bonjour, monde!"
      //
      PROCEDURE EntreGuillemets(xContenu) : chaine
      si xContenu="" alors renvoyer cGénérique._Guillemet+cGénérique._Guillemet sinon RENVOYER [cGénérique._Guillemet]+xContenu+[cGénérique._Guillemet]
     type : 458752
   -
     name : StructureVersJSON
     procedure_id : 2040598430744499683
     type_code : 15
     code : |1+
      // Résumé : Cette procédure prend en entrée un élément (xElement) et un booléen (bBoucle), et elle renvoie une chaîne représentant les données de la structure au format JSON.
      // Syntaxe : [ <Résultat> = ] StructureVersJSON (<xElement> [, <bBoucle> est booléen])
      // Paramètres :
      // 	xElement : C'est l'élément à convertir en JSON.
      // 	bBoucle (booléen optionnel1) : Un paramètre booléen, par défaut à Vrai. Il contrôle si la boucle doit être exécutée.
      // Valeur de retour : chaîne UNICODE : Une chaîne représentant les données de la structure au format JSON.
      // Exemple :
      //	sJsonResultat = StructureVersJSON(monElement)
      //
      PROCEDURE StructureVersJSON(xElement,bBoucle est un booleen = vrai) : chaine
      sRésultat 		est une chaine
      
      //vTemp est un variant = xElement			//ne fonctionne pas avec les objets
      //renvoyer VariantVersJSON(vTemp)
      
      //bufRésultat est un buffer
      //serialise(xElement,bufRésultat,psdJSON)	//ne fonctionne pas avec les énumérations (WD21)
      //renvoyer UnicodeVersAnsi(bufRésultat)
      
      	
      
      <si CibleExécution=ApplicationWindows ou CibleExécution=Site ou CibleExécution=Webservice ou CibleExécution=AssemblageDotNet ou CibleExécution=ApplicationLinux64 ou CibleExécution=ServiceWindows ou CibleExécution=ServiceLinux64>
      	
      	sÉlément 		est une chaine
      	nTypeElement	est un entier
      	sTypeElement	est une chaine
      	
      	QUAND EXCEPTION DANS
      		defStructure 	est une Définition = RécupèreDéfinition(xElement)
      		si ErreurDétectée() alors renvoyer ""
      	FAIRE
      		renvoyer ""
      	fin
      	
      	si defStructure.Variable..Occurrence>0 alors
      		POUR i=1 _À_ defStructure.Variable..Occurrence
      			sÉlément=defStructure.Variable[i]..Nom
      			SI sÉlément~="m_pclApplication" _ou_ sÉlément~="_Application" ALORS CONTINUE 	//sinon tourne en boucle
      			//on évite les classes de bas niveau du Framework
      			SI defStructure.Variable[i]..Hérité _ET_ defStructure.Variable[i]..Déclaration..Nom DANS ("cGénérique","cEnregistrement","cSourceDeDonnées","cBaseDeDonnées","cSQL","cErreur") ALORS 
      				CONTINUE
      			sinon
      				sRésultat+=[","]+cGénérique._Guillemet+JSONEncode(defStructure.Variable[i]..Nom)+cGénérique._Guillemet+":"
      				quand exception dans
      					nTypeElement=defStructure.Variable[i]..Définition..Type;sTypeElement=TrouveType({"xElement."+defStructure.Variable[i]..Nom,indVariable},nTypeElement,defStructure.Variable[i]..Nom)
      					sRésultat+=TraiteObjet(nTypeElement,{"xElement."+defStructure.Variable[i]..Nom,indVariable},sTypeElement)
      				faire
      					sRésultat+="null"
      				fin
      			FIN
      		FIN
      		sRésultat=(bBoucle ? sRésultat SINON "{"+cGénérique._Guillemet+JSONEncode(defStructure..Nom)+cGénérique._Guillemet+":{"+sRésultat+"}")+"}"
      	sinon
      		SI defStructure..Nom="MembreVariant" ALORS
      			SI xElement..Occurrence>0 ALORS
      				POUR i=1 _À_ xElement..Occurrence
      					sRésultat+=[","]+cGénérique._Guillemet+JSONEncode(xElement..Membre[i]..Nom)+cGénérique._Guillemet+":"
      					nTypeElement=xElement..Membre[i]..Type;sTypeElement=TrouveType(xElement..Membre[i],nTypeElement,xElement..Membre[i]..Nom)
      					sRésultat+=TraiteObjet(nTypeElement,xElement..Membre[i],sTypeElement)
      				FIN
      				SI sRésultat="" ALORS sRésultat="null" SINON sRésultat="{"+sRésultat+"}"
      			SINON
      				QUAND EXCEPTION DANS
      					xElement..Valeur
      				FAIRE
      					nTypeElement= defStructure..Type;sTypeElement=TrouveType({defStructure..Nom},nTypeElement,defStructure..Nom)
      					sRésultat	= TraiteObjet(nTypeElement,defStructure..Valeur,sTypeElement)
      				SINON
      					nTypeElement= TypeVar(xElement);sTypeElement=TrouveType(xElement,nTypeElement,xElement..Nom)
      					sRésultat	= TraiteObjet(nTypeElement,xElement..Valeur,sTypeElement)
      				FIN
      			FIN
      		SINON
      			nTypeElement=TypeVar(xElement)
      			QUAND EXCEPTION DANS
      				sTypeElement= TrouveType(xElement,nTypeElement,xElement..Nom)
      			FAIRE
      				sRésultat	= TraiteObjet(nTypeElement,xElement,"")
      			SINON
      				sRésultat	= TraiteObjet(nTypeElement,xElement,sTypeElement)
      			FIN
      		FIN
      	fin
      	
      <sinon si CibleExécution=SitePHP ou CibleExécution=Java ou CibleExécution=Android ou CibleExécution=iOS ou CibleExécution=AppleWatch ou CibleExécution=UniversalWindowsApp ou CibleExécution=WindowsMobile>
      	sRésultat="<structure ou objet>"
      	
      <fin>
      
      	
      
      renvoyer sRésultat
      
      	PROCÉDURE INTERNE TrouveType(xVariable,nType,sNom)
      	sTypeVariable est une chaine
      	SI nType = wlInstance ALORS 
      		QUAND EXCEPTION DANS
      			sTypeVariable=xVariable..Classe
      		FAIRE
      //			wl.trace(sNom,nType)
      		FIN
      	FIN
      	RENVOYER sTypeVariable
      	FIN
      
      	procédure interne TraiteObjet(nType est un entier,xValeur,sType)
      	sRes				est une chaine
      	
      
      <si CibleExécution=ApplicationWindows ou CibleExécution=Site ou CibleExécution=Webservice ou CibleExécution=AssemblageDotNet ou CibleExécution=ApplicationLinux64 ou CibleExécution=ServiceWindows ou CibleExécution=ServiceLinux64>
      		
      		sÉlément,sValeur 	sont des chaines
      		nSousType 			est un entier
      		sousDef				est une Définition
      		
      		SELON nType
      			CAS wlChaîne,wlChaîneAnsi,wlChaîneUnicode,wlCaractère
      				QUAND EXCEPTION DANS
      					sRes=cGénérique._Guillemet+(xValeur~="" ? "" SINON JSONEncode(xValeur))+cGénérique._Guillemet
      				FAIRE
      					sRes=cGénérique._Guillemet+cGénérique._Guillemet
      				FIN
      			CAS wlEntierSansSigne_1 À wlEntier_8,wlMonétaire,wlNumérique,wlHandle,wlRéel,wlRéel_4,wlRéel_8 : sRes=xValeur
      			CAS wlBooléen					: sRes=(xValeur ? "vrai" SINON "faux")
      			CAS wlDate,wlHeure,wlDateHeure 	: sRes=cGénérique._Guillemet+JSONEncode(xValeur)+cGénérique._Guillemet
      			CAS wlVide 						: sRes="null"
      			CAS wlBuffer,wlMémoBinaire		: si xValeur>"" ALORS sRes=cGénérique._Guillemet+Encode(xValeur,encodeBASE64)+cGénérique._Guillemet SINON sRes="null"
      			CAS wlVariant					: sRes=VariantVersJSON(xValeur)
      			CAS wlEnumération,wlCombinaison	: sRes=cGénérique._Guillemet+JSONEncode(xValeur..Nom)+cGénérique._Guillemet
      			CAS wlVariantTableau,wlTableau,wlListe
      				POUR TOUT unElement DE xValeur
      					sValeur=StructureVersJSON(unElement)//;si position(sValeur,","+cGénérique._Guillemet)>0 alors sValeur="{"+sValeur
      					sRes+=[","]+sValeur
      				FIN
      				si sRes="" alors sRes="null" sinon sRes="["+sRes+"]"
      			cas wlTableauAssociatif
      				POUR TOUT unElement,sNom DE xValeur
      					sValeur=StructureVersJSON(unElement);si position(sValeur,","+cGénérique._Guillemet)>0 alors sValeur="{"+sValeur
      					sRes+=[","]+"{"+cGénérique._Guillemet+JSONEncode(sNom)+cGénérique._Guillemet+":"+sValeur+"}"
      				FIN
      				SI sRes="" ALORS sRes="null" SINON sRes="["+sRes+"]"
      			CAS wlConnexion		
      				QUAND EXCEPTION DANS
      					sConnexion est une chaine = cGénérique._Guillemet+"Utilisateur"+cGénérique._Guillemet+":"+cGénérique._Guillemet+JSONEncode(xValeur..Utilisateur)+cGénérique._Guillemet
      					sConnexion+=","+cGénérique._Guillemet+"Serveur"+cGénérique._Guillemet+":"+cGénérique._Guillemet+JSONEncode(xValeur..Serveur)+cGénérique._Guillemet
      					sConnexion+=","+cGénérique._Guillemet+"BaseDeDonn\u00e9es"+cGénérique._Guillemet+":"+cGénérique._Guillemet+JSONEncode(xValeur..BaseDeDonnées)+cGénérique._Guillemet
      					sConnexion+=","+cGénérique._Guillemet+"Provider"+cGénérique._Guillemet+":"+cGénérique._Guillemet+JSONEncode(UnicodeVersAnsi(xValeur..Provider))+cGénérique._Guillemet
      					sConnexion+=","+cGénérique._Guillemet+"Acc\u00e8s"+cGénérique._Guillemet+":"+cGénérique._Guillemet+JSONEncode(xValeur..Accès)+cGénérique._Guillemet
      					sConnexion+=","+cGénérique._Guillemet+"Infos\u00c9tendues"+cGénérique._Guillemet+":"+cGénérique._Guillemet+JSONEncode(UnicodeVersAnsi(xValeur..InfosEtendues))+cGénérique._Guillemet
      					sConnexion+=","+cGénérique._Guillemet+"OptionsCurseur"+cGénérique._Guillemet+":"+cGénérique._Guillemet+JSONEncode(UnicodeVersAnsi(xValeur..OptionsCurseur))+cGénérique._Guillemet
      				FAIRE
      					RENVOYER ""
      				sinon 
      					sRes="{"+sConnexion+"}"
      				FIN
      			CAS wlTypeAvancé				//ou wlOnNeSaitPas = 111
      				sDéfinition est une chaine
      				QUAND EXCEPTION DANS
      					sDéfinition=cGénérique._Guillemet+"D\u00e9finitionBase"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..DéfinitionBase)
      					sDéfinition+=","+cGénérique._Guillemet+"D\u00e9finitionAssociation"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..DéfinitionAssociation)
      					sDéfinition+=","+cGénérique._Guillemet+"FamilleD\u00e9finition"+cGénérique._Guillemet+":"+xValeur..FamilleDéfinition
      					sDéfinition+=","+cGénérique._Guillemet+"Nom"+cGénérique._Guillemet+":"+xValeur..Nom
      					sDéfinition+=","+cGénérique._Guillemet+"Option"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..Option)
      					sDéfinition+=","+cGénérique._Guillemet+"Procédure"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..Procédure)
      					sDéfinition+=","+cGénérique._Guillemet+"Propri\u00e9t\u00e9"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..Propriété)
      					sDéfinition+=","+cGénérique._Guillemet+"Type"+cGénérique._Guillemet+":"+xValeur..Type
      					sDéfinition+=","+cGénérique._Guillemet+"Valeur"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..Valeur)
      					sDéfinition+=","+cGénérique._Guillemet+"Variable"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..Variable)
      				FAIRE
      					//rien on va passer au type suivant
      				SINON
      					sRes="{"+sDéfinition+"}"
      				FIN
      				
      				SI sRes="" ALORS
      					sOAuth est une chaine
      					QUAND EXCEPTION DANS
      						sOAuth=cGénérique._Guillemet+"ClientID"+cGénérique._Guillemet+":"+cGénérique._Guillemet+JSONEncode(xValeur..ClientID)+cGénérique._Guillemet
      						sOAuth+=","+cGénérique._Guillemet+"ClientSecret"+cGénérique._Guillemet+":"+cGénérique._Guillemet+JSONEncode(xValeur..ClientSecret)+cGénérique._Guillemet
      						sOAuth+=","+cGénérique._Guillemet+"Param\u00e8tresSuppl\u00e9mentaires"+cGénérique._Guillemet+":"+cGénérique._Guillemet+JSONEncode(xValeur..ParamètresSupplémentaires)+cGénérique._Guillemet
      						sOAuth+=","+cGénérique._Guillemet+"Scope"+cGénérique._Guillemet+":"+cGénérique._Guillemet+JSONEncode(xValeur..Scope)+cGénérique._Guillemet
      						sOAuth+=","+cGénérique._Guillemet+"URLAuth"+cGénérique._Guillemet+":"+cGénérique._Guillemet+JSONEncode(xValeur..URLAuth)+cGénérique._Guillemet
      						sOAuth+=","+cGénérique._Guillemet+"URLRedirection"+cGénérique._Guillemet+":"+cGénérique._Guillemet+JSONEncode(xValeur..URLRedirection)+cGénérique._Guillemet
      						sOAuth+=","+cGénérique._Guillemet+"URLToken"+cGénérique._Guillemet+":"+cGénérique._Guillemet+JSONEncode(xValeur..URLToken)+cGénérique._Guillemet
      					FAIRE
      						//rien on va passer au type suivant
      					sinon
      						sRes="{"+sOAuth+"}"
      					FIN
      				FIN
      				
      				SI sRes="" ALORS
      					sImage est une chaine
      					QUAND EXCEPTION DANS
      						sImage = cGénérique._Guillemet+"Valide"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..Valide)
      						si xValeur..valide alors
      							sImage += "," + cGénérique._Guillemet+"AvecAlpha"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..AvecAlpha)
      							sImage += "," + cGénérique._Guillemet+"BitParPixel"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..BitParPixel)
      							sImage += "," + cGénérique._Guillemet+"CouleurRemplissage.Couleur"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..CouleurRemplissage..Couleur)
      							sImage += "," + cGénérique._Guillemet+"CouleurRemplissage.Opacit\u00e9"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..CouleurRemplissage..Opacité)
      							sImage += "," + cGénérique._Guillemet+"EchelleDessin"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..EchelleDessin)
      							sImage += "," + cGénérique._Guillemet+"Hauteur"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..Hauteur)
      							sImage += "," + cGénérique._Guillemet+"Largeur"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..Largeur)
      						fin
      					FAIRE
      						//rien on va passer au type suivant
      					SINON
      						sRes="{"+sImage+"}"
      					FIN
      				FIN
      				
      				SI sRes="" ALORS
      					sEmail est une chaîne
      					QUAND EXCEPTION DANS
      						sEmail = cGénérique._Guillemet+"AccuséRéception"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..AccuséRéception)
      						sEmail += "," + cGénérique._Guillemet+"AdresseExpéditeur"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..AdresseExpéditeur)
      						sEmail += "," + cGénérique._Guillemet+"Attache"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..Attache)
      						sEmail += "," + cGénérique._Guillemet+"Catégorie"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..Catégorie)
      						sEmail += "," + cGénérique._Guillemet+"Cc"+cGénérique._Guillemet+":"+StructureVersJSON(TableauVersCSV(xValeur..Cc))
      						sEmail += "," + cGénérique._Guillemet+"Cci"+cGénérique._Guillemet+":"+StructureVersJSON(TableauVersCSV(xValeur..Cci))
      	//					sEmail += "," + cGénérique._Guillemet+"Certificat"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..Certificat)	//erreur par dépassement de pile
      						sEmail += "," + cGénérique._Guillemet+"Confidentialité"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..Confidentialité)
      						sEmail += "," + cGénérique._Guillemet+"ConfirmationLecture"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..ConfirmationLecture)
      						sEmail += "," + cGénérique._Guillemet+"DateRéception"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..DateRéception)
      						sEmail += "," + cGénérique._Guillemet+"Destinataire"+cGénérique._Guillemet+":"+StructureVersJSON(TableauVersCSV(xValeur..Destinataire))
      						sEmail += "," + cGénérique._Guillemet+"Entête"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..Entête)
      						sEmail += "," + cGénérique._Guillemet+"Expéditeur"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..Expediteur)
      						sEmail += "," + cGénérique._Guillemet+"HTML"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..HTML)
      						sEmail += "," + cGénérique._Guillemet+"ID"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..ID)
      						sEmail += "," + cGénérique._Guillemet+"Message"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..Message)
      						sEmail += "," + cGénérique._Guillemet+"MessageID"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..MessageID)
      						sEmail += "," + cGénérique._Guillemet+"Priorité"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..Priorité)
      						sEmail += "," + cGénérique._Guillemet+"Référence"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..Référence)
      						sEmail += "," + cGénérique._Guillemet+"Signature"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..Signature)
      						sEmail += "," + cGénérique._Guillemet+"Source"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..Source)
      						sEmail += "," + cGénérique._Guillemet+"Sujet"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..Sujet)
      						sEmail += "," + cGénérique._Guillemet+"TexteBrut"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..TexteBrut)
      					FAIRE
      						//rien on va passer au type suivant
      					SINON
      						sRes="{"+sEmail+"}"
      					FIN
      				FIN
      				
      				SI sRes="" ALORS
      					sEmail est une chaine
      					QUAND EXCEPTION DANS
      						sEmail = cGénérique._Guillemet+"AccuséRéception"+cGénérique._Guillemet+":"+JSONEncode(Email.AccuséRéception)
      						sEmail += "," + cGénérique._Guillemet+"AdresseExpéditeur"+cGénérique._Guillemet+":"+cGénérique._Guillemet+JSONEncode(Email.AdresseExpéditeur)+cGénérique._Guillemet
      						sEmail += "," + cGénérique._Guillemet+"Attache"+cGénérique._Guillemet+":"+StructureVersJSON(TableauVersCSV(Email.Attache,";",Email.NbAttache))
      						sEmail += "," + cGénérique._Guillemet+"Catégorie"+cGénérique._Guillemet+":"+cGénérique._Guillemet+JSONEncode(Email.Catégorie)+cGénérique._Guillemet
      						sEmail += "," + cGénérique._Guillemet+"Cc"+cGénérique._Guillemet+":"+StructureVersJSON(TableauVersCSV(Email.Cc,";",Email.NbCc))
      						sEmail += "," + cGénérique._Guillemet+"Cci"+cGénérique._Guillemet+":"+StructureVersJSON(TableauVersCSV(Email.Cci,";",Email.NbCci))
      						sEmail += "," + cGénérique._Guillemet+"Certificat"+cGénérique._Guillemet+":"+StructureVersJSON(Email.Certificat)
      						sEmail += "," + cGénérique._Guillemet+"Confidentialité"+cGénérique._Guillemet+":"+JSONEncode(Email.Confidentialité)
      						sEmail += "," + cGénérique._Guillemet+"ConfirmationLecture"+cGénérique._Guillemet+":"+JSONEncode(Email.ConfirmationLecture)
      						sEmail += "," + cGénérique._Guillemet+"DateRéception"+cGénérique._Guillemet+":"+cGénérique._Guillemet+JSONEncode(Email.DateRéception)+cGénérique._Guillemet
      						sEmail += "," + cGénérique._Guillemet+"Destinataire"+cGénérique._Guillemet+":"+StructureVersJSON(TableauVersCSV(Email.Destinataire,";",Email.NbDestinataire))
      						sEmail += "," + cGénérique._Guillemet+"Expéditeur"+cGénérique._Guillemet+":"+cGénérique._Guillemet+JSONEncode(Email.Expéditeur)+cGénérique._Guillemet
      						sEmail += "," + cGénérique._Guillemet+"HTML"+cGénérique._Guillemet+":"+cGénérique._Guillemet+JSONEncode(Email.HTML)+cGénérique._Guillemet
      						sEmail += "," + cGénérique._Guillemet+"ID"+cGénérique._Guillemet+":"+cGénérique._Guillemet+JSONEncode(Email.ID)+cGénérique._Guillemet
      						sEmail += "," + cGénérique._Guillemet+"Message"+cGénérique._Guillemet+":"+cGénérique._Guillemet+JSONEncode(Email.Message)+cGénérique._Guillemet
      						sEmail += "," + cGénérique._Guillemet+"MessageID"+cGénérique._Guillemet+":"+cGénérique._Guillemet+JSONEncode(Email.MessageID)+cGénérique._Guillemet
      						sEmail += "," + cGénérique._Guillemet+"Priorité"+cGénérique._Guillemet+":"+JSONEncode(Email.Priorité)
      						sEmail += "," + cGénérique._Guillemet+"Référence"+cGénérique._Guillemet+":"+cGénérique._Guillemet+JSONEncode(Email.Référence)+cGénérique._Guillemet
      						sEmail += "," + cGénérique._Guillemet+"Signature"+cGénérique._Guillemet+":"+JSONEncode(Email.Signature)
      						sEmail += "," + cGénérique._Guillemet+"Source"+cGénérique._Guillemet+":"+cGénérique._Guillemet+JSONEncode(Email.Source)+cGénérique._Guillemet
      						sEmail += "," + cGénérique._Guillemet+"Sujet"+cGénérique._Guillemet+":"+cGénérique._Guillemet+JSONEncode(Email.Sujet)+cGénérique._Guillemet
      						sEmail += "," + cGénérique._Guillemet+"TexteBrut"+cGénérique._Guillemet+":"+cGénérique._Guillemet+JSONEncode(Email.TexteBrut)+cGénérique._Guillemet
      					FAIRE
      						//rien on va passer au type suivant
      					SINON
      						sEmailVide est une chaine = [
      							{"AccuséRéception":0,"AdresseExpéditeur":"","Attache":"","Catégorie":"","Cc":"","Cci":"","Certificat":{"DateValiditéDébut":"00000000000000000","DateValiditéFin":"00000000000000000","Emetteur":"","EmetteurComplet":"","Empreinte":"","Fiabilité":0,"Nom":"","NuméroSérie":"","Objet":"","ValidePourSignature":false},"Confidentialité":0,"ConfirmationLecture":0,"DateRéception":"","Destinataire":"","Expéditeur":"","HTML":"","ID":"","Message":"","MessageID":"","Priorité":100,"Référence":"","Signature":2,"Source":"","Sujet":"","TexteBrut":""}
      						]
      						SI semail<>sEmailVide ALORS	sRes="{"+sEmail+"}"
      					FIN
      				FIN
      				
      				SI sRes="" ALORS
      					sCertificat est une chaîne
      					QUAND EXCEPTION DANS
      						sCertificat = cGénérique._Guillemet+"DateValiditéDébut"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..DateValiditéDébut)
      						sCertificat += "," + cGénérique._Guillemet+"DateValiditéFin"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..DateValiditéFin)
      						sCertificat += "," + cGénérique._Guillemet+"Emetteur"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..Emetteur)
      						sCertificat += "," + cGénérique._Guillemet+"EmetteurComplet"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..EmetteurComplet)
      						sCertificat += "," + cGénérique._Guillemet+"Empreinte"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..Empreinte)
      						sCertificat += "," + cGénérique._Guillemet+"Fiabilité"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..Fiabilité)
      						sCertificat += "," + cGénérique._Guillemet+"Nom"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..Nom)
      						sCertificat += "," + cGénérique._Guillemet+"NuméroSérie"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..NuméroSérie)
      						sCertificat += "," + cGénérique._Guillemet+"Objet"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..Objet)
      						sCertificat += "," + cGénérique._Guillemet+"ValidePourSignature"+cGénérique._Guillemet+":"+StructureVersJSON(xValeur..ValidePourSignature)
      					FAIRE
      						//rien on va passer au type suivant
      					SINON
      						sRes="{"+sCertificat+"}"
      					FIN
      				FIN
      				
      				SI sRes="" ALORS sRes="¤"
      				//autres types selon expérience (car pas documenté)
      			CAS wlPoint						: sRes="{"+cGénérique._Guillemet+"X"+cGénérique._Guillemet+":"+xValeur..X+","+cGénérique._Guillemet+"Y"+cGénérique._Guillemet+":"+xValeur..Y+"}"
      			CAS wlAutomation				: sRes=cGénérique._Guillemet+"<objet automation>"+cGénérique._Guillemet
      			CAS wlChamp						: 
      				quand exception dans
      					sChamp est une chaine=cGénérique._Guillemet+"Type"+cGénérique._Guillemet+":"+cGénérique._Guillemet+JSONEncode(TypeChampVersNom(xValeur..type))+cGénérique._Guillemet
      					sChamp+=","+cGénérique._Guillemet+"Libellé"+cGénérique._Guillemet+":"+cGénérique._Guillemet+JSONEncode(xValeur..libelle)+cGénérique._Guillemet
      					sChamp+=","+cGénérique._Guillemet+"X"+cGénérique._Guillemet+":"+xValeur..x
      					sChamp+=","+cGénérique._Guillemet+"Y"+cGénérique._Guillemet+":"+xValeur..Y
      					sChamp+=","+cGénérique._Guillemet+"Hauteur"+cGénérique._Guillemet+":"+xValeur..hauteur
      					sChamp+=","+cGénérique._Guillemet+"Largeur"+cGénérique._Guillemet+":"+xValeur..Largeur
      				faire
      					//rien
      				sinon
      					sRes="{"+sChamp+"}"
      				fin
      			CAS wlChampOLE					: sRes=cGénérique._Guillemet+"<champ OLE>"+cGénérique._Guillemet
      			CAS wlDescriptionFichier		: sRes=cGénérique._Guillemet+"<description de fichier>"+cGénérique._Guillemet
      			CAS wlDescriptionLiaison		: sRes=cGénérique._Guillemet+"<description de liaison>"+cGénérique._Guillemet
      			CAS wlDescriptionRubrique		: sRes=cGénérique._Guillemet+"<description de rubrique>"+cGénérique._Guillemet
      			CAS wlObjetDotNet				: sRes=cGénérique._Guillemet+"<objet .net>"+cGénérique._Guillemet
      			CAS wlPolice					: sRes=cGénérique._Guillemet+"<police>"+cGénérique._Guillemet
      			CAS wlProcédure					: sRes=cGénérique._Guillemet+"<proc\u00e9dure>"+cGénérique._Guillemet
      			CAS wlRectangle					: 
      				sRes="{"+cGénérique._Guillemet+"X"+cGénérique._Guillemet+":"+xValeur..X+","+cGénérique._Guillemet+"Y"+cGénérique._Guillemet+":"+xValeur..Y
      				sRes+=","+cGénérique._Guillemet+"Largeur"+cGénérique._Guillemet+":"+xValeur..Largeur+","+cGénérique._Guillemet+"Hauteur"+cGénérique._Guillemet+":"+xValeur..hauteur+"}"
      			CAS wlSourceDeDonnées			: sRes=cGénérique._Guillemet+"<source de donn\u00e9es>"+cGénérique._Guillemet
      			CAS wlInstance,wlStructure,wlVariableComposée
      				SI sType="" _OU_ xValeur=Null ALORS RENVOYER "null"
      				quand exception dans
      					defSousStructure 	est une définition = RécupèreDéfinition(xValeur)
      					nDefOccurrence 		est un entier = defSousStructure.Variable..Occurrence
      				FAIRE
      					RENVOYER ""
      				sinon
      					si nDefOccurrence=0 alors RENVOYER ""
      				FIN
      				POUR j=1 _À_ nDefOccurrence
      					SI defSousStructure.Variable[j]..Nom dans ("m_pclApplication","_Application") ALORS CONTINUE 	//sinon tourne en boucle
      					SI defSousStructure.Variable[j]..Nom = "m_clJauge" ALORS CONTINUE 	//élément de GUI n'ayant rien à faire dans un JSON
      					SI defSousStructure.Variable[j]..Nom dans ("m_pclTable","m_pclErreur","m_tabEnregistrement") ALORS CONTINUE 	//élément interne
      					SI defSousStructure.Variable[j]..Nom DANS ("m_nNiveauClassique","m_nNiveauHyperFile","m_coAttributsJSON") ALORS CONTINUE	//membre de cErreur inutiles dans un JSON
      					sÉlément="xValeur."+defSousStructure.Variable[j]..Nom;sValeur=""
      					QUAND EXCEPTION DANS
      						SI typevar({sÉlément,indVariable}..nom) dans (wldate,wlDateHeure,wlheure) _et_ {sÉlément,indVariable}=Null ALORS sValeur="null"
      					FAIRE
      						sValeur="null"
      					fin
      					quand exception dans
      						SI sValeur="" _ET_ defSousStructure.Variable[j]<>Null _ET_ TypeVar(defSousStructure.Variable[j])<>wlOnNeSaitPas ALORS 
      							sousDef		= defSousStructure.Variable[j]..Définition
      							nSousType	= TypeVar(defSousStructure.Variable[j])	//sousDef..Type
      							sValeur		= TraiteObjet(nSousType,{sÉlément,indVariable},trouvetype(defSousStructure.Variable[j],nSousType,defSousStructure.Variable[j]..Nom))
      						FIN
      					faire
      						//rien
      					fin
      					SI sValeur="" ALORS sValeur="null"
      					sRes+=[","]+cGénérique._Guillemet+JSONEncode(UnicodeVersAnsi(defSousStructure.Variable[j]..Nom))+cGénérique._Guillemet+":"+sValeur
      				fin                                                              
      				sRes="{"+sRes+"}"
      			AUTRES CAS						: sRes=cGénérique._Guillemet+JSONEncode(xValeur)+cGénérique._Guillemet
      	FIN
      	
      <fin>
      
      	
      	renvoyer sRes	
      	FIN
     type : 458752
   -
     name : ConvertiInformatique
     procedure_id : 2052226633863344836
     type_code : 15
     group : 1
     code : |1-
      // Résumé : La fonction ConvertiInformatique est une procédure dans le langage de développement WinDev du framework. Elle permet de convertir une valeur numérique d'une unité informatique à une autre avec la possibilité de spécifier des multiplicateurs et un niveau d'arrondi.
      //	La différence avec la fonction Conversion() est qu'on peut spécifier ici le multiplicateur, les unités et multiplicateurs sont des énumérations et non des chaines (qui peuvent introduire un risque d'erreur), il y a plus de conversions possibles (et vous pouvez en ajouter) et vous pouvez vérifier/modifier le facteur entre deux unités.
      // Syntaxe : [ <Résultat> = ] ConvertiInformatique (<rValeur> est réel, <eUnitéDépart> est COL_Conversion.EUnitéInformatique [, <eUnitéFinale> est COL_Conversion.EUnitéInformatique [, <eMultiplicateurDépart> est COL_Conversion.EMultiInformatique [, <eMultiplicateurFinal> est COL_Conversion.EMultiInformatique [, <nArrondi> est entier]]]])
      // Paramètres :
      //	rValeur (réel) : La valeur numérique à convertir.
      //	eUnitéDépart (COL_Conversion.EUnitéInformatique) : L'unité informatique de départ.
      //	eUnitéFinale (COL_Conversion.EUnitéInformatique) : L'unité informatique cible de la conversion, par défaut=octet.
      //	eMultiplicateurDépart (COL_Conversion.EMultiInformatique optionnel): Le multiplicateur associé à l'unité de départe, par défaut=EMultiInformatique.Aucun.
      //	eMultiplicateurFinal (COL_Conversion.EMultiInformatique optionnel): Le multiplicateur associé à l'unité cible, par défaut=EMultiInformatique.Aucun.
      // 	nArrondi (entier optionnel): Le niveau d'arrondi à appliquer à la valeur convertie, par défaut=-1.
      // Valeur de retour : réel : La valeur convertie selon les paramètres spécifiés.
      // Exemple :
      // Indiquez ici un exemple d'utilisation.
      //	rValeurConvertie est un réel = ConvertiInformatique(1024,EUnitéInformatique.octet_,EUnitéInformatique.bit,EMultiInformatique.kilo, EMultiInformatique.mega)
      //	rValeurConvertie contiendra 8
      //
      PROCEDURE ConvertiInformatique(LOCAL rValeur est un réel,eUnitéDépart est EUnitéInformatique,eUnitéFinale est un EUnitéInformatique = octet_,eMultiplicateurDépart est un EMultiInformatique = EMultiInformatique.Aucun,eMultiplicateurFinal est un EMultiInformatique = EMultiInformatique.Aucun,nArrondi est un entier=-1) : reel
      RENVOYER ConvertiUnité(rValeur,eUnitéDépart..Valeur,eUnitéFinale..Valeur,eMultiplicateurDépart..valeur,eMultiplicateurFinal..valeur,nArrondi)
     type : 458752
   -
     name : ConvertiÉnergie
     procedure_id : 2078807198348079820
     type_code : 15
     group : 1
     code : |1-
      // Résumé : La fonction est une procédure dans le langage de développement WinDev du framework. Elle permet de convertir une valeur numérique d'une unité d'énergie à une autre avec la possibilité de spécifier des multiplicateurs et un niveau d'arrondi.
      //	La différence avec la fonction Conversion() est qu'on peut spécifier ici le multiplicateur, les unités et multiplicateurs sont des énumérations et non des chaines (qui peuvent introduire un risque d'erreur), il y a plus de conversions possibles (et vous pouvez en ajouter) et vous pouvez vérifier/modifier le facteur entre deux unités.
      // Syntaxe : [ <Résultat> = ] ConvertiÉnergie (<rValeur> est réel, <eUnitéDépart> est COL_Conversion.EUnitéÉnergie [, <eUnitéFinale> est COL_Conversion.EUnitéÉnergie [, <eMultiplicateurDépart> est COL_Conversion.EMultiplicateur [, <eMultiplicateurFinal> est COL_Conversion.EMultiplicateur [, <nArrondi> est entier]]]])
      // Paramètres :
      //	rValeur (réel) : La valeur numérique à convertir.
      //	eUnitéDépart (COL_Conversion.EUnitéÉnergie) : L'unité d'énergie de départ.
      //	eUnitéFinale (COL_Conversion.EUnitéÉnergie) : optionnel): L'unité d'énergie cible de la conversion, par défaut=KiloWattHeure.
      //	eMultiplicateurDépart (COL_Conversion.EMultiplicateur optionnel) : Le multiplicateur associé à l'unité de départ, par défaut=EMultiplicateur.Aucun.
      //	eMultiplicateurFinal (COL_Conversion.EMultiplicateur optionnel): Le multiplicateur associé à l'unité cible, par défaut=EMultiplicateur.Aucun.
      // 	nArrondi (entier optionnel): Le niveau d'arrondi à appliquer à la valeur convertie, par défaut=-1.
      // Valeur de retour : réel : La valeur convertie selon les paramètres spécifiés.
      // Exemple :
      //	rValeurConvertie est un réel = ConvertiÉnergie(1000, EUnitéÉnergie.Joule, EUnitéÉnergie.Calorie)
      //	rValeurConvertie contiendra 238.9200812328
      //
      PROCEDURE ConvertiÉnergie(LOCAL rValeur est un réel,eUnitéDépart est EUnitéÉnergie,eUnitéFinale est un EUnitéÉnergie = KiloWattHeure,eMultiplicateurDépart est un EMultiplicateur = EMultiplicateur.Aucun,eMultiplicateurFinal est un EMultiplicateur = EMultiplicateur.Aucun,nArrondi est un entier=-1) : réel
      RENVOYER ConvertiUnité(rValeur,eUnitéDépart..Valeur,eUnitéFinale..Valeur,eMultiplicateurDépart..Valeur,eMultiplicateurFinal..Valeur,nArrondi)
     type : 458752
   -
     name : ConvertiConsommation
     procedure_id : 2078810574192439981
     type_code : 15
     group : 1
     code : |1-
      // Résumé : La fonction permet de convertir une valeur numérique d'une unité de consommation à une autre avec la possibilité de spécifier des multiplicateurs et un niveau d'arrondi.
      //	La différence avec la fonction Conversion() est qu'on peut spécifier ici le multiplicateur, les unités et multiplicateurs sont des énumérations et non des chaines (qui peuvent introduire un risque d'erreur), il y a plus de conversions possibles (et vous pouvez en ajouter) et vous pouvez vérifier/modifier le facteur entre deux unités.
      // Syntaxe : [ <Résultat> = ] ConvertiConsommation (<rValeur> est réel, <eUnitéDépart> est COL_Conversion.EUnitéConsommation [, <eUnitéFinale> est COL_Conversion.EUnitéConsommation [, <eMultiplicateurDépart> est COL_Conversion.EMultiplicateur [, <eMultiplicateurFinal> est COL_Conversion.EMultiplicateur [, <nArrondi> est entier]]]])
      // Paramètres :
      //	rValeur (réel) : La valeur numérique à convertir.
      //	eUnitéDépart (COL_Conversion.EUnitéConsommation) : L'unité de consommation de départ.
      //	eUnitéFinale (COL_Conversion.EUnitéConsommation optionnel): L'unité de consommation cible de la conversion, par défaut=LitrePar1km.
      //	eMultiplicateurDépart (COL_Conversion.EMultiplicateur optionnel) : Le multiplicateur associé à l'unité de départ, par défaut=EMultiplicateur.Aucun.
      //	eMultiplicateurFinal (COL_Conversion.EMultiplicateur optionnel): Le multiplicateur associé à l'unité cible, par défaut=EMultiplicateur.Aucun.
      // 	nArrondi (entier optionnel): Le niveau d'arrondi à appliquer à la valeur convertie, par défaut=-1.
      // Valeur de retour : réel : La valeur convertie selon les paramètres spécifiés.
      // Exemple :
      //	rValeurConvertie est un réel = ConvertiConsommation(10, EUnitéConsommation.LitrePar100km, EUnitéConsommation.MileParGallonUS)
      //	rValeurConvertie contiendra 425.1447617914
      //
      PROCEDURE ConvertiConsommation(LOCAL rValeur est un réel,eUnitéDépart est EUnitéConsommation,eUnitéFinale est un EUnitéConsommation = LitrePar1km,eMultiplicateurDépart est un EMultiplicateur = EMultiplicateur.Aucun,eMultiplicateurFinal est un EMultiplicateur = EMultiplicateur.Aucun,nArrondi est un entier=-1) : réel
      RENVOYER ConvertiUnité(rValeur,eUnitéDépart..Valeur,eUnitéFinale..Valeur,eMultiplicateurDépart..Valeur,eMultiplicateurFinal..Valeur,nArrondi)
     type : 458752
   -
     name : WGS84VersLambert93
     procedure_id : 2078812197690127384
     type_code : 15
     code : |1-
      // Résumé : La fonction réalise la conversion des coordonnées géographiques d'un système de coordonnées WGS84 (latitude et longitude) vers le système de coordonnées Lambert 93 (X et Y en mètres).
      // Syntaxe : [ <Résultat> = ] LambertVersWGS84 (<rLatitude>, <rLongitude>, <eTypeLambert> est COL_Conversion.ETypeCoordonnéesLambert)
      // Paramètres :
      // 	rLatitude : La latitude du point en degrés.
      // 	rLongitude : La longitude du point en degrés.
      //	eTypeLambert (COL_Conversion.ETypeCoordonnéesLambert) : Description: Les coordonnées converties dans le système Lambert 93.
      // Valeur de retour : multi-valeur (réel, réel) : Les coordonnées converties dans le système Lambert 93.
      // Exemple :
      // Indiquez ici un exemple d'utilisation.
      //	rLatitudePoint est un réel = 48.8566
      //	rLongitudePoint est un réel = 2.3522
      //	rX, rY sont des réels
      //	(rX, rY) = WGS84VersLambert93(rLatitudePoint, rLongitudePoint)
      
      //=================== EN TEST ========================
      PROCEDURE WGS84VersLambert93(rLatitude est un réel,rLongitude est un réel) : (réel,réel)
      //ref : https://forum.pcsoft.fr/fr-FR/pcsoft.fr.windev/115029-wd14-wgs84-lambert93/read.awp		
      
      rn,rcc,rys,rRgl,rRgl0,rgl1,rRgl2,rRx93,rRy93 sont des réels sur 8
      rlc,rl,rPhi,rPhi0,rPhi1,rPhi2,rx0,rRy0,rgN1,rgN2 sont des réels
      
      //système WGS84
      ra est un réel sur 8 octets = 6378137 			//demi grand axe de l'ellipsoïde (m)
      re est un réel sur 8 octets = 0.08181919106 	//première excentricité de l'ellipsoïde
      
      //paramètres de projections
      
      rlc		= 3 		//longitude de référence			
      rPhi0	= 46.5 		//latitude d'origine en radian
      rPhi1	= 44 		//1er parallèle automcoque
      rPhi2	= 49 		//2ème parallèle automcoque
      
      rx0		= 700000	//coordonnées à l'origine
      rRy0	= 6600000 	//coordonnées à l'origine
      
      //coordonnées du point à traduire
      rPhi	= rLatitude
      rl		= rLongitude
      
      //calcul des grandes normales
      rgN1	= ra/Racine(1-re*re*Sin(rPhi1)*Sin(rPhi1))
      rgN2	= ra/Racine(1-re*re*Sin(rPhi2)*Sin(rPhi2))
      
      //calculs des latitudes isométriques
      rgl1	= Log(Tang(45+rPhi1/2)*Puissance((1-re*Sin(rPhi1))/(1+re*Sin(rPhi1)),re/2))
      rRgl2	= Log(Tang(45+rPhi2/2)*Puissance((1-re*Sin(rPhi2))/(1+re*Sin(rPhi2)),re/2))
      rRgl0	= Log(Tang(45+rPhi0/2)*Puissance((1-re*Sin(rPhi0))/(1+re*Sin(rPhi0)),re/2))
      rRgl	= Log(Tang(45+rPhi/2)*Puissance((1-re*Sin(rPhi))/(1+re*Sin(rPhi)),re/2))
      
      
      rn		= (Log((rgN2*Cos(rPhi2))/(rgN1*Cos(rPhi1))))/(rgl1-rRgl2)	//calcul de l'exposant de la projection
      
      rcc		= ((rgN1*Cos(rPhi1))/rn)*Exp(rn*rgl1)						//calcul de la constante de projection
      
      
      rys		= rRy0+rcc*Exp(-1*rn*rRgl0)									//calcul des coordonnées
      
      //calcul des coordonnées Lambert 93
      rRx93	= rx0+rcc*Exp(-1*rn*rRgl)*Sin(rn*(rl-rlc))
      rRy93	= rys-rcc*Exp(-1*rn*rRgl)*Cos(rn*(rl-rlc))
      
      renvoyer (rRx93,rRy93)
     type : 458752
   -
     name : LambertVersWGS84
     procedure_id : 2078836382654898143
     type_code : 15
     code : |1-
      // Résumé : La fonction permet de convertir les coordonnées cartésiennes du système Lambert I, II, IIétendu, III, IV et 93 vers les coordonnées géographiques du système WGS84 (latitude et longitude).
      // Syntaxe : [ <Résultat> = ] LambertVersWGS84 (<rLatitude>, <rLongitude>, <eTypeLambert> est COL_Conversion.ETypeCoordonnéesLambert)
      // Paramètres :
      // 	rLatitude (réel) : La latitude du point en degrés.
      // 	rLongitude (réel) : La longitude du point en degrés.
      //	eTypeLambert (COL_Conversion.ETypeCoordonnéesLambert) : Le type de coordonnées Lambert spécifié.
      // Valeur de retour : multi-valeur (réel, réel) : Les coordonnées géographiques converties dans le système WGS84.
      // Exemple :
      //	rX_Lambert93 est un réel = 652384.12
      //	rY_Lambert93 est un réel = 6864394.23
      //	rLatitude, rLongitude sont des réels
      //	(rLatitude, rLongitude) = LambertVersWGS84(rX_Lambert93, rY_Lambert93, ETypeCoordonnéesLambert.Lambert93)
      //
      PROCEDURE LambertVersWGS84(rLatitude est un réel,rLongitude est un réel,eTypeLambert est un ETypeCoordonnéesLambert) : (réel,réel)	//ATTENTION, une divergence avec geoFree (http://www.catco.fr) a été constatée
      //ref : https://gist.github.com/lovasoa/096d8be82520ea6b0abe
      Ntabs 	est un tableau de réels = [0.7604059656, 0.7289686274, 0.6959127966, 0.6712679322, 0.7289686274, 0.7256077650]
      Ctabs 	est un tableau de réels = [11603796.98, 11745793.39, 11947992.52, 12136281.99, 11745793.39, 11754255.426]
      Xstabs 	est un tableau de réels = [600000.0, 600000.0, 600000.0, 234.358, 600000.0, 700000.0]
      Ystabs 	est un tableau de réels = [5657616.674, 6199695.768, 6791905.085, 7239161.542, 8199695.768, 12655612.050]
      
      n est un réel 		= Ntabs[eTypeLambert..valeur]
      c est un réel 		= Ctabs[eTypeLambert..valeur]
      xs est un réel 		= Xstabs[eTypeLambert..valeur]
      ys est un réel 		= Ystabs[eTypeLambert..valeur]
                      	
      l0 est un réel		= 0.0				//correspond à la longitude en radian de Paris (2°20'14.025" E) par rapport à Greenwich
      e est un réel		= 0.08181919106     //e du NTF (on le change après pour passer en WGS)
      eps est un réel		= 0.00001     		//précision
      
      //Conversion Lambert 2 -> NTF géographique : ALG0004
      R est un reel 		= racine(((rLatitude - xs) * (rLatitude - xs)) + ((rLongitude - ys) * (rLongitude - ys)))
      g est un reel 		= Arctan((rLatitude - xs) / (ys - rLongitude))*EUnitéAngle.Degré..valeur
      l2 est un reel 		= -(1 / n) * ln(Abs(R / c))
      phi0 est un reel	= 2 * Arctan(Exp(l2))*EUnitéAngle.Degré..valeur - (ValPI/2)
      phiprec est un reel = phi0
      phii est un reel 	= 2 * Arctan((puissance(((1 + e * Sin(phiprec/EUnitéAngle.Degré..valeur)) / (1 - e * Sin(phiprec/EUnitéAngle.Degré..valeur))), e / 2) * Exp(l2)))*EUnitéAngle.Degré..valeur - (ValPI/2)
      TANTQUE (PAS (Abs(phii - phiprec) < eps))
      	phiprec = phii
      	phii = 2 * ArcTan((Puissance(((1 + e * Sin(phiprec/EUnitéAngle.Degré..valeur)) / (1 - e * Sin(phiprec/EUnitéAngle.Degré..valeur))), e / 2) * Exp(l2)))*EUnitéAngle.Degré..valeur - (ValPI/2)
      FIN
      
      phii				= phii/EUnitéAngle.Degré..Valeur
      l1 est un reel		= (l0 + (g / n))/EUnitéAngle.Degré..Valeur
      //Conversion NTF géographique -> NTF cartésien : ALG0009
      b est un reel 		= 6378249.2
      h est un reel		= 100         // En mètres
      n = b / (Puissance((1 - (e * e) * (Sin(phii) * Sin(phii))), 0.5))
      X_cart est un reel 	= (n + h) * Cos(phii) * Cos(l1)
      Y_cart est un réel 	= (n + h) * Cos(phii) * Sin(l1)
      Z_cart est un réel 	= ((n * (1 - (e * e))) + h) * Sin(phii)
      
      //Conversion NTF cartésien -> WGS84 cartésien : ALG0013
      XWGS84 est un reel 	= X_cart - 168
      YWGS84 est un reel 	= Y_cart - 60
      ZWGS84 est un reel 	= Z_cart + 320
      
      //Conversion WGS84 cartésien -> WGS84 géographique : ALG0012
      rl840 est un reel 	= 0.04079234433
      e 					= 0.08181919106 *  0.08181919106            // On change e pour le mettre dans le système WGS84 au lieu de NTF
      b 					= 6378137.0
      P est un reel 		= racine((XWGS84 * XWGS84) + (YWGS84 * YWGS84))
      rl84 est un reel 	= rl840 + Arctan(YWGS84 / XWGS84)*EUnitéAngle.Degré..valeur
      phi840 est un reel 	= Arctan(ZWGS84 / (P * (1 - ((b * e)) / racine((XWGS84 * XWGS84) + (YWGS84 * YWGS84) + (ZWGS84 * ZWGS84)))))*EUnitéAngle.Degré..valeur
      phi84prec est un reel = phi840
      phi84i est un reel 	= Arctan((ZWGS84 / P) / (1 - ((b * e * Cos(phi84prec/EUnitéAngle.Degré..Valeur)) / (P * racine(1 - e * (Sin(phi84prec/EUnitéAngle.Degré..Valeur) * Sin(phi84prec/EUnitéAngle.Degré..Valeur)))))))*EUnitéAngle.Degré..valeur
      TANTQUE (PAS (Abs(phi84i - phi84prec) < eps))
      	phi84prec = phi84i
      	phi84i = ArcTan((ZWGS84 / P) / (1 - ((b * e * Cos(phi84prec/EUnitéAngle.Degré..Valeur)) / (P * Racine(1 - (e * (Sin(phi84prec/EUnitéAngle.Degré..Valeur) * Sin(phi84prec/EUnitéAngle.Degré..Valeur))))))))*EUnitéAngle.Degré..valeur
      FIN
      RENVOYER (phi84i*180.0/ValPI,rl84*180.0/ValPI)
     type : 458752
   -
     name : DateHeureVersEntier
     procedure_id : 2200228883496029720
     type_code : 15
     code : |1-
      // Résumé : La fonction prend en entrée une valeur de type DateHeure et renvoie une valeur entière représentant la combinaison de la date et de l'heure sous la forme d'un entier unique.
      // Syntaxe : [ <Résultat> = ] DateHeureVersEntier (<dhDateHeure> est dateheure)
      // Paramètres :
      //	dhDateHeure (dateheure) : La valeur de type DateHeure à convertir en entier.
      // Valeur de retour : entier sur 8 octets : Un entier représentant la date et l'heure sous le format AAAAMMJJHHMMSS.
      // Exemple :
      //	nDateHeureEntier est un entier = DateHeureVersEntier("20231114153045")
      // 	nDateHeureEntier contiendra 8176705584500
      //
      PROCEDURE DateHeureVersEntier(dhDateHeure est une dateheure) : entier sur 8 octets
      RENVOYER DateVersEntier(dhDateHeure..PartieDate)*100000000+HeureVersEntier(dhDateHeure..PartieHeure)
     type : 458752
   -
     name : ChiffresSeulement
     procedure_id : 2204584002671887083
     type_code : 15
     code : |1-
      // Résumé : La fonction prend en entrée une chaîne de caractères et renvoie une nouvelle chaîne contenant uniquement les chiffres de la chaîne d'origine.
      // Syntaxe : [ <Résultat> = ] ChiffresSeulement (<sChaine> est chaîne)
      // Paramètres :
      //	sChaine (chaîne UNICODE) : La chaîne de caractères à partir de laquelle extraire les chiffres.
      // Valeur de retour : chaîne UNICODE : Une nouvelle chaîne contenant uniquement les chiffres extraits de la chaîne d'origine.
      // Exemple :
      //	sChiffresUniquement est une chaîne = ChiffresSeulement("abc123def456ghi")
      //	sChiffresUniquement contiendra "123456"
      //
      PROCEDURE ChiffresSeulement(sChaine est une chaîne) : chaîne
      SI sChaine~="" ALORS RENVOYER ""
      sRes est une chaîne
      POUR nCaractère = 1 _À_ Taille(sChaine)
      	SI Contient(cGénérique._CaractèresNumériques,sChaine[nCaractère]) ALORS sRes+=sChaine[nCaractère]
      FIN
      RENVOYER sRes
     type : 458752
   -
     name : TableauAssociatifVersChaîne
     procedure_id : 2221019331618488874
     type_code : 15
     code : |1-
      // Résumé : La fonction prend en entrée un tableau associatif et renvoie une chaîne de caractères représentant les paires clé-valeur du tableau associatif.
      // Syntaxe : [ <Résultat> = ] TableauAssociatifVersChaîne (<taAssociatif>)
      // Paramètres :
      // 	taAssociatif (tableau associatif) : Le tableau associatif à convertir en chaîne.
      // Valeur de retour : chaîne UNICODE : Une chaîne de caractères représentant les paires clé-valeur du tableau associatif. Chaque paire est séparée par un retour chariot (RC), et la clé et la valeur de chaque paire sont séparées par une tabulation (TAB).
      // Exemple :
      //	taExemple est un tableau associatif de chaines
      //	taExemple["Nom"] = "John"
      //	taExemple["Âge"] = 30
      //	taExemple["Ville"] = "Paris"
      //	sResultat est une chaîne = TableauAssociatifVersChaîne(taExemple)
      //	sResultat contiendra "Nom"+TAB+"John"+RC+"Âge"+TAB+"30"+RC+"Ville"+TAB+"Paris"
      //
      PROCEDURE TableauAssociatifVersChaîne(taAssociatif) : chaine
      si typevar(taAssociatif)<>wlTableauAssociatif alors ErreurDéclenche(ErreurDeConverion,<§@1b155a2803bc0642004d§>);renvoyer ""
      sRes est une chaine
      pour tout element xValeur,sElement de taAssociatif 
      	sRes+=[rc]+sElement+tab+xValeur
      FIN
      renvoyer sRes
     type : 458752
   -
     name : DateGrégorienneVersDateJulienne
     procedure_id : 2264416817173269175
     type_code : 15
     code : |1-
      // Résumé : La fonction convertit une date grégorienne en un système de notation des dates utilisé au sein des forces armées canadiennes. Si la date est invalide, la fonction déclenche une erreur de conversion avec le message "Date invalide" et renvoie -1.
      // Syntaxe : [ <Résultat> = ] DateGrégorienneVersJulienne (<xDate>)
      // Paramètres :
      // 	xDate (date ou chaîne): La date grégorienne à convertir en jour julien.
      // Valeur de retour : entier : Le jour julien correspondant à la date grégorienne.
      // Exemple :
      //	nJourJulien est un entier = DateGrégorienneVersDateJulienne("20231114")
      //	nJourJulien contiendra 23318
      //
      PROCEDURE DateGrégorienneVersDateJulienne(xDate) : entier
      dDate est une Date = xDate
      SI DateValide(dDate) ALORS
      	RENVOYER milieu(dDate,3,2)+NumériqueVersChaîne(DateVersEntier(dDate)-DateVersEntier(dDate..Année+"0101")+1)
      SINON
      	ErreurDéclenche(ErreurDeConverion,<§@1b155a2803bc0642004e§>);RENVOYER -1
      FIN
     type : 458752
   -
     name : DateJulienneVersDateGrégorienne
     procedure_id : 2264417130705954510
     type_code : 15
     code : |1-
      // Résumé : La fonction convertit un système de notation des dates utilisé au sein des forces armées canadiennes en une date grégorienne.
      // Syntaxe : [ <Résultat> = ] DateJulienneVersGrégorienne (<nDateJulienne> est entier [, <nAnnée> est entier])
      // Paramètres :
      //	nDateJulienne (entier) : Le jour julien à convertir en date grégorienne.
      // Valeur de retour : date : La date grégorienne correspondant au jour julien spécifié.
      // Exemple :
      //	dDate est une date = DateJulienneVersDateGrégorienne(23318)
      //	dDate contiendra "20231114"
      //
      PROCEDURE DateJulienneVersDateGrégorienne(nDateJulienne est un entier) : Date
      sDate est une chaine = nDateJulienne
      RENVOYER EntierVersDate(DateVersEntier(gauche(sDate)+"0101")-1+val(milieu(sDate,3)))
     type : 458752
   -
     name : HeuresEnJoursTravaillés
     procedure_id : 1242079695781077346
     type_code : 15
     code : |1-
      // Résumé : La fonction HeuresEnJoursTravaillés convertit une durée en heures et minutes en jours travaillés, en tenant compte du nombre d'heures de travail par jour spécifié.
      // Syntaxe : [ <Résultat> = ] HeuresEnJoursTravaillés (<nHeures> est entier, <nMinutes> est entier, <rNbHeuresParJour> est réel)
      // Paramètres :
      //	nHeures (entier) : Le nombre d'heures de la durée.
      //	nMinutes (entier) : Le nombre de minutes de la durée.
      //	rNbHeuresParJour (réel) : Le nombre d'heures de travail par jour.
      // Valeur de retour : réel : Le nombre de jours travaillés, arrondi au nombre le plus proche.
      // Exemple :
      //	rJoursTravaillés est un réel = HeuresEnJoursTravaillés(40, 30, 7.5)
      //	rJoursTravaillés contiendra 5.4 jours travaillés
      //
      PROCEDURE HeuresEnJoursTravaillés(nHeures est un entier,nMinutes est un entier,rNbHeuresParJour est un reel) : reel
      //ref : https://forum.pcsoft.fr/fr-FR/pcsoft.fr.windev/252233-conversion-heures-jours/read.awp
      si nMinutes>60 alors nHeures+=modulo(nMinutes,60);nMinutes=nMinutes-modulo(nMinutes,60)*60
      duRésultat est une Durée
      duRésultat..Heure	= nHeures
      duRésultat..Minute	= nMinutes
      renvoyer duRésultat..EnHeures/rNbHeuresParJour
     type : 458752
   -
     name : CombinaisonProgressive
     procedure_id : 1261883940150839247
     type_code : 15
     code : |1-
      // Résumé : La fonction CombinaisonProgressive génère toutes les combinaisons progressives possibles à partir d'un tableau de référence de chaînes. Une combinaison progressive est une combinaison où chaque élément est ajouté séquentiellement, générant de nouvelles combinaisons à chaque étape.
      // Syntaxe : [ <Résultat> = ] CombinaisonStdNbr (<k>, <n>)
      // Paramètres :
      // 	tabRéférence (tableau de chaînes): Le tableau de référence à partir duquel les combinaisons progressives seront générées.
      // 	bAvecDoublon (booléen): Un indicateur spécifiant si les doublons sont autorisés dans les combinaisons générées. Si Vrai, les combinaisons peuvent contenir des doublons ; sinon, les doublons sont évités.
      // Valeur de retour : tableau de chaînes : Le tableau contenant toutes les combinaisons progressives générées.
      // Exemple :
      //	tabRésultat est un tableau de chaînes = CombinaisonProgressive(["ABC","DEF","GHI"],faux)
      // 	tabRésultat contiendra
      //		ABC
      //		DEF
      //		GHI
      //		ABC<RC>DEF
      //		ABC<RC>GHI
      //		DEF<RC>GHI
      //		ABC<RC>DEF<RC>GHI
      //
      PROCEDURE CombinaisonProgressive(tabRéférence est un tableau de chaines,bAvecDoublon est un booleen) : tableau de chaîne
      tabRes,tabTemp 	sont des tableaux de chaînes
      sCombinaison	est une chaîne
      tabRes = tabRéférence	//au moins une fois chaque élément de la référence
      POUR nRéférence = 1 _À_ tabRéférence..Occurrence
      	//prendre les éléments dans le résultat pour faire d'autres résultat en ajoutant, s'il n'existe pas, un élément de référence
      	POUR nRésultat = 1 _À_ tabRes..Occurrence
      		SI bAvecDoublon _OU_ Position(tabRes[nRésultat],tabRéférence[nRéférence])<1 ALORS
      			sCombinaison=tabRes[nRésultat]+RC+tabRéférence[nRéférence]
      			ChaîneVersTableau(sCombinaison,tabTemp);TableauTrie(tabTemp);sCombinaison=TableauVersChaîne(tabTemp)	//pas de doublon de combinaison
      			SI TableauCherche(tabRes,tcLinéaire,sCombinaison)<1 ALORS TableauAjoute(tabRes,sCombinaison) 
      		FIN
      	FIN
      FIN
      
      RENVOYER tabRes
     type : 458752
   -
     name : CombinaisonStdNbr
     procedure_id : 1261898620349133027
     type_code : 15
     code : |1-
      // Résumé : La fonction calcule le coefficient binomial, également connu sous le nom de combinaison, représenté comme "n choose k" ou C(n, k). Cela représente le nombre de façons de choisir k éléments parmi un ensemble de n éléments, sans tenir compte de l'ordre.
      // Syntaxe : [ <Résultat> = ] CombinaisonStdNbr (<k>, <n>)
      // Paramètres :
      // 	k (entier) : Le nombre d'éléments à choisir dans l'ensemble.
      // 	n (entier) : Le nombre total d'éléments dans l'ensemble.
      // Valeur de retour : entier : Le nombre de combinaisons de k éléments parmi n éléments.
      // Exemple :
      //	resExemple est un entier = CombinaisonStdNbr(2,52)
      //	resExemple contiendra 10
      //
      PROCEDURE CombinaisonStdNbr(k est un entier,n est un entier) : entier
      SI (k = n) ALORS RENVOYER 1
      Si (n >= 0 ET k >= 0 ET k <= n) Alors
      	nFactoriel,kFactoriel,nkFactoriel,nRésultat sont des entiers
      	nFactoriel = Factorielle(n)			// Calculer n!
      	kFactoriel = Factorielle(k)			// Calculer k!
      	nkFactoriel = Factorielle(n - k)	// Calculer (n - k)!
      	nRésultat = nFactoriel / (kFactoriel * nkFactoriel)	// Calculer C(n, k)
      	RENVOYER nRésultat
      Sinon
      	// Gérer l'erreur (par exemple, en retournant -1 pour indiquer une erreur)
      	renvoyer -1
      Fin
     type : 458752
   -
     name : CombinaisonStd
     procedure_id : 1261899874479678994
     type_code : 15
     code : |1+
      // Résumé : La fonction génère toutes les combinaisons possibles de k éléments parmi un ensemble de n éléments, sans tenir compte de l'ordre. Elle utilise la méthode récursive pour générer ces combinaisons.
      // Syntaxe : [ <Résultat> = ] CombinaisonStd (<n> est entier, <k> est entier)
      // Paramètres :
      //	n (entier) : Le nombre total d'éléments dans l'ensemble.
      //	k (entier) : Le nombre d'éléments à choisir dans l'ensemble.
      // Valeur de retour : tableau de chaînes : Un tableau de chaînes représentant toutes les combinaisons de k éléments parmi n éléments.
      // Exemple :
      //	tabCombi est un tableau de chaînes = TableauVersChaîne(CombinaisonStd(5,2))
      //	tabCombi contiendra
      //	1	2
      //	1	3
      //	1	4
      //	1	5
      //	2	3
      //	2	4
      //	2	5
      //	3	4
      //	3	5
      //	4	5
      //
      PROCEDURE CombinaisonStd(n est un entier, local k est un entier) : tableau de chaines
      tElements est un tableau de chaînes
      POUR i = 1 _A_ n
      	Ajoute(tElements,i)
      FIN
      RENVOYER iCombinaison(k)
      
      	PROCÉDURE INTERNE iCombinaison(k2 est un entier)
      	tabCombinaisons est un tableau de chaîne
      	
      	SI PAS tElements..Vide ALORS
      		SI k2 > 1 ALORS
      			POUR i = 1 _A_ tElements..Occurrence
      				sElementCourant est une chaîne = tElements[1]
      				Supprime(tElements, 1)
      				POUR TOUT UnElement de iCombinaison(k2-1)
      					Ajoute(tabCombinaisons, sElementCourant+TAB+UnElement)
      				FIN
      			FIN
      		SINON
      			POUR TOUT UnElement de tElements
      				Ajoute(tabCombinaisons, UnElement)
      			FIN
      		FIN
      	FIN
      	RENVOYER tabCombinaisons
      	FIN
     type : 458752
   -
     name : DateRelative
     procedure_id : 1348526374098610742
     type_code : 15
     code : |1-
      // Résumé : La fonction calcule une date relative en fonction du quantième (numéro de semaine dans le mois) et du jour de la semaine spécifiés par les paramètres. La date résultante est calculée par rapport à une date de référence donnée.
      // Syntaxe : [ <Résultat> = ] DateRelative (<eQuantième> est COL_Données.ENumSemaineDansMois, <eJour> est COL_Données.EJour [, <bAprès> est booléen [, <dRéférence> est date]])
      // Paramètres :
      //	eQuantième (COL_Données.ENumSemaineDansMois) : L'énumération représentant le quantième (numéro de semaine dans le mois) pour la date relative.
      //	eJour (COL_Données.EJour) : L'énumération représentant le jour de la semaine pour la date relative.
      // 	bAprès (booléen optionnel): Un booléen indiquant si la date relative doit être calculée après la date de référence, par défaut Vrai.
      //	dRéférence (date optionnel, par défaut le premier jour du mois en cours): La date de référence à partir de laquelle calculer la date relative.
      // Valeur de retour : date : La date relative calculée en fonction des paramètres spécifiés.
      // Exemple :
      //	dDateRelative est une Date = DateRelative(Troisième, Mercredi, Vrai, "20231101")
      //	dDateRelative contiendra "20231122"
      //
      PROCEDURE DateRelative(eQuantième est un ENumSemaineDansMois,eJour est un EJour,bAprès est un booleen = vrai,dRéférence est une date = gauche(datesys(),6)+"01") : date
      si pas datevalide(dRéférence) alors ErreurDéclenche(ErreurDonnées,<§@12092cce1bd42f800015§>+dRéférence);renvoyer ""
      nTemp est un entier = DateVersEntier(dRéférence)+((bAprès ? 7 sinon -7)*(eQuantième..Valeur-(pas bAprès)))-DateVersJour(dRéférence)
      selon eJour
      	CAS Lundi		: si eQuantième=Premier _et_ DateVersJour(dRéférence)=_lundi 	alors renvoyer dRéférence sinon renvoyer entierversdate(nTemp+1)
      	CAS Mardi		: SI eQuantième=Premier _ET_ DateVersJour(dRéférence)=_Mardi 	ALORS RENVOYER dRéférence SINON RENVOYER EntierVersDate(nTemp+2)
      	CAS Mercredi	: SI eQuantième=Premier _ET_ DateVersJour(dRéférence)=_Mercredi ALORS RENVOYER dRéférence SINON RENVOYER EntierVersDate(nTemp+3)
      	CAS Jeudi		: SI eQuantième=Premier _ET_ DateVersJour(dRéférence)=_jeudi 	ALORS RENVOYER dRéférence SINON RENVOYER EntierVersDate(nTemp+4)
      	CAS Vendredi	: SI eQuantième=Premier _ET_ DateVersJour(dRéférence)=_vendredi ALORS RENVOYER dRéférence SINON RENVOYER EntierVersDate(nTemp+5)
      	CAS Samedi		: SI eQuantième=Premier _ET_ DateVersJour(dRéférence)=_Samedi 	ALORS RENVOYER dRéférence SINON RENVOYER EntierVersDate(nTemp+6)
      	CAS Dimanche	: SI eQuantième=Premier _ET_ DateVersJour(dRéférence)=_dimanche ALORS RENVOYER dRéférence SINON RENVOYER EntierVersDate(nTemp+7)
      FIN
     type : 458752
   -
     name : EntierVersDateHeure
     procedure_id : 1348526515832564489
     type_code : 15
     code : |1-
      // Résumé : La fonction EntierVersDateHeure convertit un entier représentant une date et une heure en un objet DateHeure.
      // Syntaxe : [ <Résultat> = ] EntierVersDateHeure (<nDateHeure> est entier sur 8 octets)
      // Paramètres :
      //	nDateHeure (entier) : L'entier représentant la date et l'heure sous le format AAAAMMJJHH (année, mois, jour, heure).
      // Valeur de retour : dateheure : Un objet DateHeure représentant la date et l'heure obtenues à partir de l'entier fourni.
      // Exemple :
      //	dhDateHeure est une DateHeure = EntierVersDateHeure(8176705584500)
      //	dhDateHeure contiendra "20231114153045"
      //
      PROCEDURE EntierVersDateHeure(nDateHeure est un entier sur 8 octets) : dateheure
      nDate 	est un entier = partieentiere(nDateHeure/100000000)
      nHeure 	est un entier = PartieDécimale(nDateHeure/100000000)
      renvoyer entierversdate(nDate)+entierversheure(nHeure)
     type : 458752
   -
     name : Aujourdhui
     procedure_id : 1348527258862014197
     type_code : 15
     group : 3
     code : |1-
      // Résumé : La fonction renvoie la date actuelle du système.
      // Syntaxe : [ <Résultat> = ] Aujourdhui ()
      // Paramètres : Aucun
      // Valeur de retour : date : La date actuelle du système.
      // Exemple :
      //	dDate est une date = DateDuJour()
      //
      PROCEDURE Aujourdhui() : date
      renvoyer DateDuJour()
     type : 458752
   -
     name : Unités
     procedure_id : 1378359232334865107
     type_code : 15
     code : |1-
      // Résumé : Prend un nombre réel, un entier, un monétaire, un numérique ou une chaine et renvoie le nombre d'unités en-dessous de mille d'un nombre réel.
      // Syntaxe : [ <Résultat> = ] Unités (<xValeur>)
      // Paramètres : xValeur : Le nombre duquel extraire les unités.
      // Valeur de retour : numérique : Le nombre d'unités en-dessous de mille dans la partie décimale du nombre fourni.
      // Exemple :
      //	nResultat est un Entier = Unités(123.456)
      //	nResultat contiendra 123
      //
      PROCEDURE Unités(xValeur) : numérique
      sRes est une chaîne = ExtraitChaîne(NumVersChaine(xValeur),1,".")
      SI Taille(sRes)=0 ALORS RENVOYER 0 SINON RENVOYER val(droite(sRes,3))
     type : 458752
   -
     name : Dizaines
     procedure_id : 1378359292464486452
     type_code : 15
     code : |1-
      // Résumé : Prend un nombre réel, un entier, un monétaire, un numérique ou une chaine en paramètre et renvoie la partie dizaine de ce nombre, c'est-à-dire le chiffre des dizaines dans sa représentation décimale. Si le nombre est inférieur à 10, la fonction renvoie 0.
      // Syntaxe : [ <Résultat> = ] Dizaines (<xValeur>)
      // Paramètres :	xValeur : Le nombre duquel extraire le nombre de dizaines.
      // Valeur de retour : chaîne UNICODE : Le nombre de dizaines dans la partie entière du nombre fourni.
      // Exemple :
      //	nResultat est un Entier = Dizaines(456.789)
      //	nResultat contiendra 45 
      PROCEDURE Dizaines(xValeur) : numérique
      sRes est une chaîne = ExtraitChaîne(NumVersChaine(xValeur),1,".")
      si taille(sRes)<2 alors renvoyer 0 sinon renvoyer val(gauche(sRes,taille(sRes)-1))
     type : 458752
   -
     name : Centaines
     procedure_id : 1378361775063968509
     type_code : 15
     code : |1-
      // Résumé : Prend un nombre réel, un entier, un monétaire, un numérique ou une chaine en paramètre et renvoie la partie centaine de ce nombre, c'est-à-dire le chiffre des centaines dans sa représentation décimale. Si le nombre est inférieur à 100, la fonction renvoie 0.
      // Syntaxe : [ <Résultat> = ] Centaines (<xValeur>)
      // Paramètres : xValeur : Le nombre dont on souhaite extraire la partie centaine.
      // Valeur de retour : numérique : Le nombre de centaines dans la partie entière du nombre fourni.
      // Exemple :
      //	nPartieCentaine est un entier = Centaines(456.78)
      //	nPartieCentaine contiendra 4
      //
      PROCEDURE Centaines(xValeur) : numérique
      sRes est une chaîne = ExtraitChaîne(NumVersChaine(xValeur),1,".")
      SI Taille(sRes)<3 ALORS RENVOYER 0 SINON RENVOYER val(gauche(sRes,Taille(sRes)-2))
     type : 458752
   -
     name : Milliers
     procedure_id : 1378362286165195918
     type_code : 15
     code : |1-
      // Résumé : Prend un nombre réel, un entier, un monétaire, un numérique ou une chaine en paramètre et renvoie la partie millier de ce nombre, c'est-à-dire le chiffre des milliers dans sa représentation décimale. Si le nombre est inférieur à 1 000, la fonction renvoie 0.
      // Syntaxe : [ <Résultat> = ] Milliers (<xValeur>)
      // Paramètres : xValeur : Le nombre dont on souhaite extraire la partie millier.
      // Valeur de retour : numérique : Le nombre de milliers dans la partie entière du nombre fourni.
      // Exemple :
      //	nPartieMillier est un entier = Milliers(4567.89)
      //	nPartieMillier contiendra 4
      //
      PROCEDURE Milliers(xValeur) : numérique
      sRes est une chaîne = ExtraitChaîne(NumVersChaine(xValeur),1,".")
      SI Taille(sRes)<4 ALORS RENVOYER 0 SINON RENVOYER val(gauche(sRes,Taille(sRes)-3))
     type : 458752
   -
     name : Dizaine
     procedure_id : 1380968889030518323
     type_code : 15
     code : |1-
      // Résumé : Prend un nombre réel, un entier, un monétaire, un numérique ou une chaine en paramètre et renvoie la partie dizaine de ce nombre, c'est-à-dire le chiffre des dizaines dans sa représentation décimale. Si le nombre est inférieur à 10, la fonction renvoie 0.
      // Syntaxe : [ <Résultat> = ] Dizaine (<xValeur>)
      // Paramètres :
      // 	xValeur (numérique) : Le nombre dont on souhaite extraire la partie dizaine.
      // Valeur de retour : entier : La partie dizaine du nombre
      // Exemple :
      //	nPartieDizaine est un entier = Dizaine(4567.89)
      //	nPartieDizaine contiendra 6
      //
      PROCEDURE Dizaine(xValeur) : entier
      renvoyer val(droite(NumériqueVersChaîne(dizaines(xValeur)),1))
     type : 458752
   -
     name : Millier
     procedure_id : 1380969241217919041
     type_code : 15
     code : |1-
      // Résumé : Prend un nombre réel, un entier, un monétaire, un numérique ou une chaine en paramètre et renvoie la partie millier de ce nombre, c'est-à-dire les chiffres des milliers dans sa représentation décimale. Si le nombre est inférieur à 1 000, la fonction renvoie 0.
      // Syntaxe : [ <Résultat> = ] Millier (<xValeur>)
      // Paramètres :
      // 	xValeur (numérique) : Le nombre dont on souhaite extraire la partie millier.
      // Valeur de retour : entier : La partie millier du nombre
      // Exemple :
      //	nPartieMillier est un entier = Millier(12345.67)
      //	nPartieMillier contiendra 12
      //
      PROCEDURE Millier(xValeur) : entier
      renvoyer val(droite(NumériqueVersChaîne(milliers(xValeur)),3))
     type : 458752
   -
     name : Centaine
     procedure_id : 1380969816743604410
     type_code : 15
     code : |1-
      // Résumé : Prend un nombre réel, un entier, un monétaire, un numérique ou une chaine en paramètre et renvoie la partie centaine de ce nombre. Si le nombre est inférieur à 100, la fonction renvoie 0.
      // Syntaxe : [ <Résultat> = ] Centaine (<xValeur>)
      // Paramètres :
      // 	xValeur (numérique) : Le nombre dont on souhaite extraire la partie centaine.
      // Valeur de retour : entier : La partie centaine du nombre
      // Exemple :
      //	nPartieCentaine est un entier = Centaine(4567.89)
      //	nPartieCentaine contiendra 5
      //
      PROCEDURE Centaine(xValeur) : entier
      RENVOYER val(Droite(NumériqueVersChaîne(CEntaines(xValeur)),2))
     type : 458752
   -
     name : Unité
     procedure_id : 1380970095916544342
     type_code : 15
     code : |1-
      // Résumé : Prend un nombre réel, un entier, un monétaire, un numérique ou une chaine en paramètre et renvoie la partie unité de ce nombre. Si le nombre est inférieur à 1, la fonction renvoie 0.
      // Syntaxe : [ <Résultat> = ] Unité (<xValeur>)
      // Paramètres :
      // 	xValeur (numérique) : Le nombre dont on souhaite extraire la partie unité.
      // Valeur de retour : entier : La partie unité du nombre
      // Exemple :
      //	nPartieUnité est un entier = Unité(123.45)
      //	nPartieUnité contiendra 3
      //
      PROCEDURE Unité(xValeur) : entier
      RENVOYER val(Droite(NumériqueVersChaîne(Unités(xValeur)),1))
     type : 458752
   -
     name : NumériqueVersChaineANSI
     procedure_id : 1395021131795699679
     type_code : 15
     code : |1-
      // Résumé : Prend un nombre en paramètre, le convertit en chaîne Unicode, puis retourne cette chaîne convertie en ANSI. Cela peut être utile pour manipuler des chaînes dans un format de caractères spécifique.
      // Syntaxe : [ <Résultat> = ] NumériqueVersChaineANSI (<xValeur>)
      // Paramètres :
      // 	xValeur : Le nombre à convertir en chaîne ANSI.
      // Valeur de retour : chaîne ANSI : La représentation en chaîne ANSI du nombre.
      // Exemple :
      //	sChaineANSI est une chaîne ANSI = NumériqueVersChaineANSI(123.45)
      //	sChaineANSI contiendra "123.45"
      //
      PROCEDURE NumériqueVersChaineANSI(xValeur) : chaine ansi
      renvoyer UnicodeVersAnsi(NumériqueVersChaîne(xValeur))
     type : 458752
   -
     name : Million
     procedure_id : 1399913956385450652
     type_code : 15
     code : |1-
      // Résumé : Prend un nombre réel, un entier, un monétaire, un numérique ou une chaine en paramètre et renvoie la partie million de ce nombre.
      // Syntaxe : [ <Résultat> = ] Million (<xValeur>)
      // Paramètres :
      // 	xValeur (numérique) : Le nombre à partir duquel extraire les millions.
      // Valeur de retour : entier : Les millions extraits du nombre
      // Exemple :
      //	nRésultat est un entier = Million(1234567890.12)
      //	nRésultat contiendra 234
      //
      PROCEDURE Million(xValeur) : entier
      RENVOYER val(Droite(NumériqueVersChaîne(millions(xValeur)),3))
     type : 458752
   -
     name : Millions
     procedure_id : 1399914699414834637
     type_code : 15
     code : |1-
      // Résumé : Prend un nombre réel, un entier, un monétaire, un numérique ou une chaine en paramètre, extrait la partie correspondant aux millions de ce nombre.
      // Syntaxe : [ <Résultat> = ] Millions (<xValeur>)
      // Paramètres : xValeur : Le nombre à partir duquel extraire les millions.
      // Valeur de retour : numérique : Le nombre de millions dans la partie entière du nombre fourni.
      // Exemple :
      //	nRésultat est un entier = Millions(1234567890.12)
      //	nRésultat contiendra 1234
      //
      PROCEDURE Millions(xValeur) : numérique
      sRes est une chaîne = ExtraitChaîne(NumVersChaine(xValeur),1,".")
      SI Taille(sRes)<7 ALORS RENVOYER 0 SINON RENVOYER val(gauche(sRes,Taille(sRes)-6))
     type : 458752
   -
     name : Milliard
     procedure_id : 1399915747443787502
     type_code : 15
     code : |1-
      // Résumé : Prend un nombre réel, un entier, un monétaire, un numérique ou une chaine en paramètre et renvoie la partie milliard de ce nombre. (milliard = 10^9).
      // Syntaxe : [ <Résultat> = ] Milliard (<xValeur>)
      // Paramètres :
      // 	xValeur (numérique) : Le nombre à partir duquel extraire les milliards.
      // Valeur de retour :
      // 	entier : Les milliards extraits du nombre
      // Exemple :
      //	nRésultat est un entier = Milliard(1234567890123456.78)
      //	nRésultat contiendra 567
      //
      PROCEDURE Milliard(xValeur) : entier
      RENVOYER val(Droite(NumériqueVersChaîne(Milliards(xValeur)),3))
     type : 458752
   -
     name : Milliards
     procedure_id : 1399915824753217176
     type_code : 15
     code : |1-
      // Résumé : La fonction prend un nombre réel en paramètre, extrait la partie correspondant aux milliards de ce nombre. (milliard = 10^9).
      // Syntaxe : [ <Résultat> = ] Milliards (<xValeur>)
      // Paramètres : xValeur : Le nombre à partir duquel extraire les milliards.
      // Valeur de retour : chaîne UNICODE : Le nombre de milliards dans la partie entière du nombre fourni.
      // Exemple :
      //	nRésultat est un entier = Milliards(1234567890123456.78)
      //	nRésultat contiendra 1234567
      //
      PROCEDURE Milliards(xValeur) : chaine
      sRes est une chaine = ExtraitChaîne(NumVersChaine(xValeur),1,".")
      SI Taille(sRes)<10 ALORS RENVOYER 0 SINON RENVOYER Gauche(sRes,Taille(sRes)-9)
     type : 458752
   -
     name : NumVersChaine
     procedure_id : 1399944841831523310
     type_code : 15
     code : |1-
      // Résumé : Fonction pour convertir un nombre ou une chaîne numérique en chaîne de caractères.
      // Syntaxe : [ <Résultat> = ] NumVersChaine (<xValeur>)
      // Paramètres :
      // 	xValeur (numérique) : La valeur à convertir en chaîne.
      // Valeur de retour : chaîne UNICODE : La valeur convertie en chaîne de caractères.
      // Exemple :
      //	sChaine est une chaîne = NumVersChaine(123)
      //	sChaine contiendra "123"
      //
      //	sChaine est une chaîne = NumVersChaine("123AB")
      //	sChaine contiendra "123"
      
      PROCEDURE NumVersChaine(xValeur) : chaine
      SELON TypeVar(xValeur)
      	CAS wlEntierSansSigne_1 À wlEntier_8,wlMonétaire,wlNumérique,wlHandle,wlRéel,wlRéel_4,wlRéel_8 		: renvoyer NumériqueVersChaîne(xValeur)
      	CAS wlChaîne,wlCaractère,wlChaîneAnsi,wlChaîneASCIIZ,wlChaîneFixe,wlChaînePascal,wlChaîneUnicode 	: SI xValeur>"" _ET_ EstNumérique(xValeur) ALORS RENVOYER xValeur
      	AUTRES CAS : 	//ce n'est ni un numérique ni une chaine numérique
      FIN
      RENVOYER ""
     type : 458752
   -
     name : Billion
     procedure_id : 1399946439559532564
     type_code : 15
     code : |1-
      // Résumé : Prend un nombre réel, un entier, un monétaire, un numérique ou une chaine en paramètre et renvoie la partie billion de ce nombre. (billion = 10^12).
      // Syntaxe : [ <Résultat> = ] Billion (<xValeur>)
      // Paramètres :
      // 	xValeur : Valeur numérique à partir de laquelle extraire la composante des billions.
      // Valeur de retour : entier : La composante des billions extraite de la valeur fournie.
      // Exemple :
      //	nRésultat est un entier = Billion(12345678912345678.90)
      //	nRésultat contiendra 345
      //
      //ref : https://fr.wikipedia.org/wiki/Noms_des_grands_nombres
      PROCEDURE Billion(xValeur) : entier
      RENVOYER val(Droite(NumériqueVersChaîne(Billions(xValeur)),3))
     type : 458752
   -
     name : Billions
     procedure_id : 1399946508279025555
     type_code : 15
     code : |1-
      // Résumé : Prend un nombre réel, un entier, un monétaire, un numérique ou une chaine en paramètre, extrait la partie correspondant aux billiards de ce nombre. (billiard = 10^15).
      // Syntaxe : [ <Résultat> = ] Billiards (<xValeur>)
      // Paramètres : xValeur : Valeur numérique à partir de laquelle extraire la composante des billiards.
      // Valeur de retour : numérique : Le nombre de billiards dans la partie entière du nombre fourni.
      // Exemple :
      //	nRésultat est un entier = Billiards(1234567891234567890123.45)
      //	nRésultat contiendra 1234567
      //
      //ref : https://fr.wikipedia.org/wiki/Noms_des_grands_nombres
      PROCEDURE Billions(xValeur) : numérique
      sRes est une chaine = ExtraitChaîne(NumVersChaine(xValeur),1,".")
      SI Taille(sRes)<13 ALORS RENVOYER 0 SINON RENVOYER val(Gauche(sRes,Taille(sRes)-12))
     type : 458752
   -
     name : Billiard
     procedure_id : 1399946860466426211
     type_code : 15
     code : |1-
      // Résumé : Prend un nombre réel, un entier, un monétaire, un numérique ou une chaine en paramètre et renvoie la partie billiard de ce nombre. (billiard = 10^15).
      // Syntaxe : [ <Résultat> = ] Billiard (<xValeur>)
      // Paramètres :
      // 	xValeur : Valeur numérique à partir de laquelle extraire la composante des billiards.
      // Valeur de retour : entier : La composante des billiard extraite de la valeur fournie.
      // Exemple :
      //	nRésultat est un entier = Billiard(1234567891234567890123.45)
      //	nRésultat contiendra 567
      //
      //ref : https://fr.wikipedia.org/wiki/Noms_des_grands_nombres
      PROCEDURE Billiard(xValeur) : entier
      RENVOYER val(Droite(NumériqueVersChaîne(Billiards(xValeur)),3))
     type : 458752
   -
     name : Billiards
     procedure_id : 1399946942070888764
     type_code : 15
     code : |1-
      // Résumé : Prend un nombre réel, un entier, un monétaire, un numérique ou une chaine en paramètre, extrait la partie correspondant aux billiards de ce nombre. (billiard = 10^15).
      // Syntaxe : [ <Résultat> = ] Billiards (<xValeur>)
      // Paramètres : xValeur : Valeur numérique à partir de laquelle extraire la composante des billiards.
      // Valeur de retour : numérique : Le nombre de billiards dans la partie entière du nombre fourni.
      // Exemple :
      //	nRésultat est un entier = Billiards(1234567891234567890123.45)
      //	nRésultat contiendra 1234567
      //
      //ref : https://fr.wikipedia.org/wiki/Noms_des_grands_nombres
      PROCEDURE Billiards(xValeur) : numérique
      sRes est une chaine = ExtraitChaîne(NumVersChaine(xValeur),1,".")
      SI Taille(sRes)<16 ALORS RENVOYER 0 SINON RENVOYER val(Gauche(sRes,Taille(sRes)-15))
     type : 458752
   -
     name : Trillion
     procedure_id : 1399947298553257605
     type_code : 15
     code : |1-
      // Résumé : Prend un nombre réel, un entier, un monétaire ou un numérique en paramètre et renvoie la partie trillion de ce nombre. (trillion = 10^18)
      // Syntaxe : [ <Résultat> = ] Trillion (<xValeur>)
      // Paramètres :
      // 	xValeur : Valeur numérique à partir de laquelle extraire la composante des trillions.
      // Valeur de retour : entier : La composante des trillions extraite de la valeur fournie.
      // Exemple :
      //	nRésultat est un entier = Trillion(1234567891234567890123.45)
      //	nRésultat contiendra 234
      //
      //ref : https://fr.wikipedia.org/wiki/Noms_des_grands_nombres
      PROCEDURE Trillion(xValeur) : entier
      RENVOYER val(Droite(NumériqueVersChaîne(Trillions(xValeur)),3))
     type : 458752
   -
     name : Trillions
     procedure_id : 1399947367272750425
     type_code : 15
     code : |1-
      // Résumé : Prend un nombre réel, un entier, un monétaire, un numérique ou une chaine en paramètre, extrait la partie correspondant aux trillions de ce nombre. (trillion = 10^18)
      // Syntaxe : [ <Résultat> = ] Trillions (<xValeur>)
      // Paramètres : xValeur : Valeur numérique à partir de laquelle extraire la composante des trillions.
      // Valeur de retour : numérique : Le nombre de trillions dans la partie entière du nombre fourni.
      // Exemple :
      //	nRésultat est un entier = Trillions(1234567891234567890123.45)
      //	nRésultat contiendra 1234
      //
      //ref : https://fr.wikipedia.org/wiki/Noms_des_grands_nombres
      PROCEDURE Trillions(xValeur) : numérique
      sRes est une chaine = ExtraitChaîne(NumVersChaine(xValeur),1,".")
      SI Taille(sRes)<19 ALORS RENVOYER 0 SINON RENVOYER val(Gauche(sRes,Taille(sRes)-18))
     type : 458752
   -
     name : Trilliard
     procedure_id : 1399947745229960286
     type_code : 15
     code : |1-
      // Résumé : Prend un nombre réel, un entier, un monétaire, un numérique ou une chaine en paramètre et renvoie la partie trilliard de ce nombre.
      // Syntaxe : [ <Résultat> = ] Trilliard (<xValeur>)
      // Paramètres :
      // 	xValeur : Valeur numérique à partir de laquelle extraire la composante des trilliards.
      // Valeur de retour : entier : La composante des trilliard extraite de la valeur fournie.
      // Exemple :
      //	nRésultat est un entier = Trilliard(1234567891234567890123456.78)
      //	nRésultat contiendra 234
      //
      //ref : https://fr.wikipedia.org/wiki/Noms_des_grands_nombres
      PROCEDURE Trilliard(xValeur) : entier
      RENVOYER val(Droite(NumériqueVersChaîne(Trilliards(xValeur)),3))
     type : 458752
   -
     name : Trilliards
     procedure_id : 1399947779589771990
     type_code : 15
     code : |1-
      // Résumé : Prend un nombre réel, un entier, un monétaire, un numérique ou une chaine en paramètre, extrait la partie correspondant aux trillards de ce nombre. (trilliard = 10^21)
      // Syntaxe : [ <Résultat> = ] Trilliards (<xValeur>)
      // Paramètres : xValeur : Valeur numérique à partir de laquelle extraire la composante des trilliard.
      // Valeur de retour : numérique : Le nombre de trilliards dans la partie entière du nombre fourni.
      // Exemple :
      //	nRésultat est un entier = Trilliards(1234567891234567890123456.78)
      //	nRésultat contiendra 1234
      //
      //ref : https://fr.wikipedia.org/wiki/Noms_des_grands_nombres
      PROCEDURE Trilliards(xValeur) : numérique
      sRes est une chaine = ExtraitChaîne(NumVersChaine(xValeur),1,".")
      SI Taille(sRes)<22 ALORS RENVOYER 0 SINON RENVOYER val(Gauche(sRes,Taille(sRes)-21))
     type : 458752
   -
     name : CAN_ArrondiMonétaireEspèce
     procedure_id : 1524156071108114908
     type_code : 15
     code : |1-
      // Résumé : Cette fonction effectue un arrondi monétaire d'un montant donné conformément à la spécification des pièces et billets au Canada. Elle arrondit le montant à la pièce de 5 cents la plus proche.
      // Syntaxe : [ <Résultat> = ] DateHeureVersISO8601 ( [<dDate> est date [, <hHeure> est heure [, <bEstDateHeureLocale> est booléen]]])
      // Paramètres :
      //	xMontant (numérique) : Montant monétaire à arrondir.
      // Valeur de retour : monétaire : Montant arrondi à la pièce de 5 cents la plus proche.
      // Exemple :
      //	moRésulat est un monétaire = CAN_ArrondiMonétaireEspèce(12.37)
      //	moRésulat contiendra 12.35
      //
      PROCEDURE CAN_ArrondiMonétaireEspèce(xMontant) : monétaire
      renvoyer Arrondi((xMontant)/0.05,0)*0.05
     type : 458752
   -
     name : DateHeureVersISO8601
     procedure_id : 1547669324601807463
     type_code : 15
     code : |1-
      // Résumé : La fonction convertit une date et une heure en format ISO 8601. Le résultat est une chaîne représentant la date et l'heure au format YYYY-MM-DDTHH:MM:SSZ.
      // Syntaxe : [ <Résultat> = ] DateHeureVersISO8601 ( [<dDate> est date [, <hHeure> est heure [, <bEstDateHeureLocale> est booléen]]])
      // Paramètres :
      //	dDate (date optionnel) : Date à convertir (par défaut, la date système).
      //	hHeure (heure optionnel) : Heure à convertir (par défaut, l'heure système).
      // 	bEstDateHeureLocale (booléen optionnel) : indique si la date et l'heure sont fournies dans le fuseau horaire local (par défaut à Vrai).
      // Valeur de retour : chaîne UNICODE : Date et heure au format ISO 8601.
      // Exemple :
      //	sDateHeureISO est une chaine = DateHeureVersISO8601()
      //	sDateHeureISO contiendra "20231219T220019Z"
      //
      PROCEDURE DateHeureVersISO8601(local dDate est une date = datesys(), local hHeure est une heure = heuresys(),bEstDateHeureLocale est un booleen = vrai) : chaine
      dhUTC est une dateheure = dDate+hHeure
      si bEstDateHeureLocale alors dhUTC=DateHeureLocaleVersUTC(dDate+hHeure)
      renvoyer DateVersChaîne(dhUTC..PartieDate,"AAAAMMJJ")+"T"+HeureVersChaîne(dhUTC..PartieHeure,"HHMMSS")+"Z"	//ex : 2023-12-09T19:09:12.000Z
     type : 458752
   -
     name : ISO8601VersDateHeure
     procedure_id : 1547669371846523411
     type_code : 15
     code : |1-
      // Résumé : La fonction convertit une chaîne représentant une date et une heure au format ISO 8601 en une valeur de type DateHeure en prenant en compte le fuseau horaire UTC (temps universel coordonné).
      // Syntaxe : [ <Résultat> = ] ISO8601VersDateHeure (<sDateHeureISO8601> est chaîne)
      // Paramètres :
      //	sDateHeureISO8601 (chaîne UNICODE) : La chaîne représentant la date et l'heure au format ISO 8601. Elle doit être au format "AAAA-MM-JJTHH:MM:SS:CCCZ", où "T" est le séparateur entre la date et l'heure, et "Z" indique que le temps est en UTC.
      // Valeur de retour : dateheure : représentant la date et l'heure converties de la chaîne ISO 8601. Si la chaîne d'entrée est vide ou ne respecte pas le format attendu, la fonction renvoie une chaîne vide.
      // Exemple :
      //	sDateISO8601 = "2023-11-30T15:45:30:000Z"
      //	dhResultat = ISO8601VersDateHeure(sDateISO8601)
      //	dhResultat contiendra "20231130104530000"
      //
      PROCEDURE ISO8601VersDateHeure(sDateHeureISO8601 est une chaine) : dateheure
      si sDateHeureISO8601="" _ou_ sDateHeureISO8601[11]<>"T" _ou_ sDateHeureISO8601[24]<>"Z" alors renvoyer ""
      dhRes est une dateheure
      dhRes..PartieDate 	= chaineversdate(sDateHeureISO8601[1 a 10],"AAAA-MM-JJ")
      dhRes..Partieheure	= chaineversheure(sDateHeureISO8601[12 à 23],"HH:MM:SS:CCC")
      renvoyer DateHeureUTCVersLocale(dhRes)
     type : 458752
   -
     name : GrayVersBinaire
     procedure_id : 1568090881538484460
     type_code : 15
     code : |1-
      // Résumé : Converti un nombre binaire Gray en binaire "classique"
      // Syntaxe : [ <Résultat> = ] GrayVersBinaire (<sGray> est chaîne)
      // Paramètres :
      //	sGray (chaîne UNICODE) : chaine binaire Gray à convertir
      // Valeur de retour : chaîne UNICODE : Résultat de la conversion
      // Exemple :
      //
      PROCEDURE GrayVersBinaire(sGray est une chaîne) : chaîne
      //ref : https://forum.pcsoft.fr/fr-FR/pcsoft.fr.windev/270295-codage-gray/read.awp
      sBinary est une chaîne = sGray[1]
      POUR i=1 _À_ Taille(sGray)-1 sBinary+=(sBinary[i] = sGray[i+1] ? "0" SINON "1")
      RENVOYER sBinary
     type : 458752
   -
     name : BinaireVersGray
     procedure_id : 1568091611682963911
     type_code : 15
     code : |1-
      // Résumé : Converti un nombre binaire "classique" en binaire Gray
      // Syntaxe : [ <Résultat> = ] BinaireVersGray (<sBinary> est chaîne)
      // Paramètres :
      //	sBinary (chaîne UNICODE) : chaine binaire à convertir
      // Valeur de retour : chaîne UNICODE : Résultat de la conversion
      // Exemple :
      //
      PROCEDURE BinaireVersGray(sBinary est une chaîne) : chaîne
      //ref : https://forum.pcsoft.fr/fr-FR/pcsoft.fr.windev/270295-codage-gray/read.awp
      sGray est une chaîne = sBinary
      POUR i=Taille(sGray) À 1 PAS -1
      	SI sGray[i]="0" ALORS
      		SI sGray[i-1]="1" ALORS sGray[i]="1"
      	SINON
      		SI sGray[i-1]="1" ALORS sGray[i]="0"
      	FIN
      FIN
      RENVOYER sGray
     type : 458752
   -
     name : NumériqueEnArabe
     procedure_id : 1571355367376548434
     type_code : 15
     code : |1-
      // Résumé : Convertit un nombre entier en sa représentation en lettres en arabe. Elle supporte des nombres allant jusqu'à neuf chiffres.
      // Syntaxe :
      //[ <Résultat> = ] NumériqueEnArabe (<nValeur> est entier)
      // Paramètres :
      //	nValeur (entier) : Le nombre entier à convertir en lettres arabes
      // Valeur de retour : chaîne UNICODE : Le nombre en lettre arables
      // Exemple :
      //	sNombreEnLettres est une chaîne = NumériqueEnArabe(12345.45)
      //	sNombreEnLettres contiendra إثنى عشر ألفا  و ثلاثمائه و خمسه و أريعون
      //
      PROCEDURE NumériqueEnArabe(nValeur est un entier) : chaine
      //ref : https://www.fekwx.com/threads/chiffres-vers-lettre-arabe-code-exemple.21/
      sValeur est une chaine = NumériqueVersChaîne(nValeur)
      SELON Taille(sValeur)
      	CAS 1 : RENVOYER Premier(sValeur)
      	CAS 2 : RENVOYER Deuxième(sValeur)
      	CAS 3 : RENVOYER Troisième(sValeur)
      	CAS 4 : RENVOYER Quatrième(sValeur)
      	CAS 5 : RENVOYER Cinquième(sValeur)			
      	CAS 6 : RENVOYER Sixième(sValeur)	
      	CAS 7 : RENVOYER Septième(sValeur)
      	CAS 8 : RENVOYER Huitième(sValeur)
      	CAS 9 : RENVOYER Neuvième(sValeur)			
      	AUTRE CAS : ErreurDéclenche(ErreurPCS,<§@1b845284210c698d0006§>);renvoyer ""
      FIN
      
      	procédure interne Premier(sChiffre est une chaine) : chaine
      	SELON Val(sChiffre)
      		CAS 1 		: RENVOYER "واحد"
      		CAS 2 		: RENVOYER "إثنان"
      		CAS 3 		: RENVOYER "ثلاثه"
      		CAS 4 		: RENVOYER "أربعه"
      		CAS 5 		: RENVOYER "خمسه"
      		CAS 6 		: RENVOYER "سته"
      		CAS 7 		: RENVOYER "سبعه"
      		CAS 8 		: RENVOYER "ثمانيه"
      		CAS 9 		: RENVOYER "تسعه"
      		AUTRE CAS 	: RENVOYER ""
      	FIN
      	FIN
      	
      	Procédure Interne Deuxième(sChiffre est une chaine) : chaine
      	sPremier est une chaine
      	SELON val(sChiffre[1])
      		CAS 1 
      			SI sChiffre[2] = "1" ALORS RENVOYER "إحدى عشر"
      			SI sChiffre[2] = "2" ALORS rENVOYER"إثنى عشر"
      			RENVOYER Premier(sChiffre[2]) + " " + "عشر"
      		CAS 2		: sPremier = "عشرون "
      		CAS 3		: sPremier = "ثلاثون"
      		CAS 4		: sPremier = "أريعون"
      		CAS 5		: sPremier = "خمسون"
      		CAS 6		: sPremier = "ستون"
      		CAS 7		: sPremier = "سبعون"
      		CAS 8		: sPremier = "ثمانون"
      		CAS 9		: sPremier = "تسعون"
      		AUTRE CAS 	: sPremier = ""
      	FIN
      	SI sChiffre[[2]] = "0" OU sChiffre[[1]] = "1" ALORS RENVOYER sPremier SINON RENVOYER Premier(sChiffre[2]) + " و " + sPremier
      	FIN
      	
      	procédure interne Troisième(sChiffre est une chaine) : chaîne
      	SELON val(sChiffre[1])
      		CAS 0
      			SI sChiffre[2] = "0" alors
      				SI sChiffre[3] = "0" alors RENVOYER "" SINON RENVOYER Premier(sChiffre[3])	
      			SINON
      				RENVOYER Deuxieme(sChiffre[2 À 3])
      			FIN
      		CAS 1
      			SI sChiffre[2] = "0" ALORS
      				SI sChiffre[3] = "0" ALORS RENVOYER "مائه" SINON RENVOYER "مائه" + " و " + Premier(sChiffre[3])
      			SINON	
      				RENVOYER "مائه" + " و " +Deuxieme(sChiffre[2 à 3])
      			FIN		
      		CAS 2
      			SI sChiffre[2] = "0" ALORS
      				SI sChiffre[3] = "0" RENVOYER "مائتين" SINON RENVOYER "مائتين" + " و " + Premier(sChiffre[3])
      			ELSE
      				RENVOYER "مائتين" + " و " + Deuxieme(sChiffre[2 À 3])
      			FIN		
      		CASE 3,4,5,6,7,8,9
      			sPremier est une chaîne = Premier(sChiffre[1])
      			sPremier = Gauche(sPremier,Taille(sPremier)-1)
      			SI sChiffre[2] = "0" ALORS
      				SI sChiffre[3] = "0" ALORS RENVOYER sPremier + "مائه" SINON RENVOYER sPremier + "مائه" + " و " + Premier(sChiffre[3])
      			sinon
      				RENVOYER sPremier + "مائه" + " و " + Deuxieme(sChiffre[2 À 3])
      			FIN					
      		AUTRES CAS : RENVOYER ""
      	FIN
      	FIN
      
      	procédure interne Quatrième(sChiffre est une chaine) : chaîne
      	SELON val(sChiffre[1])
      		CAS 1
      			SI sChiffre[2] = "0" alors
      				SI sChiffre[3] = "0" alors
      					SI sChiffre[4] = "0" alors RENVOYER "ألف" SINON RENVOYER "ألف" + " و " + Premier(sChiffre[4])
      				SINON		
      					RENVOYER "ألف" + " و " + Deuxieme(sChiffre[3 à 4])
      				FIN		
      			SINON
      				RENVOYER "ألف" + " و " + Troisieme(sChiffre[2 à 4])
      			FIN
      		CASE 2
      			SI sChiffre[2] = "0" alors
      				SI sChiffre[3] = "0" ALORS
      					SI sChiffre[4] = "0" alors RENVOYER "ألفين" SINON RENVOYER "ألفين" + " و " + Premier(sChiffre[4])
      				SINON	
      					RENVOYER "ألفين" + " و " + Deuxieme(sChiffre[3 À 4])
      				FIN		
      			ELSE
      				RENVOYER "ألفين" + " و " + Troisième(sChiffre[2 À 4])
      			FIN			
      		CASE 3,4,5,6,7,8,9
      			SI sChiffre[2] = "0" ALORS
      				SI sChiffre[3] = "0" ALORS
      					SI sChiffre[4] = "0" alors RENVOYER Premier(sChiffre[1]) + " ألاف" SINON 	RENVOYER Premier(sChiffre[1]) + " ألاف" + " و " + Premier(sChiffre[4])
      				SINON		
      					RENVOYER Premier(sChiffre[1]) + " ألاف" + " و " + Deuxieme(sChiffre[3 À 4])
      				FIN		
      			sinon
      				RENVOYER Premier(sChiffre[1]) + " ألاف" + " و " + Troisieme(sChiffre[2 À 4])
      			FIN
      		AUTRES CAS : RENVOYER ""
      	FIN
      	FIN
      	
      	procédure interne Cinquième(sChiffre est une chaine) : chaine
      	SI Troisieme(sChiffre[3 à 5]) = "" alors RENVOYER Deuxieme(sChiffre[1 à 2]) + " ألف " SINON RENVOYER Deuxieme(sChiffre[1 À 2]) + " ألفا " + " و " + Troisieme(sChiffre[3 À 5])
      	FIN
      	
      	procédure interne Sixième(sChiffre est une chaine) : chaîne
      	SI Troisieme(sChiffre[4 à 6]) = "" ALORS
      		RENVOYER Troisieme(sChiffre[1 À 3]) + " ألفا " + " و " + Troisieme(sChiffre[4 À 6])
      	SINON
      		SI Troisieme(sChiffre[1 à 3]) = "" ALORS RENVOYER Troisieme(sChiffre[4 À 6]) sINON RENVOYER Troisieme(sChiffre[1 À 3]) + " ألف " + Troisieme(sChiffre[4 À 6])
      	FIN
      	FIN
      	
      	procédure interne Septième(sChiffre est une chaine) : chaine
      	SELON val(sChiffre[1])
      		CAS 1
      			SI Sixiéme(sChiffre[2 À 7]) = "" OU Sixiéme(sChiffre[2 À 7])= " ألف " RENVOYER "مليون" sINON RENVOYER "مليون" + " و " + Sixiéme(sChiffre[2 À 7])
      		CAS 2
      			SI Sixiéme(sChiffre[2 À 7]) = "" OU Sixiéme(sChiffre[2 À 7])= " ألف " RENVOYER "مليونين" SINON rENVOYER  "مليونين" + " و " + Sixiéme(sChiffre[2 À 7])
      		CAS 3,4,5,6,7,8,9
      			SI Sixiéme(sChiffre[2 à 7]) = "" OU Sixiéme(sChiffre[2 À 7])= " ألف " RENVOYER Premier(sChiffre[1]) + " ملايين " SINON RENVOYER Premier(sChiffre[1]) + " ملايين"+ " و " + Sixiéme(Droite(sChiffre,6))	
      		AUTRES CAS : RENVOYER ""
      	FIN
      	FIN
      	
      	procédure interne Huitième(sChiffre est une chaine) : chaine
      	SI Sixième(sChiffre[3 à 8]) = "" alors RENVOYER Deuxieme(sChiffre[1 à 2]) + " مليون  " SINON RENVOYER Deuxieme(sChiffre[1 À 2]) + " مليون " + " و " + Sixième(sChiffre[3 À 8])
      	FIN
      	
      	procédure interne Neuvième(sChiffre est une chaine) : chaine
      	SI Sixième(sChiffre[3 À 9]) = "" OU Sixième(sChiffre[3 À 9]) = "الف" ALORS RENVOYER Troisieme(sChiffre[1 à 3]) + " مليون " sINON RENVOYER Troisieme(sChiffre[1 À 3]) + " مليون " + " و " + Sixième(sChiffre[3 À 9])
      	FIN
     type : 458752
   -
     name : NumériqueEnFrançais
     procedure_id : 1571355375966549921
     type_code : 15
     code : |1-
      // Résumé : Convertit une valeur numérique donnée en lettres en français, en prenant en compte diverses options telles que la langue, la portion à convertir (partie entière ou décimale), et d'autres paramètres.
      //	Cette fonction remplace NombreEnLettres et permet d'avoir le résultat en français mais aussi en canadien français, en belge, en suisse, en franco-africain et en particulier pour la république démocratique du Congo
      // Syntaxe : [ <Résultat> = ] NumériqueEnFrançais (<xValeur> [, <ePortion> est COL_Conversion.ENumériqueEnChaine [, <eLangue> est COL_Conversion.ENumériqueEnFrançaisLangue [, <eOptions> est COL_Conversion.ENumériqueEnFrançaisOption [, <bOrthographe1990> est booléen]]]])
      // Paramètres :
      //	xValeur : La valeur numérique à convertir en lettres.
      //	ePortion (COL_Conversion.ENumériqueEnChaine) : La portion de la valeur à convertir (partie entière ou décimale), par défaut PartieEntière.
      //	eLangue (COL_Conversion.ENumériqueEnFrançaisLangue) : La langue pour la conversion, avec la possibilité de choisir entre la France, le Canada, la Suisse, ... Par défaut "France"
      //	eOptions (COL_Conversion.ENumériqueEnFrançaisOption) : Diverses options de conversion, telles que l'orthographe de 1990 ou l'orthographe classique.
      // 	bOrthographe1990 (booléen) : Conforme aux rectifications orthographiques de 1990, Faux par défaut
      // Valeur de retour : Type indéterminé : soit le chiffre transformé en mot français (selon les options), soit la valeur entrée si elle n'est pas numérique
      // Exemple :
      //	sChaineEnLettres est une chaîne = NumériqueEnFrançais(1234.56, PartieEntière, France, Classique)
      //	sChaineEnLettres contiendra "mille deux cent trente-quatre"
      //
      pROCEDURE NumériqueEnFrançais(xValeur,ePortion est un ENumériqueEnChaine = PartieEntière,local eLangue est une ENumériqueEnFrançaisLangue = France,local eOptions est un ENumériqueEnFrançaisOption = Classique,bOrthographe1990 est un booleen = faux)
      //ref : https://fr.wikipedia.org/wiki/Noms_des_grands_nombres   et   https://fr.wikipedia.org/wiki/Nombres_en_fran%C3%A7ais
      tabUnité		est un tableau de chaines	= ["un","deux","trois","quatre","cinq","six","sept","huit","neuf","dix","onze","douze","treize","quatorze","quinze","seize","dix-sept","dix-huit","dix-neuf"]
      tabDizaine		est un tableau de chaînes	= ["dix","vingt","trente","quarante","cinquante","soixante","septante","huitante","nonante"]
      tabMulti		est un tableau de chaines	= ["mille","million","milliard","billion","billiard","trillion","trilliard","quadrillion","quadrilliard","quintillion","quintilliard","sextillion","sextilliard","septillion","septilliard","octillion","octilliard","nonillion","nonilliard","décillion","décilliard"]	//un entier sur 8 octets traite des nombres 10^9
      s4x20			est une chaine				= "quatre-vingt"
      sLettres,sSépar	sont des chaines
      sVal			est une chaine				= NumVersChaine(xValeur)
      bMoins,bPlus	est un booleen
      
      SI ePortion=PartieEntière ALORS 
      	sVal=ExtraitChaîne(sVal,1,".")
      SINON SI Position(sVal,".")>0 ALORS
      	sVal=ExtraitChaîne(sVal,2,".")
      	si val(sVal)=0 alors renvoyer ""	//les 0 décimaux ne sont pas pertinents à décrire
      FIN
      SI sVal="" ALORS RENVOYER xValeur
      SI sVal DANS ("0","-0") ALORS RENVOYER "zéro"
      SI sVal[1]="+" ALORS bPlus=Vrai;sVal=Milieu(sVal,2)
      SI sVal[1]="-" ALORS bMoins=Vrai;sVal=Milieu(sVal,2)
      si bOrthographe1990 alors sSépar="-" sinon sSépar=" "
      
      SELON ePortion
      	CAS PartieEntière
      		SI eOptions=CentainesVigésimales _ET_ 1100<=Val(sVal)<1999 ALORS	//dix-neuf-cent quatre-vingt-dix-neuf
      			nCentaines	est un entier = Centaine(xValeur)
      			nUnités		est un entier = Dizaine(xValeur)*10+unite(xValeur)
      			RENVOYER (bPlus ? "plus " SINON "")+(bMoins ? "moins " SINON "")+tabUnité[nCentaines]+[sSépar]+"cent"+(nUnités=0 ? "s" SINON sSépar+tabUnité[nUnités])
      		SINON
      			nUnités		est un entier = unités(xValeur)
      			nMilliers 	est un entier = Millier(xValeur)
      			nMillions 	est un entier = Million(xValeur)
      			nMilliards 	est un entier = Milliard(xValeur)
      			nBillions 	est un entier = Billion(xValeur)
      			nBilliards 	est un entier = Billiard(xValeur)
      			nTrillions 	est un entier = Trillion(xValeur)
      			nTrilliards est un entier = Trilliard(xValeur)
      			sUnités		est une chaine = (nUnités=0 ? "" sinon TraiteCentaines(nUnités,vrai))
      			sMilliers	est une chaine = (nMilliers=0 ? "" sinon TraiteCentaines(nMilliers,faux,vrai)+[sSépar]+tabMulti[1])	//mille est invariable
      			sMillions	est une chaine = (nMillions=0 ? "" sinon TraiteCentaines(nMillions,vrai)+[sSépar]+tabMulti[2]+(nMillions=1 ? "" sinon "s"))
      			sMilliards	est une chaine = (nMilliards=0 ? "" sinon TraiteCentaines(nMilliards,vrai)+[sSépar]+tabMulti[3]+(nMilliards=1 ? "" sinon "s"))
      			sBillions	est une chaine = (nBillions=0 ? "" sinon TraiteCentaines(nBillions,vrai)+[sSépar]+tabMulti[4]+(nBillions=1 ? "" sinon "s"))
      			sBilliards	est une chaine = (nBilliards=0 ? "" sinon TraiteCentaines(nBilliards,vrai)+[sSépar]+tabMulti[5]+(nBilliards=1 ? "" sinon "s"))
      			sTrillions	est une chaine = (nTrillions=0 ? "" sinon TraiteCentaines(nTrillions,vrai)+[sSépar]+tabMulti[6]+(nTrillions=1 ? "" sinon "s"))
      			sTrilliards	est une chaine = (nTrilliards=0 ? "" sinon TraiteCentaines(nTrilliards,vrai)+[sSépar]+tabMulti[7]+(nTrilliards=1 ? "" sinon "s"))
      			sLettres	= sTrilliards+[sSépar]+sTrillions+[sSépar]+sBilliards+[sSépar]+sBillions+[sSépar]+sMilliards+[sSépar]+sMillions+[sSépar]+sMilliers+[sSépar]+sUnités	//
      			RENVOYER (bPlus ? "plus " SINON "")+(bMoins ? "moins " SINON "")+sLettres
      		FIN
      	AUTRES CAS //toujours avec des tirets
      		SI ePortion=PartieDécimaleMonétaire ET Millier(sVal)>0 ALORS ePortion=PartieDécimaleStandard //une partie décimale monétaire ne peut pas dépasser 3 chiffres
      		SI ePortion=PartieDécimaleMonétaire ALORS
      			sLettres=TraiteCentaines(Unités(sVal),Vrai)
      			RENVOYER Remplace(sLettres," ","-")
      		SINON SI ePortion=PartieDécimaleStandard ALORS
      			POUR nChiffre = 1 _a_ taille(sVal)
      				sLettres+=["-"]+tabUnité[Val(sVal[nChiffre])]	
      			FIN
      			RENVOYER sLettres
      		FIN
      FIN
      RENVOYER ""
      
      	PROCÉDURE INTERNE TraiteCentaines(LOCAL nValeur est un entier,bUnité est un booleen = faux,bMille est un booleen = faux) : chaine
      	sRes 		est une chaine
      	nCentaine 	est un entier = Centaine(nValeur)
      	nDizaine 	est un entier = dizaine(nValeur)
      	nUnité 		est un entier = unité(nValeur)
      	SI nCentaine>0 ALORS
      		SI nCentaine=1 ALORS sRes="cent" SINON sRes=tabUnité[nCentaine]+[sSepar]+"cent"+(bUnité _OU_ nUnité+nDizaine>0 ? "" SINON "s")
      	FIN
      	SELON nDizaine
      		CAS 0 : SI nUnité>1 _OU_ bUnité ALORS sRes+=[sSépar]+tabUnité[nUnité]
      		CAS 1 : sRes+=[sSépar]+tabUnité[nDizaine*10+nUnité]
      		CAS 2 À 6 : sRes+=[sSépar]+tabDizaine[nDizaine]+(nUnité=0 ? "" SINON sEt(nUnité)+tabUnité[nUnité])
      		CAS 7 : sRes+=[sSépar]+(eLangue=France OU eLangue=Canada ? tabDizaine[6]+(nUnité=0 ? "" SINON sEt(nUnité)+tabUnité[10+nUnité]) SINON tabDizaine[7]+(nUnité=0 ? "" SINON sEt(nUnité)+tabUnité[nUnité]))
      		CAS 8 : sRes+=[sSépar]+(eLangue=Suisse ? tabDizaine[8]+(nUnité=0 ? "" SINON sEt(nUnité)+tabUnité[nUnité]) SINON s4x20+(nUnité>0 _OU_ bMille ? "" SINON "s")+(nUnité=0 ? "" SINON "-")+tabUnité[nUnité])
      		CAS 9 : sRes+=[sSépar]+(eLangue=France OU eLangue=Canada ? s4x20+"-"+tabUnité[10+nUnité] SINON tabDizaine[9]+(nUnité=0 ? "" SINON sEt(nUnité)+tabUnité[nUnité]))
      	FIN
      	RENVOYER sRes
      	FIN
      
      	PROCÉDURE INTERNE sEt(nValUnité est un entier) : chaine
      	RENVOYER (nValUnité=1 ? sSépar+"et"+sSépar SINON "-")
      	FIN
     type : 458752
   -
     name : NumériqueEnEspagnol
     procedure_id : 1571355564945154976
     type_code : 15
     code : |1+
      // Résumé : Prend une valeur numérique et la convertit en mots en espagnol.
      // Syntaxe : [ <Résultat> = ] NumériqueEnEspagnol (<xValeur> [, <ePortion> est COL_Conversion.ENumériqueEnChaine])
      // Paramètres :
      //	xValeur : La valeur numérique à convertir en lettres.
      //	ePortion (COL_Conversion.ENumériqueEnChaine) : La portion de la valeur à convertir (partie entière ou décimale), par défaut PartieEntière.
      // Valeur de retour : Type indéterminé : soit le chiffre transformé en mot français (selon les options), soit la valeur entrée si elle n'est pas numérique
      // Exemple :
      //	sChaineEnLettres est une chaîne = NumériqueEnEspagnol(9761.47, PartieEntière)
      //	sChaineEnLettres contiendra "nueve mil setecientos sesenta y uno"
      //
      PROCEDURE NumériqueEnEspagnol(xValeur,ePortion est un ENumériqueEnChaine = PartieEntière) : chaine
      //ref : https://es.wikipedia.org/wiki/Anexo:Nombres_de_los_n%C3%BAmeros_en_espa%C3%B1ol  et  https://es.wikipedia.org/wiki/Escalas_num%C3%A9ricas_larga_y_corta
      tabUnité		est un tableau de chaine = ["uno", "dos", "tres", "cuatro", "cinco", "seis", "siete", "ocho", "nueve", "diez", "once", "doce", "trece", "catorce", "quince", "dieciséis", "diecisiete", "dieciocho", "diecinueve"]
      tabDizaine		est un tableau de chaine = ["diez", "veinte", "treinta", "cuarenta", "cincuenta", "sesenta", "setenta", "ochenta", "noventa"]
      tabCentaine 	est un tableau de Chaîne = ["ciento", "doscientos", "trescientos", "cuatrocientos", "quinientos", "seiscientos", "setecientos", "ochocientos", "novecientos"]
      tabMulti 		est un Tableau de Chaîne = ["mil", "millones","millardo","billón","billardo","trillón","trillardo"]
      bMoins,bPlus	est un booleen
      sLettres		est une chaine
      sVal			est une chaine = NumVersChaine(xValeur)
      
      SI ePortion=PartieEntière ALORS 
      	sVal=ExtraitChaîne(sVal,1,".")
      SINON SI Position(sVal,".")>0 ALORS
      	sVal=ExtraitChaîne(sVal,2,".")
      	SI Val(sVal)=0 ALORS RENVOYER ""	//les 0 décimaux ne sont pas pertinents à décrire
      FIN
      
      SI sVal="" ALORS RENVOYER xValeur
      SI sVal DANS ("0","-0") ALORS RENVOYER "cero"
      SI sVal[1]="+" ALORS bPlus=Vrai;sVal=Milieu(sVal,2)
      SI sVal[1]="-" ALORS bMoins=Vrai;sVal=Milieu(sVal,2)
      
      si xValeur="1" alors renvoyer tabUnité[1]
      
      SELON ePortion
      	CAS PartieEntière
      		nUnités		est un entier = unités(xValeur)
      		nMilliers 	est un entier = Millier(xValeur)
      		nMillions 	est un entier = Million(xValeur)
      		nMilliards 	est un entier = Milliard(xValeur)
      		nBillions 	est un entier = Billion(xValeur)
      		nBilliards 	est un entier = Billiard(xValeur)
      		nTrillions 	est un entier = Trillion(xValeur)
      		nTrilliards est un entier = Trilliard(xValeur)
      		sUnités		est une chaine = (nUnités=0 ? "" sinon TraiteCentaines(nUnités,vrai))
      		sMilliers	est une chaine = (nMilliers=0 ? "" sinon TraiteCentaines(nMilliers,faux,vrai)+[" "]+tabMulti[1])
      		sMillions	est une chaine = (nMillions=0 ? "" sinon TraiteCentaines(nMillions,vrai)+[" "]+(nMillions=1 ? "millón" sinon tabMulti[2]))
      		sMilliards	est une chaine = (nMilliards=0 ? "" sinon TraiteCentaines(nMilliards,vrai)+[" "]+tabMulti[3]+(nMilliards=1 ? "" sinon "s"))
      		sBillions	est une chaine = (nBillions=0 ? "" sinon TraiteCentaines(nBillions,vrai)+[" "]+tabMulti[4]+(nBillions=1 ? "" sinon "s"))
      		sBilliards	est une chaine = (nBilliards=0 ? "" sinon TraiteCentaines(nBilliards,vrai)+[" "]+tabMulti[5]+(nBilliards=1 ? "" sinon "s"))
      		sTrillions	est une chaine = (nTrillions=0 ? "" sinon TraiteCentaines(nTrillions,vrai)+[" "]+tabMulti[6]+(nTrillions=1 ? "" sinon "s"))
      		sTrilliards	est une chaine = (nTrilliards=0 ? "" sinon TraiteCentaines(nTrilliards,vrai)+[" "]+tabMulti[7]+(nTrilliards=1 ? "" sinon "s"))
      		sLettres	= sTrilliards+[" "]+sTrillions+[" "]+sBilliards+[" "]+sBillions+[" "]+sMilliards+[" "]+sMillions+[" "]+sMilliers+[" "]+sUnités
      		RENVOYER (bPlus ? "más " SINON "")+(bMoins ? "menos " SINON "")+sLettres
      	AUTRES CAS
      		SI ePortion=PartieDécimaleMonétaire ET Millier(sVal)>0 ALORS ePortion=PartieDécimaleStandard //une partie décimale monétaire ne peut pas dépasser 3 chiffres
      		SI ePortion=PartieDécimaleMonétaire ALORS
      			RENVOYER TraiteCentaines(Unités(sVal),Vrai)
      		SINON SI ePortion=PartieDécimaleStandard ALORS
      			si Taille(sVal)>2 alors sLettres=TraiteCentaines(gauche(sVal,2));sVal=milieu(sVal,3)
      			POUR nChiffre = 1 _À_ Taille(sVal)
      				sLettres+=[" "]+tabUnité[Val(sVal[nChiffre])]	
      			FIN
      			RENVOYER sLettres
      		FIN
      fin
      		
      	PROCÉDURE INTERNE TraiteCentaines(LOCAL nValeur est un entier,bUnité est un booleen = faux,bMille est un booleen = faux) : chaine
      	sRes 		est une chaine
      	nCentaine 	est un entier = Centaine(nValeur)
      	nDizaine 	est un entier = dizaine(nValeur)
      	nUnité 		est un entier = unité(nValeur)
      	si nUnité=1 _et_ nDizaine=0 _et_ nCentaine=0 _et_ pas bMille alors renvoyer "un"
      	SI nCentaine>0 ALORS sRes=tabCentaine[nCentaine]
      	SELON nDizaine
      		CAS 0 		: SI nUnité>1 _OU_ bUnité ALORS sRes+=[" "]+tabUnité[nUnité]
      		CAS 1 		: sRes+=[" "]+tabUnité[nDizaine*10+nUnité]
      		cas 2		: sRes+=[" "]+(nUnité>0 ? "veinti"+(nUnité="3" ? "trés" sinon tabUnité[nUnité]) sinon tabDizaine[nDizaine])
      		autres cas	: 
      			sRes+=[" "]+remplace(Remplace(tabDizaine[nDizaine]+[(nDizaine+nCentaine=0 ? " " SINON " y ")]+(nUnité=1 ? ["y "]+"uno" sinon (nUnité>1 _OU_ bUnité) _ET_ nUnité<>0 ? tabUnité[nUnité] sinon ""),"e y ","i")," y y "," y ")
      	fin
      	RENVOYER sRes
      	FIN
     type : 458752
   -
     name : AdjectifOrdinal
     procedure_id : 1571590070478161136
     type_code : 15
     code : |1-
      // Résumé : Retourne l'adjectif ordinal correspondant à un chiffre donné. Par exemple, pour le chiffre 1, elle renvoie "1er", pour le chiffre 2, elle renvoie "2nd", et ainsi de suite.
      // Syntaxe : [ <Résultat> = ] AdjectifOrdinal (<nChiffre> est entier)
      // Paramètres :
      //	nChiffre (entier) : Le chiffre pour lequel l'adjectif ordinal doit être trouvé.
      // Valeur de retour : chaîne UNICODE : L'adjectif ordinal correspondant au chiffre donné.
      // Exemple :
      //	nChiffre est un entier = 3
      //	sAdjectifOrdinal est une chaîne = AdjectifOrdinal(nChiffre)
      //	//sAdjectifOrdinal contient "3ème"
      //
      PROCEDURE AdjectifOrdinal(nChiffre est un entier) : chaine
      SELON nChiffre
      	CAS 1	: RENVOYER <§@1b155a2803bc06420051§>	
      	CAS 2	: RENVOYER <§@1b155a2803bc06420052§>
      	CAS 3	: RENVOYER <§@1b155a2803bc06420053§>
      	AUTRE CAS : RENVOYER nChiffre+<§@1b155a2803bc06420054§>
      FIN
     type : 458752
   -
     name : FrançaisEnNumérique
     procedure_id : 1576853761453597961
     type_code : 15
     code : |1+
      // Résumé : Prend une chaîne représentant un nombre en français et le convertit en valeur numérique.
      // Syntaxe : [ <Résultat> = ] FrançaisEnNumérique (<sNombre> est chaîne)
      // Paramètres :	sNombre (chaîne UNICODE) : La chaîne représentant le nombre en français.
      // Valeur de retour : entier : La valeur numérique correspondante.
      // Exemple :
      // nValeur est un entier = FrançaisEnNumérique("cent vingt-trois")
      //	nValeur contiendra 123
      //
      PROCEDURE FrançaisEnNumérique(local sNombre est une chaine) : entier
      sNombre=minuscule(sansespace(sNombre))
      si sNombre="zéro" ou sNombre="" alors renvoyer 0
      sNombre=Remplace(sNombre,"quatre-vingt","quatrevingt")
      
      tabUnité	est un tableau de chaines	= ["un","deux","trois","quatre","cinq","six","sept","huit","neuf","dix","onze","douze","treize","quatorze","quinze","seize","dix-sept","dix-huit","dix-neuf"]
      tabDizaine	est un tableau de chaînes	= ["dix","vingt","trente","quarante","cinquante","soixante","septante","huitante","nonante"]
      tabMulti	est un tableau de chaines	= ["mille","million","milliard","billion","billiard","trillion","trilliard","quadrillion","quadrilliard","quintillion","quintilliard","sextillion","sextilliard","septillion","septilliard","octillion","octilliard","nonillion","nonilliard","décillion","décilliard"]	//un entier sur 8 octets traite des nombres 10^9
      nRes		est un entier sur 8 octets
      sVal,sMulti	est une chaine
      POUR TOUTE CHAÎNE sMulti DE sNombre SÉPARÉE PAR " "
      	SI tabMulti.Cherche(tcLinéaire,(Droite(sMulti,1)="s" ? Gauche(sMulti,Taille(sMulti)-1) SINON sMulti))>0 ALORS
      		nRes+=(sVal="" ? 1 SINON ChaineVersNum(sVal))*Puissance(10,3*tabMulti.Cherche(tcLinéaire,(Droite(sMulti,1)="s" ? Gauche(sMulti,Taille(sMulti)-1) SINON sMulti)))
      		sVal=""
      	SINON
      		sVal+=[" "]+sMulti
      	FIN
      FIN
      SI sVal>"" ALORS nRes+=ChaineVersNum(sVal)
      renvoyer nRes
      
      	PROCÉDURE INTERNE ChaineVersNum(sChaine) : entier
      	sChaine=SansEspace(sChaine);SI sChaine="" ALORS RENVOYER 0
      	nUnités est un entier
      	SI Position(sChaine,"cent",0,SansCasse)>0 ALORS
      		RENVOYER Max(ChaineVersNum(ExtraitChaîne(sChaine,1,"cent",SansCasse)),1)*100+ChaineVersNum(ExtraitChaîne(sChaine,2,"cent",SansCasse))
      	SINON
      		POUR TOUTE CHAÎNE sPartie de sChaine séparéé par " "
      			POUR TOUTE CHAÎNE sPartie2 de sPartie séparée par "-"
      				SI sPartie2="quatrevingt" ALORS
      					nUnités+=80
      				SINON
      					SI tabDizaine.Cherche(tcLinéaire,sPartie2)>0 ALORS 
      						nUnités+=tabDizaine.Cherche(tcLinéaire,sPartie2)*10
      					SINON SI tabUnité.Cherche(tcLinéaire,sPartie2)>0 ALORS
      						nUnités+=tabUnité.Cherche(tcLinéaire,sPartie2)
      					FIN
      				FIN
      			FIN
      		FIN
      	FIN
      	RENVOYER nUnités
      	FIN
     type : 458752
   -
     name : DateVersTrimestre
     procedure_id : 1585332129712202524
     type_code : 15
     code : |1-
      // Résumé : Prend une date sous forme de chaîne et renvoie le trimestre correspondant ainsi que l'année associée. Elle extrait le mois de la date fournie et utilise cette information pour déterminer le trimestre.
      // Syntaxe : [ <Résultat> = ] DateVersTrimestre (<xDate>)
      // Paramètres :
      // 	xDate : La date au format chaîne ou date
      // Valeur de retour : multi-valeur : Le premier élément du tuple représente le trimestre, et le deuxième élément représente l'année associée à la date fournie.
      // Exemple :
      //	trimestre,année sont des entiers
      //	(trimestre, année) = DateVersTrimestre("2024-04-15")
      //	Résultat: trimestre = 2, année = 2024
      //
      PROCEDURE DateVersTrimestre(xDate) : (entier,entier)
      sDate est une chaine = xDate
      SELON Val(sDate[5 À 6])
      	CAS 1 À 3		: RENVOYER (1,Val(sDate[1 À 4]))
      	CAS 4 À 6		: RENVOYER (2,Val(sDate[1 À 4]))
      	CAS 7 À 9		: RENVOYER (3,Val(sDate[1 À 4]))
      	CAS 10 À 12		: RENVOYER (4,Val(sDate[1 À 4]))
      FIN
      RENVOYER (0,0)
     type : 458752
   -
     name : TrimestreVersDates
     procedure_id : 1585335393978743506
     type_code : 15
     code : |1-
      // Résumé : Convertit un numéro de trimestre et une année donnés en dates de début et de fin du trimestre correspondant.
      // Syntaxe : [ <Résultat> = ] TrimestreVersDates (<nTrimestre> est entier, <nAnnée> est entier)
      // Paramètres :
      //	nTrimestre (entier) : Numéro du trimestre (1, 2, 3 ou 4).
      //	nAnnée (entier) : <indiquez ici le rôle de nAnnée>
      // Valeur de retour : multi-valeur : Renvoie les dates de début et de fin du trimestre
      // Exemple :
      //	TrimestreVersDates(2, 2024) 
      //	Renvoie : "20240401" et "20240630"
      PROCEDURE TrimestreVersDates(nTrimestre est un entier,nAnnée est un entier) : (date,date)
      dDébut,dFin sont des Dates
      SELON nTrimestre
      	CAS 1		: dDébut=nAnnée+"0101"
      	CAS 2		: dDébut=nAnnée+"0401"
      	CAS 3		: dDébut=nAnnée+"0701"
      	CAS 4		: dDébut=nAnnée+"1001"
      	autres cas	: dDébut="";dFin="";renvoyer (dDébut,dFin)
      FIN
      dFin=dDébut;dFin..Mois+=3;dFin..Jour--
      RENVOYER (dDébut,dFin)
     type : 458752
  procedure_templates : []
  property_templates : []
 code_parameters :
  internal_properties : CQAAAAkAAACVGQgYbalU7DKC3oH4ItDrjtcTHXXV/EuH8q0IbhyQlw==
resources :
 string_res :
  identifier : 0x1b155a2803bc0642
  internal_properties : CQAAAAkAAACm76HWfKGWp33VjXInA4cRlqArlgTTA862QGt72W2ld5Y=
  strings :
   -
     text :
      fr-FR : <vide>
      en-GB : <empty>
      fr-CA : <vide>
      en-US : <empty>
     index : 0
   -
     text :
      fr-FR : octet
      en-GB : byte
      fr-CA : octet
      en-US : byte
     index : 1
   -
     text :
      fr-FR : mètre
      en-GB : meter
      fr-CA : mètre
      en-US : meter
     index : 2
   -
     text :
      fr-FR : unité astronomique
      en-GB : astronomical unit
      fr-CA : unité astronomique
      en-US : astronomical unit
     index : 3
   -
     text :
      fr-FR : année-lumière
      en-GB : light-year
      fr-CA : année-lumière
      en-US : light-year
     index : 4
   -
     text :
      fr-FR : pied
      en-GB : foot
      fr-CA : pied
      en-US : foot
     index : 5
   -
     text :
      fr-FR : pouce
      en-GB : inch
      fr-CA : pouce
      en-US : inch
     index : 6
   -
     text :
      fr-FR : mille international
      en-GB : international mile
      fr-CA : mille international
      en-US : international mile
     index : 7
   -
     text :
      fr-FR : verge
      en-GB : yard
      fr-CA : verge
      en-US : verge
     index : 8
   -
     text :
      fr-FR : gravité terrestre
      en-GB : earth gravity
      fr-CA : gravité terrestre
      en-US : earth gravity
     index : 9
   -
     text :
      fr-FR : mètre par seconde au carré
      en-GB : meter per second squared
      fr-CA : mètre par seconde au carré
      en-US : meter per second squared
     index : 10
   -
     text :
      fr-FR : degré
      en-GB : degree
      fr-CA : degré
      en-US : degree
     index : 11
   -
     text :
      fr-FR : seconde
      en-GB : second
      fr-CA : seconde
      en-US : second
     index : 12
   -
     text :
      fr-FR : heure
      en-GB : hour
      fr-CA : heure
      en-US : hour
     index : 13
   -
     text :
      fr-FR : livre-force
      en-GB : pound-force
      fr-CA : livre-force
      en-US : pound-force
     index : 14
   -
     text :
      fr-FR : kilogramme-force
      en-GB : kilogram-force
      fr-CA : kilogramme-force
      en-US : kilogram-force
     index : 15
   -
     text :
      fr-FR : jour
      en-GB : day
      fr-CA : jour
      en-US : day
     index : 16
   -
     text :
      fr-FR : kilogramme
      en-GB : kilogram
      fr-CA : kilogramme
      en-US : kilogram
     index : 17
   -
     text :
      fr-FR : tonne
      en-GB : ton
      fr-CA : tonne
      en-US : ton
     index : 18
   -
     text :
      fr-FR : livre
      en-GB : pound
      fr-CA : livre
      en-US : pound
     index : 19
   -
     text :
      fr-FR : livre impériale
      en-GB : imperial pound
      fr-CA : livre impériale
      en-US : imperial pound
     index : 20
   -
     text :
      fr-FR : once impériale
      en-GB : imperial ounce
      fr-CA : once impériale
      en-US : imperial ounce
     index : 21
   -
     text :
      fr-FR : newton par mètre carré
      en-GB : newton per square meter
      fr-CA : newton par mètre carré
      en-US : newton per square meter
     index : 22
   -
     text :
      fr-FR : livre par pouce carré
      en-GB : pound per square inch
      fr-CA : livre par pouce carré
      en-US : pound per square inch
     index : 23
   -
     text :
      fr-FR : atmosphère technique
      en-GB : technical atmosphere
      fr-CA : atmosphère technique
      en-US : technical atmosphere
     index : 24
   -
     text :
      fr-FR : atmosphère physique
      en-GB : physical atmosphere
      fr-CA : atmosphère physique
      en-US : physical atmosphere
     index : 25
   -
     text :
      fr-FR : millimètre de mercure
      en-GB : millimeter of mercury
      fr-CA : millimètre de mercure
      en-US : millimeter of mercury
     index : 26
   -
     text :
      fr-FR : cheval-vapeur
      en-GB : horsepower
      fr-CA : cheval-vapeur
      en-US : horsepower
     index : 27
   -
     text :
      fr-FR : cheval vapeur américain
      en-GB : American horsepower
      fr-CA : cheval vapeur américain
      en-US : American horsepower
     index : 28
   -
     text :
      fr-FR : mètre carré
      en-GB : square meter
      fr-CA : mètre carré
      en-US : square meter
     index : 29
   -
     text :
      fr-FR : hectare
      en-GB : hectare
      fr-CA : hectare
      en-US : hectare
     index : 30
   -
     text :
      fr-FR : pied carré
      en-GB : square foot
      fr-CA : pied carré
      en-US : square foot
     index : 31
   -
     text :
      fr-FR : pouce carré
      en-GB : square inch
      fr-CA : pouce carré
      en-US : square inch
     index : 32
   -
     text :
      fr-FR : mètre par seconde
      en-GB : meter per second
      fr-CA : mètre par seconde
      en-US : meter per second
     index : 33
   -
     text :
      fr-FR : mètre par minute
      en-GB : meter per minute
      fr-CA : mètre par minute
      en-US : meter per minute
     index : 34
   -
     text :
      fr-FR : kilomètre par seconde
      en-GB : kilometer per second
      fr-CA : kilomètre par seconde
      en-US : kilometer per second
     index : 35
   -
     text :
      fr-FR : mile par seconde
      en-GB : mile per second
      fr-CA : mile par seconde
      en-US : mile per second
     index : 36
   -
     text :
      fr-FR : mile par heure
      en-GB : mile per hour
      fr-CA : mile par heure
      en-US : mile per hour
     index : 37
   -
     text :
      fr-FR : pied par seconde
      en-GB : foot per second
      fr-CA : pied par seconde
      en-US : foot per second
     index : 38
   -
     text :
      fr-FR : pied par minute
      en-GB : foot per minute
      fr-CA : pied par minute
      en-US : foot per minute
     index : 39
   -
     text :
      fr-FR : minute par kilomètre
      en-GB : minute per kilometer
      fr-CA : minute par kilomètre
      en-US : minute per kilometer
     index : 40
   -
     text :
      fr-FR : noeud
      en-GB : knot
      fr-CA : noeud
      en-US : knot
     index : 41
   -
     text :
      fr-FR : mile nautique par heure
      en-GB : nautical mile per hour
      fr-CA : mile nautique par heure
      en-US : nautical mile per hour
     index : 42
   -
     text :
      fr-FR : vitesse lumière
      en-GB : light speed
      fr-CA : vitesse lumière
      en-US : light speed
     index : 43
   -
     text :
      fr-FR : mètre cube
      en-GB : cubic meter
      fr-CA : mètre cube
      en-US : cubic meter
     index : 44
   -
     text :
      fr-FR : litre
      en-GB : liter
      fr-CA : litre
      en-US : liter
     index : 45
   -
     text :
      fr-FR : pied cube
      en-GB : cubic foot
      fr-CA : pied cube
      en-US : cubic foot
     index : 46
   -
     text :
      fr-FR : pouce cube
      en-GB : cubic inch
      fr-CA : pouce cube
      en-US : cubic inch
     index : 47
   -
     text :
      fr-FR : gallon impérial
      en-GB : imperial gallon
      fr-CA : gallon impérial
      en-US : imperial gallon
     index : 48
   -
     text :
      fr-FR : pinte
      en-GB : pint
      fr-CA : pinte
      en-US : pint
     index : 49
   -
     text :
      fr-FR : baril
      en-GB : barrel
      fr-CA : baril
      en-US : barrel
     index : 50
   -
     text :
      fr-FR : octet
      en-GB : byte
      fr-CA : octet
      en-US : octet
     index : 51
   -
     text :
      fr-FR : al
      en-GB : ly
      fr-CA : al
      en-US : ly
     index : 52
   -
     text :
      fr-FR : vg
      en-GB : yd
      fr-CA : vg
      en-US : yd
     index : 53
   -
     text :
      fr-FR : j
      en-GB : g
      fr-CA : j
      en-US : g
     index : 54
   -
     text :
      fr-FR : ch
      en-GB : hp
      fr-CA : ch
      en-US : hp
     index : 55
   -
     text :
      fr-FR : Aucun fichier ouvert
      en-GB : No open file
      fr-CA : Aucun fichier ouvert
      en-US : No open file
     index : 56
   -
     text :
      fr-FR : "Impossible d'ouvrir le fichier : "
      en-GB : "Impossible to open the file : "
      fr-CA : "Impossible d'ouvrir le fichier : "
      en-US : "Impossible to open the file : "
     index : 57
   -
     text :
      fr-FR : Opération interrompue par l'utilisateur
      en-GB : Operation interrupted by the user
      fr-CA : Opération interrompue par l'utilisateur
      en-US : Operation interrupted by the user
     index : 58
   -
     text :
      fr-FR : "Erreur d'écriture dans le fichier destination #"
      en-GB : "Error writing to the destination file #"
      fr-CA : "Erreur d'écriture dans le fichier destination #"
      en-US : "Error writing to the destination file #"
     index : 59
   -
     text :
      fr-FR : "Impossible de créer le fichier destination #"
      en-GB : "Could not create destination file #"
      fr-CA : "Impossible de créer le fichier destination #"
      en-US : "Could not create destination file #"
     index : 60
   -
     text :
      fr-FR : Le fichier n'existe pas
      en-GB : File does not exist
      fr-CA : Le fichier n'existe pas
      en-US : File does not exist
     index : 61
   -
     text :
      fr-FR : <vide>
      en-GB : <empty>
      fr-CA : <vide>
      en-US : <empty>
     index : 62
   -
     text :
      fr-FR : "Erreur durant le renommage des fichiers découpés : "
      en-GB : "Error while renaming severed files : "
      fr-CA : "Erreur durant le renommage des fichiers découpés : "
      en-US : "Error while renaming severed files : "
     index : 63
   -
     text :
      fr-FR : Date/heure de début invalide
      en-GB : Invalid start date/time
      fr-CA : Date/heure de début invalide
      en-US : Invalid start date/time
     index : 64
   -
     text :
      fr-FR : Date/heure de fin invalide
      en-GB : Invalid start date/time
      fr-CA : Date/heure de fin invalide
      en-US : Invalid start date/time
     index : 65
   -
     text :
      fr-FR : Le caractère %1 n'est pas valide en chiffres romain
      en-GB : The %1 character is not valid in Roman numerals
      fr-CA : Le caractère %1 n'est pas valide en chiffres romain
      en-US : The %1 character is not valid in Roman numerals
     index : 66
   -
     text :
      fr-FR : Le nombre de seconde ne peut pas être négatif
      en-GB : The number of seconds can not be negative
      fr-CA : Le nombre de seconde ne peut pas être négatif
      en-US : The number of seconds can not be negative
     index : 67
   -
     text :
      fr-FR : La date/heure n'est pas valide
      en-GB : Date/time is not valid
      fr-CA : La date/heure n'est pas valide
      en-US : Date/time is not valid
     index : 68
   -
     text :
      fr-FR : Aucun choix de caractères dans les options
      en-GB : No choice of characters in the options
      fr-CA : Aucun choix de caractères dans les options
      en-US : No choice of characters in the options
     index : 69
   -
     text :
      fr-FR : Valeur hors des limites (1 à 3999)
      en-GB : Value out of range (1 to 3999)
      fr-CA : Valeur hors des limites (1 à 3999)
      en-US : Value out of range (1 to 3999)
     index : 70
   -
     text :
      fr-FR : Un GUID doit contenir 16 caractères
      en-GB : A GUID must contain 16 characters
      fr-CA : Un GUID doit contenir 16 caractères
      en-US : A GUID must contain 16 characters
     index : 71
   -
     text :
      fr-FR : La valeur à convertir doit avoir un nombre pair de caractères
      en-GB : The value to be converted must have an even number of characters
      fr-CA : La valeur à convertir doit avoir un nombre pair de caractères
      en-US : The value to be converted must have an even number of characters
     index : 72
   -
     text :
      fr-FR : Allemand
      en-GB : German
      fr-CA : Allemand
      en-US : German
     index : 73
   -
     text :
      fr-FR : Américain
      en-GB : American
      fr-CA : Américain
      en-US : American
     index : 74
   -
     text :
      fr-FR : Inconnu
      en-GB : Unknown
      fr-CA : Inconnu
      en-US : Unknown
     index : 75
   -
     text :
      fr-FR : Anglais
      en-GB : English
      fr-CA : Anglais
      en-US : English
     index : 76
   -
     text :
      fr-FR : L'objet n'est pas un tableau associatif
      en-GB : The object is not an associative array
      fr-CA : L'objet n'est pas un tableau associatif
      en-US : The object is not an associative array
     index : 77
   -
     text :
      fr-FR : Date invalide
      en-GB : Invalid date
      fr-CA : Date invalide
      en-US : Invalid date
     index : 78
   -
     text :
      fr-FR : L'année doit être minimum 1800
      en-GB : The year must be minimum 1800
      fr-CA : L'année doit être minimum 1800
      en-US : The year must be minimum 1800
     index : 79
   -
     text :
      fr-FR : Pas assez de choix de caractères pour construire la chaîne
      en-GB : Not enough character choices to build the string
      fr-CA : Pas assez de choix de caractères pour construire la chaîne
      en-US : Not enough character choices to build the string
     index : 80
   -
     text :
      fr-FR : 1er
      en-GB : 1st
      fr-CA : 1er
      en-US : 1st
     index : 81
   -
     text :
      fr-FR : 2nd
      en-GB : 2d
      fr-CA : 2nd
      en-US : 2d
     index : 82
   -
     text :
      fr-FR : 3ème
      en-GB : 3rd
      fr-CA : 3ème
      en-US : 3rd
     index : 83
   -
     text :
      fr-FR : ème
      en-GB : th
      fr-CA : ème
      en-US : th
     index : 84
   -
     text :
      fr-FR : pi
      en-GB : ft
      fr-CA : pi
      en-US : ft
     index : 85
   -
     text :
      fr-FR : po
      en-GB : in
      fr-CA : po
      en-US : in
     index : 86
   -
     text :
      fr-FR : Le paramètre passé n'est pas une unité (voir ENunitéxxx)
      en-GB : The parameter passed is not a unit (see ENunitxxx)
      fr-CA : Le paramètre passé n'est pas une unité (voir ENunitéxxx)
      en-US : The parameter passed is not a unit (see ENunitxxx)
     index : 87
   -
     text :
      fr-FR : Le paramètre passé n'est pas un multiplicateur (voir EMultiplicateur et EMultiInformatique)
      en-GB : The parameter passed is not a multiplier (see EMultipliateur and EMultiInformatique)
      fr-CA : Le paramètre passé n'est pas un multiplicateur (voir EMultiplicateur et EMultiInformatique)
      en-US : The parameter passed is not a multiplier (see EMultipliateur and EMultiInformatique)
     index : 88
custom_note :
 internal_properties : CQAAAAkAAABtB9HWVzrXO2+4NDRVK0vmzaNKrCKqH1DBX30lMmGZ
